/* CrawlerCtrl.h
   Generated by wsdl2h 1.2.15 from http://10.8.0.55:8081/WebServiceCrawler/services/CrawlerCtrl?wsdl and typemap.dat
   2010-02-02 08:50:57 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2001-2009 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Build Notes

NOTE:

 - Run soapcpp2 on CrawlerCtrl.h to generate the SOAP/XML processing logic.
   Use soapcpp2 option -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 option -i to generate improved proxy and server classes.
 - Use wsdl2h options -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h options -nname and -Nname to globally rename the prefix 'ns'.
 - Use wsdl2h option -d to enable DOM support for xsd:anyType.
 - Use wsdl2h option -g to auto-generate readers and writers for root elements.

WARNING:

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS.
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following two licenses:
GPL or Genivia's license for commercial use.

GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org
--------------------------------------------------------------------------------
A commercial use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *   http://crawler.nyapc                                                     *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

nyapc1 = "http://crawler.nyapc"
nyapc2 = "http://dao.crawler.nyapc"

*/

#define SOAP_NAMESPACE_OF_nyapc1	"http://crawler.nyapc"
//gsoap nyapc1 schema namespace:	http://crawler.nyapc
//gsoap nyapc1 schema elementForm:	qualified
//gsoap nyapc1 schema attributeForm:	unqualified

#define SOAP_NAMESPACE_OF_nyapc2	"http://dao.crawler.nyapc"
//gsoap nyapc2 schema namespace:	http://dao.crawler.nyapc
//gsoap nyapc2 schema elementForm:	qualified
//gsoap nyapc2 schema attributeForm:	unqualified

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class nyapc1__JobAtt.
class nyapc1__JobAtt;

//  Forward declaration of class nyapc1__Task.
class nyapc1__Task;

//  Forward declaration of class _nyapc1__add.
class _nyapc1__add;

//  Forward declaration of class _nyapc1__addResponse.
class _nyapc1__addResponse;

//  Forward declaration of class _nyapc1__getVersion.
class _nyapc1__getVersion;

//  Forward declaration of class _nyapc1__getVersionResponse.
class _nyapc1__getVersionResponse;

//  Forward declaration of class _nyapc1__getJob.
class _nyapc1__getJob;

//  Forward declaration of class _nyapc1__getJobResponse.
class _nyapc1__getJobResponse;

//  Forward declaration of class _nyapc1__addJob.
class _nyapc1__addJob;

//  Forward declaration of class _nyapc1__addJobResponse.
class _nyapc1__addJobResponse;

//  Forward declaration of class _nyapc1__hasTask.
class _nyapc1__hasTask;

//  Forward declaration of class _nyapc1__hasTaskResponse.
class _nyapc1__hasTaskResponse;

//  Forward declaration of class _nyapc1__updateJob.
class _nyapc1__updateJob;

//  Forward declaration of class _nyapc1__updateJobResponse.
class _nyapc1__updateJobResponse;

//  Forward declaration of class _nyapc1__getWrapper.
class _nyapc1__getWrapper;

//  Forward declaration of class _nyapc1__getWrapperResponse.
class _nyapc1__getWrapperResponse;

//  Forward declaration of class _nyapc1__addWrapper.
class _nyapc1__addWrapper;

//  Forward declaration of class _nyapc1__addWrapperResponse.
class _nyapc1__addWrapperResponse;

//  Forward declaration of class _nyapc1__getTask.
class _nyapc1__getTask;

//  Forward declaration of class _nyapc1__getTaskResponse.
class _nyapc1__getTaskResponse;

//  Forward declaration of class _nyapc1__getWrapTask.
class _nyapc1__getWrapTask;

//  Forward declaration of class _nyapc1__getWrapTaskResponse.
class _nyapc1__getWrapTaskResponse;

//  Forward declaration of class _nyapc1__takeWrapTask.
class _nyapc1__takeWrapTask;

//  Forward declaration of class _nyapc1__takeWrapTaskResponse.
class _nyapc1__takeWrapTaskResponse;

//  Forward declaration of class _nyapc1__getWrapInvalidTask.
class _nyapc1__getWrapInvalidTask;

//  Forward declaration of class _nyapc1__getWrapInvalidTaskResponse.
class _nyapc1__getWrapInvalidTaskResponse;

//  Forward declaration of class _nyapc1__updateWrapper.
class _nyapc1__updateWrapper;

//  Forward declaration of class _nyapc1__updateWrapperResponse.
class _nyapc1__updateWrapperResponse;

//  Forward declaration of class _nyapc1__updateWrapperCheckOk.
class _nyapc1__updateWrapperCheckOk;

//  Forward declaration of class _nyapc1__updateWrapperCheckOkResponse.
class _nyapc1__updateWrapperCheckOkResponse;

//  Forward declaration of class _nyapc1__getStat.
class _nyapc1__getStat;

//  Forward declaration of class _nyapc1__getStatResponse.
class _nyapc1__getStatResponse;

//  Forward declaration of class _nyapc1__putResult.
class _nyapc1__putResult;

//  Forward declaration of class _nyapc1__putResultResponse.
class _nyapc1__putResultResponse;

//  Forward declaration of class _nyapc1__getJobID.
class _nyapc1__getJobID;

//  Forward declaration of class _nyapc1__getJobIDResponse.
class _nyapc1__getJobIDResponse;

//  Forward declaration of class _nyapc1__getJobs.
class _nyapc1__getJobs;

//  Forward declaration of class _nyapc1__getJobsResponse.
class _nyapc1__getJobsResponse;

//  Forward declaration of class _nyapc1__getJobsWrapStatInvalid.
class _nyapc1__getJobsWrapStatInvalid;

//  Forward declaration of class _nyapc1__getJobsWrapStatInvalidResponse.
class _nyapc1__getJobsWrapStatInvalidResponse;

//  Forward declaration of class _nyapc1__getWrapGen.
class _nyapc1__getWrapGen;

//  Forward declaration of class _nyapc1__getWrapGenResponse.
class _nyapc1__getWrapGenResponse;

//  Forward declaration of class _nyapc1__updateWrapGen.
class _nyapc1__updateWrapGen;

//  Forward declaration of class _nyapc1__updateWrapGenResponse.
class _nyapc1__updateWrapGenResponse;

//  Forward declaration of class _nyapc1__getTaskQueue.
class _nyapc1__getTaskQueue;

//  Forward declaration of class _nyapc1__getTaskQueueResponse.
class _nyapc1__getTaskQueueResponse;

//  Forward declaration of class _nyapc1__getWrapTaskQueue.
class _nyapc1__getWrapTaskQueue;

//  Forward declaration of class _nyapc1__getWrapTaskQueueResponse.
class _nyapc1__getWrapTaskQueueResponse;

//  Forward declaration of class _nyapc1__takeTask.
class _nyapc1__takeTask;

//  Forward declaration of class _nyapc1__takeTaskResponse.
class _nyapc1__takeTaskResponse;

//  Forward declaration of class _nyapc1__getTaskByJobId.
class _nyapc1__getTaskByJobId;

//  Forward declaration of class _nyapc1__getTaskByJobIdResponse.
class _nyapc1__getTaskByJobIdResponse;

//  Forward declaration of class _nyapc1__delJob.
class _nyapc1__delJob;

//  Forward declaration of class _nyapc1__delJobResponse.
class _nyapc1__delJobResponse;

//  Forward declaration of class _nyapc1__updateJobUrl.
class _nyapc1__updateJobUrl;

//  Forward declaration of class _nyapc1__updateJobUrlResponse.
class _nyapc1__updateJobUrlResponse;

//  Forward declaration of class _nyapc1__getWrapInvalidTaskByJobId.
class _nyapc1__getWrapInvalidTaskByJobId;

//  Forward declaration of class _nyapc1__getWrapInvalidTaskByJobIdResponse.
class _nyapc1__getWrapInvalidTaskByJobIdResponse;

//  Forward declaration of class _nyapc1__getWrapId.
class _nyapc1__getWrapId;

//  Forward declaration of class _nyapc1__getWrapIdResponse.
class _nyapc1__getWrapIdResponse;

//  Forward declaration of class _nyapc1__getWraptype.
class _nyapc1__getWraptype;

//  Forward declaration of class _nyapc1__getWraptypeResponse.
class _nyapc1__getWraptypeResponse;

//  Forward declaration of class nyapc2__AttSuperClass.
class nyapc2__AttSuperClass;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://crawler.nyapc                                                     *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://dao.crawler.nyapc                                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://dao.crawler.nyapc                                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://crawler.nyapc                                                     *
 *                                                                            *
\******************************************************************************/


/// "http://crawler.nyapc":JobAtt is a complexType.
class nyapc1__JobAtt
{ public:
/// Element comment of type xs:string.
    std::string*                         comment                       ;	///< Nullable pointer.
/// Element createTime of type xs:string.
    std::string*                         createTime                    ;	///< Nullable pointer.
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// Element jobStat of type xs:string.
    std::string*                         jobStat                       ;	///< Nullable pointer.
/// Element name of type xs:string.
    std::string*                         name                          ;	///< Nullable pointer.
/// Element seed of type xs:string.
    std::string*                         seed                          ;	///< Nullable pointer.
/// Element seedType of type xs:string.
    std::string*                         seedType                      ;	///< Nullable pointer.
/// Element updateTime of type xs:string.
    std::string*                         updateTime                    ;	///< Nullable pointer.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":add

/// "http://crawler.nyapc":add is a complexType.
class _nyapc1__add
{ public:
/// Element s of type xs:string.
    std::string                          s                              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":addResponse

/// "http://crawler.nyapc":addResponse is a complexType.
class _nyapc1__addResponse
{ public:
/// Element addReturn of type xs:string.
    std::string                          addReturn                      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getVersion

/// "http://crawler.nyapc":getVersion is a complexType.
class _nyapc1__getVersion
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getVersionResponse

/// "http://crawler.nyapc":getVersionResponse is a complexType.
class _nyapc1__getVersionResponse
{ public:
/// Element getVersionReturn of type xs:int.
    int                                  getVersionReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJob

/// "http://crawler.nyapc":getJob is a complexType.
class _nyapc1__getJob
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobResponse

/// "http://crawler.nyapc":getJobResponse is a complexType.
class _nyapc1__getJobResponse
{ public:
/// Element getJobReturn of type "http://crawler.nyapc":JobAtt.
    nyapc1__JobAtt*                      getJobReturn                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":addJob

/// "http://crawler.nyapc":addJob is a complexType.
class _nyapc1__addJob
{ public:
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// Element url of type xs:string.
    std::string                          url                            1;	///< Required element.
/// Element type of type xs:string.
    std::string                          type                           1;	///< Required element.
/// Element comment of type xs:string.
    std::string                          comment                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":addJobResponse

/// "http://crawler.nyapc":addJobResponse is a complexType.
class _nyapc1__addJobResponse
{ public:
/// Element addJobReturn of type xs:int.
    int                                  addJobReturn                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":hasTask

/// "http://crawler.nyapc":hasTask is a complexType.
class _nyapc1__hasTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":hasTaskResponse

/// "http://crawler.nyapc":hasTaskResponse is a complexType.
class _nyapc1__hasTaskResponse
{ public:
/// Element hasTaskReturn of type xs:boolean.
    bool                                 hasTaskReturn                  1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateJob

/// "http://crawler.nyapc":updateJob is a complexType.
class _nyapc1__updateJob
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateJobResponse

/// "http://crawler.nyapc":updateJobResponse is a complexType.
class _nyapc1__updateJobResponse
{ public:
/// Element updateJobReturn of type xs:boolean.
    bool                                 updateJobReturn                1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapper

/// "http://crawler.nyapc":getWrapper is a complexType.
class _nyapc1__getWrapper
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapperResponse

/// "http://crawler.nyapc":getWrapperResponse is a complexType.
class _nyapc1__getWrapperResponse
{ public:
/// Element getWrapperReturn of type xs:string.
    std::string                          getWrapperReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":addWrapper

/// "http://crawler.nyapc":addWrapper is a complexType.
class _nyapc1__addWrapper
{ public:
/// Element jobId of type xs:int.
    int                                  jobId                          1;	///< Required element.
/// Element type of type xs:string.
    std::string                          type                           1;	///< Required element.
/// Element Wrapper of type xs:string.
    std::string                          Wrapper                        1;	///< Required element.
/// Element vargen of type xs:string.
    std::string                          vargen                         1;	///< Required element.
/// Element comment of type xs:string.
    std::string                          comment                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":addWrapperResponse

/// "http://crawler.nyapc":addWrapperResponse is a complexType.
class _nyapc1__addWrapperResponse
{ public:
/// Element addWrapperReturn of type xs:boolean.
    bool                                 addWrapperReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTask

/// "http://crawler.nyapc":getTask is a complexType.
class _nyapc1__getTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTaskResponse

/// "http://crawler.nyapc":getTaskResponse is a complexType.
class _nyapc1__getTaskResponse
{ public:
/// Element getTaskReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getTaskReturn                  1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapTask

/// "http://crawler.nyapc":getWrapTask is a complexType.
class _nyapc1__getWrapTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapTaskResponse

/// "http://crawler.nyapc":getWrapTaskResponse is a complexType.
class _nyapc1__getWrapTaskResponse
{ public:
/// Element getWrapTaskReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getWrapTaskReturn              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":takeWrapTask

/// "http://crawler.nyapc":takeWrapTask is a complexType.
class _nyapc1__takeWrapTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":takeWrapTaskResponse

/// "http://crawler.nyapc":takeWrapTaskResponse is a complexType.
class _nyapc1__takeWrapTaskResponse
{ public:
/// Element takeWrapTaskReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        takeWrapTaskReturn             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapInvalidTask

/// "http://crawler.nyapc":getWrapInvalidTask is a complexType.
class _nyapc1__getWrapInvalidTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapInvalidTaskResponse

/// "http://crawler.nyapc":getWrapInvalidTaskResponse is a complexType.
class _nyapc1__getWrapInvalidTaskResponse
{ public:
/// Element getWrapInvalidTaskReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getWrapInvalidTaskReturn       1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapper

/// "http://crawler.nyapc":updateWrapper is a complexType.
class _nyapc1__updateWrapper
{ public:
/// Element wrap of type xs:string.
    std::string                          wrap                           1;	///< Required element.
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// Element taskid of type xs:int.
    int                                  taskid                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapperResponse

/// "http://crawler.nyapc":updateWrapperResponse is a complexType.
class _nyapc1__updateWrapperResponse
{ public:
/// Element updateWrapperReturn of type xs:boolean.
    bool                                 updateWrapperReturn            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapperCheckOk

/// "http://crawler.nyapc":updateWrapperCheckOk is a complexType.
class _nyapc1__updateWrapperCheckOk
{ public:
/// Element wrap of type xs:string.
    std::string                          wrap                           1;	///< Required element.
/// Element wrapId of type xs:int.
    int                                  wrapId                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapperCheckOkResponse

/// "http://crawler.nyapc":updateWrapperCheckOkResponse is a complexType.
class _nyapc1__updateWrapperCheckOkResponse
{ public:
/// Element updateWrapperCheckOkReturn of type xs:boolean.
    bool                                 updateWrapperCheckOkReturn     1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getStat

/// "http://crawler.nyapc":getStat is a complexType.
class _nyapc1__getStat
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getStatResponse

/// "http://crawler.nyapc":getStatResponse is a complexType.
class _nyapc1__getStatResponse
{ public:
/// Element getStatReturn of type xs:int.
    int                                  getStatReturn                  1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":putResult

/// "http://crawler.nyapc":putResult is a complexType.
class _nyapc1__putResult
{ public:
/// Element res of type xs:string.
    std::string                          res                            1;	///< Required element.
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":putResultResponse

/// "http://crawler.nyapc":putResultResponse is a complexType.
class _nyapc1__putResultResponse
{ public:
/// Element putResultReturn of type xs:boolean.
    bool                                 putResultReturn                1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobID

/// "http://crawler.nyapc":getJobID is a complexType.
class _nyapc1__getJobID
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobIDResponse

/// "http://crawler.nyapc":getJobIDResponse is a complexType.
class _nyapc1__getJobIDResponse
{ public:
/// Vector of int with length 1..unbounded
    std::vector<int                    > getJobIDReturn                 1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobs

/// "http://crawler.nyapc":getJobs is a complexType.
class _nyapc1__getJobs
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobsResponse

/// "http://crawler.nyapc":getJobsResponse is a complexType.
class _nyapc1__getJobsResponse
{ public:
/// Vector of nyapc1__JobAtt* with length 1..unbounded
    std::vector<nyapc1__JobAtt*        > getJobsReturn                  1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobsWrapStatInvalid

/// "http://crawler.nyapc":getJobsWrapStatInvalid is a complexType.
class _nyapc1__getJobsWrapStatInvalid
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getJobsWrapStatInvalidResponse

/// "http://crawler.nyapc":getJobsWrapStatInvalidResponse is a complexType.
class _nyapc1__getJobsWrapStatInvalidResponse
{ public:
/// Vector of nyapc1__JobAtt* with length 1..unbounded
    std::vector<nyapc1__JobAtt*        > getJobsWrapStatInvalidReturn   1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapGen

/// "http://crawler.nyapc":getWrapGen is a complexType.
class _nyapc1__getWrapGen
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapGenResponse

/// "http://crawler.nyapc":getWrapGenResponse is a complexType.
class _nyapc1__getWrapGenResponse
{ public:
/// Element getWrapGenReturn of type xs:string.
    std::string                          getWrapGenReturn               1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapGen

/// "http://crawler.nyapc":updateWrapGen is a complexType.
class _nyapc1__updateWrapGen
{ public:
/// Element wrapgen of type xs:string.
    std::string                          wrapgen                        1;	///< Required element.
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateWrapGenResponse

/// "http://crawler.nyapc":updateWrapGenResponse is a complexType.
class _nyapc1__updateWrapGenResponse
{ public:
/// Element updateWrapGenReturn of type xs:boolean.
    bool                                 updateWrapGenReturn            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTaskQueue

/// "http://crawler.nyapc":getTaskQueue is a complexType.
class _nyapc1__getTaskQueue
{ public:
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTaskQueueResponse

/// "http://crawler.nyapc":getTaskQueueResponse is a complexType.
class _nyapc1__getTaskQueueResponse
{ public:
/// Element getTaskQueueReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getTaskQueueReturn             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapTaskQueue

/// "http://crawler.nyapc":getWrapTaskQueue is a complexType.
class _nyapc1__getWrapTaskQueue
{ public:
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapTaskQueueResponse

/// "http://crawler.nyapc":getWrapTaskQueueResponse is a complexType.
class _nyapc1__getWrapTaskQueueResponse
{ public:
/// Element getWrapTaskQueueReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getWrapTaskQueueReturn         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":takeTask

/// "http://crawler.nyapc":takeTask is a complexType.
class _nyapc1__takeTask
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":takeTaskResponse

/// "http://crawler.nyapc":takeTaskResponse is a complexType.
class _nyapc1__takeTaskResponse
{ public:
/// Element takeTaskReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        takeTaskReturn                 1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTaskByJobId

/// "http://crawler.nyapc":getTaskByJobId is a complexType.
class _nyapc1__getTaskByJobId
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// Element jid of type xs:int.
    int                                  jid                            1;	///< Required element.
/// Element type of type xs:string.
    std::string                          type                           1;	///< Required element.
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getTaskByJobIdResponse

/// "http://crawler.nyapc":getTaskByJobIdResponse is a complexType.
class _nyapc1__getTaskByJobIdResponse
{ public:
/// Element getTaskByJobIdReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getTaskByJobIdReturn           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":delJob

/// "http://crawler.nyapc":delJob is a complexType.
class _nyapc1__delJob
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":delJobResponse

/// "http://crawler.nyapc":delJobResponse is a complexType.
class _nyapc1__delJobResponse
{ public:
/// Element delJobReturn of type xs:boolean.
    bool                                 delJobReturn                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateJobUrl

/// "http://crawler.nyapc":updateJobUrl is a complexType.
class _nyapc1__updateJobUrl
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// Element url of type xs:string.
    std::string                          url                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":updateJobUrlResponse

/// "http://crawler.nyapc":updateJobUrlResponse is a complexType.
class _nyapc1__updateJobUrlResponse
{ public:
/// Element updateJobUrlReturn of type xs:boolean.
    bool                                 updateJobUrlReturn             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapInvalidTaskByJobId

/// "http://crawler.nyapc":getWrapInvalidTaskByJobId is a complexType.
class _nyapc1__getWrapInvalidTaskByJobId
{ public:
/// Element cid of type xs:int.
    int                                  cid                            1;	///< Required element.
/// Element jid of type xs:int.
    int                                  jid                            1;	///< Required element.
/// Element type of type xs:string.
    std::string                          type                           1;	///< Required element.
/// Element num of type xs:int.
    int                                  num                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapInvalidTaskByJobIdResponse

/// "http://crawler.nyapc":getWrapInvalidTaskByJobIdResponse is a complexType.
class _nyapc1__getWrapInvalidTaskByJobIdResponse
{ public:
/// Element getWrapInvalidTaskByJobIdReturn of type "http://crawler.nyapc":Task.
    nyapc1__Task*                        getWrapInvalidTaskByJobIdReturn 1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapId

/// "http://crawler.nyapc":getWrapId is a complexType.
class _nyapc1__getWrapId
{ public:
/// Element jid of type xs:int.
    int                                  jid                            1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWrapIdResponse

/// "http://crawler.nyapc":getWrapIdResponse is a complexType.
class _nyapc1__getWrapIdResponse
{ public:
/// Vector of int with length 1..unbounded
    std::vector<int                    > getWrapIdReturn                1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWraptype

/// "http://crawler.nyapc":getWraptype is a complexType.
class _nyapc1__getWraptype
{ public:
/// Element id of type xs:int.
    int                                  id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://crawler.nyapc":getWraptypeResponse

/// "http://crawler.nyapc":getWraptypeResponse is a complexType.
class _nyapc1__getWraptypeResponse
{ public:
/// Element getWraptypeReturn of type xs:string.
    std::string                          getWraptypeReturn              1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://dao.crawler.nyapc                                                 *
 *                                                                            *
\******************************************************************************/


/// "http://dao.crawler.nyapc":AttSuperClass is an abstract complexType.
class nyapc2__AttSuperClass
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://crawler.nyapc":Task is a complexType with complexContent extension of "http://dao.crawler.nyapc":AttSuperClass.
class nyapc1__Task : public nyapc2__AttSuperClass
{ public:
/*  INHERITED FROM nyapc2__AttSuperClass:
    END OF INHERITED */
/// Element ids of type xs:string.
    std::string*                         ids                           ;	///< Nullable pointer.
/// Element job_id of type xs:int.
    int                                  job_USCOREid                   1;	///< Required element.
/// Element taskId of type xs:int.
    int                                  taskId                         1;	///< Required element.
/// Element type of type xs:string.
    std::string*                         type                          ;	///< Nullable pointer.
/// Element urls of type xs:string.
    std::string*                         urls                          ;	///< Nullable pointer.
/// Element wrap_id of type xs:int.
    int                                  wrap_USCOREid                  1;	///< Required element.
/// Element wrap_version of type xs:int.
    int                                  wrap_USCOREversion             1;	///< Required element.
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://crawler.nyapc                                                     *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://crawler.nyapc                                                     *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://dao.crawler.nyapc                                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://dao.crawler.nyapc                                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/


//gsoap nyapc1 service name:	CrawlerCtrlSoapBinding 
//gsoap nyapc1 service type:	CrawlerCtrl 
//gsoap nyapc1 service port:	http://10.8.0.55:8081/WebServiceCrawler/services/CrawlerCtrl 
//gsoap nyapc1 service namespace:	http://crawler.nyapc 
//gsoap nyapc1 service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage Service Definitions

@section Service_bindings Service Bindings
  - @ref CrawlerCtrlSoapBinding

@section Service_more More Information
- @ref page_notes "Notes"
- @ref page_XMLDataBinding "XML Data Binding"
- @ref SOAP_ENV__Header "SOAP Header Content"
- @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page CrawlerCtrlSoapBinding Binding "CrawlerCtrlSoapBinding"

@section CrawlerCtrlSoapBinding_operations Operations of Binding  "CrawlerCtrlSoapBinding"
  - @ref __nyapc1__add
  - @ref __nyapc1__getVersion
  - @ref __nyapc1__getJob
  - @ref __nyapc1__addJob
  - @ref __nyapc1__hasTask
  - @ref __nyapc1__updateJob
  - @ref __nyapc1__getWrapper
  - @ref __nyapc1__addWrapper
  - @ref __nyapc1__getTask
  - @ref __nyapc1__getWrapTask
  - @ref __nyapc1__takeWrapTask
  - @ref __nyapc1__getWrapInvalidTask
  - @ref __nyapc1__updateWrapper
  - @ref __nyapc1__updateWrapperCheckOk
  - @ref __nyapc1__getStat
  - @ref __nyapc1__putResult
  - @ref __nyapc1__getJobID
  - @ref __nyapc1__getJobs
  - @ref __nyapc1__getJobsWrapStatInvalid
  - @ref __nyapc1__getWrapGen
  - @ref __nyapc1__updateWrapGen
  - @ref __nyapc1__getTaskQueue
  - @ref __nyapc1__getWrapTaskQueue
  - @ref __nyapc1__takeTask
  - @ref __nyapc1__getTaskByJobId
  - @ref __nyapc1__delJob
  - @ref __nyapc1__updateJobUrl
  - @ref __nyapc1__getWrapInvalidTaskByJobId
  - @ref __nyapc1__getWrapId
  - @ref __nyapc1__getWraptype

@section CrawlerCtrlSoapBinding_ports Endpoints of Binding  "CrawlerCtrlSoapBinding"
  - http://10.8.0.55:8081/WebServiceCrawler/services/CrawlerCtrl

Note: use wsdl2h option -N to change the service binding prefix name

*/

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   CrawlerCtrlSoapBinding                                                   *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__add                                                            *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__add" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__add(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__add*                       nyapc1__add,
    // response parameters:
    _nyapc1__addResponse*               nyapc1__addResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__add(
    struct soap *soap,
    // request parameters:
    _nyapc1__add*                       nyapc1__add,
    // response parameters:
    _nyapc1__addResponse*               nyapc1__addResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	add document
//gsoap nyapc1 service method-encoding:	add literal
//gsoap nyapc1 service method-action:	add ""
int __nyapc1__add(
    _nyapc1__add*                       nyapc1__add,	///< Request parameter
    _nyapc1__addResponse*               nyapc1__addResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getVersion                                                     *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getVersion" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getVersion(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getVersion*                nyapc1__getVersion,
    // response parameters:
    _nyapc1__getVersionResponse*        nyapc1__getVersionResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getVersion(
    struct soap *soap,
    // request parameters:
    _nyapc1__getVersion*                nyapc1__getVersion,
    // response parameters:
    _nyapc1__getVersionResponse*        nyapc1__getVersionResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getVersion document
//gsoap nyapc1 service method-encoding:	getVersion literal
//gsoap nyapc1 service method-action:	getVersion ""
int __nyapc1__getVersion(
    _nyapc1__getVersion*                nyapc1__getVersion,	///< Request parameter
    _nyapc1__getVersionResponse*        nyapc1__getVersionResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getJob                                                         *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getJob" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getJob(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getJob*                    nyapc1__getJob,
    // response parameters:
    _nyapc1__getJobResponse*            nyapc1__getJobResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getJob(
    struct soap *soap,
    // request parameters:
    _nyapc1__getJob*                    nyapc1__getJob,
    // response parameters:
    _nyapc1__getJobResponse*            nyapc1__getJobResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getJob document
//gsoap nyapc1 service method-encoding:	getJob literal
//gsoap nyapc1 service method-action:	getJob ""
int __nyapc1__getJob(
    _nyapc1__getJob*                    nyapc1__getJob,	///< Request parameter
    _nyapc1__getJobResponse*            nyapc1__getJobResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__addJob                                                         *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__addJob" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__addJob(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__addJob*                    nyapc1__addJob,
    // response parameters:
    _nyapc1__addJobResponse*            nyapc1__addJobResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__addJob(
    struct soap *soap,
    // request parameters:
    _nyapc1__addJob*                    nyapc1__addJob,
    // response parameters:
    _nyapc1__addJobResponse*            nyapc1__addJobResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	addJob document
//gsoap nyapc1 service method-encoding:	addJob literal
//gsoap nyapc1 service method-action:	addJob ""
int __nyapc1__addJob(
    _nyapc1__addJob*                    nyapc1__addJob,	///< Request parameter
    _nyapc1__addJobResponse*            nyapc1__addJobResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__hasTask                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__hasTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__hasTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__hasTask*                   nyapc1__hasTask,
    // response parameters:
    _nyapc1__hasTaskResponse*           nyapc1__hasTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__hasTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__hasTask*                   nyapc1__hasTask,
    // response parameters:
    _nyapc1__hasTaskResponse*           nyapc1__hasTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	hasTask document
//gsoap nyapc1 service method-encoding:	hasTask literal
//gsoap nyapc1 service method-action:	hasTask ""
int __nyapc1__hasTask(
    _nyapc1__hasTask*                   nyapc1__hasTask,	///< Request parameter
    _nyapc1__hasTaskResponse*           nyapc1__hasTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__updateJob                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__updateJob" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__updateJob(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__updateJob*                 nyapc1__updateJob,
    // response parameters:
    _nyapc1__updateJobResponse*         nyapc1__updateJobResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__updateJob(
    struct soap *soap,
    // request parameters:
    _nyapc1__updateJob*                 nyapc1__updateJob,
    // response parameters:
    _nyapc1__updateJobResponse*         nyapc1__updateJobResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	updateJob document
//gsoap nyapc1 service method-encoding:	updateJob literal
//gsoap nyapc1 service method-action:	updateJob ""
int __nyapc1__updateJob(
    _nyapc1__updateJob*                 nyapc1__updateJob,	///< Request parameter
    _nyapc1__updateJobResponse*         nyapc1__updateJobResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapper                                                     *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapper" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapper(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapper*                nyapc1__getWrapper,
    // response parameters:
    _nyapc1__getWrapperResponse*        nyapc1__getWrapperResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapper(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapper*                nyapc1__getWrapper,
    // response parameters:
    _nyapc1__getWrapperResponse*        nyapc1__getWrapperResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapper document
//gsoap nyapc1 service method-encoding:	getWrapper literal
//gsoap nyapc1 service method-action:	getWrapper ""
int __nyapc1__getWrapper(
    _nyapc1__getWrapper*                nyapc1__getWrapper,	///< Request parameter
    _nyapc1__getWrapperResponse*        nyapc1__getWrapperResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__addWrapper                                                     *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__addWrapper" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__addWrapper(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__addWrapper*                nyapc1__addWrapper,
    // response parameters:
    _nyapc1__addWrapperResponse*        nyapc1__addWrapperResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__addWrapper(
    struct soap *soap,
    // request parameters:
    _nyapc1__addWrapper*                nyapc1__addWrapper,
    // response parameters:
    _nyapc1__addWrapperResponse*        nyapc1__addWrapperResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	addWrapper document
//gsoap nyapc1 service method-encoding:	addWrapper literal
//gsoap nyapc1 service method-action:	addWrapper ""
int __nyapc1__addWrapper(
    _nyapc1__addWrapper*                nyapc1__addWrapper,	///< Request parameter
    _nyapc1__addWrapperResponse*        nyapc1__addWrapperResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getTask                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getTask*                   nyapc1__getTask,
    // response parameters:
    _nyapc1__getTaskResponse*           nyapc1__getTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__getTask*                   nyapc1__getTask,
    // response parameters:
    _nyapc1__getTaskResponse*           nyapc1__getTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getTask document
//gsoap nyapc1 service method-encoding:	getTask literal
//gsoap nyapc1 service method-action:	getTask ""
int __nyapc1__getTask(
    _nyapc1__getTask*                   nyapc1__getTask,	///< Request parameter
    _nyapc1__getTaskResponse*           nyapc1__getTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapTask                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapTask*               nyapc1__getWrapTask,
    // response parameters:
    _nyapc1__getWrapTaskResponse*       nyapc1__getWrapTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapTask*               nyapc1__getWrapTask,
    // response parameters:
    _nyapc1__getWrapTaskResponse*       nyapc1__getWrapTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapTask document
//gsoap nyapc1 service method-encoding:	getWrapTask literal
//gsoap nyapc1 service method-action:	getWrapTask ""
int __nyapc1__getWrapTask(
    _nyapc1__getWrapTask*               nyapc1__getWrapTask,	///< Request parameter
    _nyapc1__getWrapTaskResponse*       nyapc1__getWrapTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__takeWrapTask                                                   *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__takeWrapTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__takeWrapTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__takeWrapTask*              nyapc1__takeWrapTask,
    // response parameters:
    _nyapc1__takeWrapTaskResponse*      nyapc1__takeWrapTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__takeWrapTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__takeWrapTask*              nyapc1__takeWrapTask,
    // response parameters:
    _nyapc1__takeWrapTaskResponse*      nyapc1__takeWrapTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	takeWrapTask document
//gsoap nyapc1 service method-encoding:	takeWrapTask literal
//gsoap nyapc1 service method-action:	takeWrapTask ""
int __nyapc1__takeWrapTask(
    _nyapc1__takeWrapTask*              nyapc1__takeWrapTask,	///< Request parameter
    _nyapc1__takeWrapTaskResponse*      nyapc1__takeWrapTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapInvalidTask                                             *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapInvalidTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapInvalidTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapInvalidTask*        nyapc1__getWrapInvalidTask,
    // response parameters:
    _nyapc1__getWrapInvalidTaskResponse* nyapc1__getWrapInvalidTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapInvalidTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapInvalidTask*        nyapc1__getWrapInvalidTask,
    // response parameters:
    _nyapc1__getWrapInvalidTaskResponse* nyapc1__getWrapInvalidTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapInvalidTask document
//gsoap nyapc1 service method-encoding:	getWrapInvalidTask literal
//gsoap nyapc1 service method-action:	getWrapInvalidTask ""
int __nyapc1__getWrapInvalidTask(
    _nyapc1__getWrapInvalidTask*        nyapc1__getWrapInvalidTask,	///< Request parameter
    _nyapc1__getWrapInvalidTaskResponse* nyapc1__getWrapInvalidTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__updateWrapper                                                  *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__updateWrapper" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__updateWrapper(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__updateWrapper*             nyapc1__updateWrapper,
    // response parameters:
    _nyapc1__updateWrapperResponse*     nyapc1__updateWrapperResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__updateWrapper(
    struct soap *soap,
    // request parameters:
    _nyapc1__updateWrapper*             nyapc1__updateWrapper,
    // response parameters:
    _nyapc1__updateWrapperResponse*     nyapc1__updateWrapperResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	updateWrapper document
//gsoap nyapc1 service method-encoding:	updateWrapper literal
//gsoap nyapc1 service method-action:	updateWrapper ""
int __nyapc1__updateWrapper(
    _nyapc1__updateWrapper*             nyapc1__updateWrapper,	///< Request parameter
    _nyapc1__updateWrapperResponse*     nyapc1__updateWrapperResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__updateWrapperCheckOk                                           *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__updateWrapperCheckOk" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__updateWrapperCheckOk(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__updateWrapperCheckOk*      nyapc1__updateWrapperCheckOk,
    // response parameters:
    _nyapc1__updateWrapperCheckOkResponse* nyapc1__updateWrapperCheckOkResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__updateWrapperCheckOk(
    struct soap *soap,
    // request parameters:
    _nyapc1__updateWrapperCheckOk*      nyapc1__updateWrapperCheckOk,
    // response parameters:
    _nyapc1__updateWrapperCheckOkResponse* nyapc1__updateWrapperCheckOkResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	updateWrapperCheckOk document
//gsoap nyapc1 service method-encoding:	updateWrapperCheckOk literal
//gsoap nyapc1 service method-action:	updateWrapperCheckOk ""
int __nyapc1__updateWrapperCheckOk(
    _nyapc1__updateWrapperCheckOk*      nyapc1__updateWrapperCheckOk,	///< Request parameter
    _nyapc1__updateWrapperCheckOkResponse* nyapc1__updateWrapperCheckOkResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getStat                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getStat" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getStat(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getStat*                   nyapc1__getStat,
    // response parameters:
    _nyapc1__getStatResponse*           nyapc1__getStatResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getStat(
    struct soap *soap,
    // request parameters:
    _nyapc1__getStat*                   nyapc1__getStat,
    // response parameters:
    _nyapc1__getStatResponse*           nyapc1__getStatResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getStat document
//gsoap nyapc1 service method-encoding:	getStat literal
//gsoap nyapc1 service method-action:	getStat ""
int __nyapc1__getStat(
    _nyapc1__getStat*                   nyapc1__getStat,	///< Request parameter
    _nyapc1__getStatResponse*           nyapc1__getStatResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__putResult                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__putResult" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__putResult(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__putResult*                 nyapc1__putResult,
    // response parameters:
    _nyapc1__putResultResponse*         nyapc1__putResultResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__putResult(
    struct soap *soap,
    // request parameters:
    _nyapc1__putResult*                 nyapc1__putResult,
    // response parameters:
    _nyapc1__putResultResponse*         nyapc1__putResultResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	putResult document
//gsoap nyapc1 service method-encoding:	putResult literal
//gsoap nyapc1 service method-action:	putResult ""
int __nyapc1__putResult(
    _nyapc1__putResult*                 nyapc1__putResult,	///< Request parameter
    _nyapc1__putResultResponse*         nyapc1__putResultResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getJobID                                                       *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getJobID" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getJobID(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getJobID*                  nyapc1__getJobID,
    // response parameters:
    _nyapc1__getJobIDResponse*          nyapc1__getJobIDResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getJobID(
    struct soap *soap,
    // request parameters:
    _nyapc1__getJobID*                  nyapc1__getJobID,
    // response parameters:
    _nyapc1__getJobIDResponse*          nyapc1__getJobIDResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getJobID document
//gsoap nyapc1 service method-encoding:	getJobID literal
//gsoap nyapc1 service method-action:	getJobID ""
int __nyapc1__getJobID(
    _nyapc1__getJobID*                  nyapc1__getJobID,	///< Request parameter
    _nyapc1__getJobIDResponse*          nyapc1__getJobIDResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getJobs                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getJobs" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getJobs(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getJobs*                   nyapc1__getJobs,
    // response parameters:
    _nyapc1__getJobsResponse*           nyapc1__getJobsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getJobs(
    struct soap *soap,
    // request parameters:
    _nyapc1__getJobs*                   nyapc1__getJobs,
    // response parameters:
    _nyapc1__getJobsResponse*           nyapc1__getJobsResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getJobs document
//gsoap nyapc1 service method-encoding:	getJobs literal
//gsoap nyapc1 service method-action:	getJobs ""
int __nyapc1__getJobs(
    _nyapc1__getJobs*                   nyapc1__getJobs,	///< Request parameter
    _nyapc1__getJobsResponse*           nyapc1__getJobsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getJobsWrapStatInvalid                                         *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getJobsWrapStatInvalid" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getJobsWrapStatInvalid(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getJobsWrapStatInvalid*    nyapc1__getJobsWrapStatInvalid,
    // response parameters:
    _nyapc1__getJobsWrapStatInvalidResponse* nyapc1__getJobsWrapStatInvalidResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getJobsWrapStatInvalid(
    struct soap *soap,
    // request parameters:
    _nyapc1__getJobsWrapStatInvalid*    nyapc1__getJobsWrapStatInvalid,
    // response parameters:
    _nyapc1__getJobsWrapStatInvalidResponse* nyapc1__getJobsWrapStatInvalidResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getJobsWrapStatInvalid document
//gsoap nyapc1 service method-encoding:	getJobsWrapStatInvalid literal
//gsoap nyapc1 service method-action:	getJobsWrapStatInvalid ""
int __nyapc1__getJobsWrapStatInvalid(
    _nyapc1__getJobsWrapStatInvalid*    nyapc1__getJobsWrapStatInvalid,	///< Request parameter
    _nyapc1__getJobsWrapStatInvalidResponse* nyapc1__getJobsWrapStatInvalidResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapGen                                                     *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapGen" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapGen(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapGen*                nyapc1__getWrapGen,
    // response parameters:
    _nyapc1__getWrapGenResponse*        nyapc1__getWrapGenResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapGen(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapGen*                nyapc1__getWrapGen,
    // response parameters:
    _nyapc1__getWrapGenResponse*        nyapc1__getWrapGenResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapGen document
//gsoap nyapc1 service method-encoding:	getWrapGen literal
//gsoap nyapc1 service method-action:	getWrapGen ""
int __nyapc1__getWrapGen(
    _nyapc1__getWrapGen*                nyapc1__getWrapGen,	///< Request parameter
    _nyapc1__getWrapGenResponse*        nyapc1__getWrapGenResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__updateWrapGen                                                  *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__updateWrapGen" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__updateWrapGen(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__updateWrapGen*             nyapc1__updateWrapGen,
    // response parameters:
    _nyapc1__updateWrapGenResponse*     nyapc1__updateWrapGenResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__updateWrapGen(
    struct soap *soap,
    // request parameters:
    _nyapc1__updateWrapGen*             nyapc1__updateWrapGen,
    // response parameters:
    _nyapc1__updateWrapGenResponse*     nyapc1__updateWrapGenResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	updateWrapGen document
//gsoap nyapc1 service method-encoding:	updateWrapGen literal
//gsoap nyapc1 service method-action:	updateWrapGen ""
int __nyapc1__updateWrapGen(
    _nyapc1__updateWrapGen*             nyapc1__updateWrapGen,	///< Request parameter
    _nyapc1__updateWrapGenResponse*     nyapc1__updateWrapGenResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getTaskQueue                                                   *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getTaskQueue" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getTaskQueue(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getTaskQueue*              nyapc1__getTaskQueue,
    // response parameters:
    _nyapc1__getTaskQueueResponse*      nyapc1__getTaskQueueResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getTaskQueue(
    struct soap *soap,
    // request parameters:
    _nyapc1__getTaskQueue*              nyapc1__getTaskQueue,
    // response parameters:
    _nyapc1__getTaskQueueResponse*      nyapc1__getTaskQueueResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getTaskQueue document
//gsoap nyapc1 service method-encoding:	getTaskQueue literal
//gsoap nyapc1 service method-action:	getTaskQueue ""
int __nyapc1__getTaskQueue(
    _nyapc1__getTaskQueue*              nyapc1__getTaskQueue,	///< Request parameter
    _nyapc1__getTaskQueueResponse*      nyapc1__getTaskQueueResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapTaskQueue                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapTaskQueue" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapTaskQueue(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapTaskQueue*          nyapc1__getWrapTaskQueue,
    // response parameters:
    _nyapc1__getWrapTaskQueueResponse*  nyapc1__getWrapTaskQueueResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapTaskQueue(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapTaskQueue*          nyapc1__getWrapTaskQueue,
    // response parameters:
    _nyapc1__getWrapTaskQueueResponse*  nyapc1__getWrapTaskQueueResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapTaskQueue document
//gsoap nyapc1 service method-encoding:	getWrapTaskQueue literal
//gsoap nyapc1 service method-action:	getWrapTaskQueue ""
int __nyapc1__getWrapTaskQueue(
    _nyapc1__getWrapTaskQueue*          nyapc1__getWrapTaskQueue,	///< Request parameter
    _nyapc1__getWrapTaskQueueResponse*  nyapc1__getWrapTaskQueueResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__takeTask                                                       *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__takeTask" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__takeTask(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__takeTask*                  nyapc1__takeTask,
    // response parameters:
    _nyapc1__takeTaskResponse*          nyapc1__takeTaskResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__takeTask(
    struct soap *soap,
    // request parameters:
    _nyapc1__takeTask*                  nyapc1__takeTask,
    // response parameters:
    _nyapc1__takeTaskResponse*          nyapc1__takeTaskResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	takeTask document
//gsoap nyapc1 service method-encoding:	takeTask literal
//gsoap nyapc1 service method-action:	takeTask ""
int __nyapc1__takeTask(
    _nyapc1__takeTask*                  nyapc1__takeTask,	///< Request parameter
    _nyapc1__takeTaskResponse*          nyapc1__takeTaskResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getTaskByJobId                                                 *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getTaskByJobId" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getTaskByJobId(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getTaskByJobId*            nyapc1__getTaskByJobId,
    // response parameters:
    _nyapc1__getTaskByJobIdResponse*    nyapc1__getTaskByJobIdResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getTaskByJobId(
    struct soap *soap,
    // request parameters:
    _nyapc1__getTaskByJobId*            nyapc1__getTaskByJobId,
    // response parameters:
    _nyapc1__getTaskByJobIdResponse*    nyapc1__getTaskByJobIdResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getTaskByJobId document
//gsoap nyapc1 service method-encoding:	getTaskByJobId literal
//gsoap nyapc1 service method-action:	getTaskByJobId ""
int __nyapc1__getTaskByJobId(
    _nyapc1__getTaskByJobId*            nyapc1__getTaskByJobId,	///< Request parameter
    _nyapc1__getTaskByJobIdResponse*    nyapc1__getTaskByJobIdResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__delJob                                                         *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__delJob" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__delJob(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__delJob*                    nyapc1__delJob,
    // response parameters:
    _nyapc1__delJobResponse*            nyapc1__delJobResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__delJob(
    struct soap *soap,
    // request parameters:
    _nyapc1__delJob*                    nyapc1__delJob,
    // response parameters:
    _nyapc1__delJobResponse*            nyapc1__delJobResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	delJob document
//gsoap nyapc1 service method-encoding:	delJob literal
//gsoap nyapc1 service method-action:	delJob ""
int __nyapc1__delJob(
    _nyapc1__delJob*                    nyapc1__delJob,	///< Request parameter
    _nyapc1__delJobResponse*            nyapc1__delJobResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__updateJobUrl                                                   *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__updateJobUrl" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__updateJobUrl(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__updateJobUrl*              nyapc1__updateJobUrl,
    // response parameters:
    _nyapc1__updateJobUrlResponse*      nyapc1__updateJobUrlResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__updateJobUrl(
    struct soap *soap,
    // request parameters:
    _nyapc1__updateJobUrl*              nyapc1__updateJobUrl,
    // response parameters:
    _nyapc1__updateJobUrlResponse*      nyapc1__updateJobUrlResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	updateJobUrl document
//gsoap nyapc1 service method-encoding:	updateJobUrl literal
//gsoap nyapc1 service method-action:	updateJobUrl ""
int __nyapc1__updateJobUrl(
    _nyapc1__updateJobUrl*              nyapc1__updateJobUrl,	///< Request parameter
    _nyapc1__updateJobUrlResponse*      nyapc1__updateJobUrlResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapInvalidTaskByJobId                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapInvalidTaskByJobId" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapInvalidTaskByJobId(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapInvalidTaskByJobId* nyapc1__getWrapInvalidTaskByJobId,
    // response parameters:
    _nyapc1__getWrapInvalidTaskByJobIdResponse* nyapc1__getWrapInvalidTaskByJobIdResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapInvalidTaskByJobId(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapInvalidTaskByJobId* nyapc1__getWrapInvalidTaskByJobId,
    // response parameters:
    _nyapc1__getWrapInvalidTaskByJobIdResponse* nyapc1__getWrapInvalidTaskByJobIdResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapInvalidTaskByJobId document
//gsoap nyapc1 service method-encoding:	getWrapInvalidTaskByJobId literal
//gsoap nyapc1 service method-action:	getWrapInvalidTaskByJobId ""
int __nyapc1__getWrapInvalidTaskByJobId(
    _nyapc1__getWrapInvalidTaskByJobId* nyapc1__getWrapInvalidTaskByJobId,	///< Request parameter
    _nyapc1__getWrapInvalidTaskByJobIdResponse* nyapc1__getWrapInvalidTaskByJobIdResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWrapId                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWrapId" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWrapId(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWrapId*                 nyapc1__getWrapId,
    // response parameters:
    _nyapc1__getWrapIdResponse*         nyapc1__getWrapIdResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWrapId(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWrapId*                 nyapc1__getWrapId,
    // response parameters:
    _nyapc1__getWrapIdResponse*         nyapc1__getWrapIdResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWrapId document
//gsoap nyapc1 service method-encoding:	getWrapId literal
//gsoap nyapc1 service method-action:	getWrapId ""
int __nyapc1__getWrapId(
    _nyapc1__getWrapId*                 nyapc1__getWrapId,	///< Request parameter
    _nyapc1__getWrapIdResponse*         nyapc1__getWrapIdResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __nyapc1__getWraptype                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__nyapc1__getWraptype" of service binding "CrawlerCtrlSoapBinding"

/**

Operation details:

  - SOAP document/literal style

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___nyapc1__getWraptype(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _nyapc1__getWraptype*               nyapc1__getWraptype,
    // response parameters:
    _nyapc1__getWraptypeResponse*       nyapc1__getWraptypeResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __nyapc1__getWraptype(
    struct soap *soap,
    // request parameters:
    _nyapc1__getWraptype*               nyapc1__getWraptype,
    // response parameters:
    _nyapc1__getWraptypeResponse*       nyapc1__getWraptypeResponse
  );
@endcode

C++ proxy class (defined in soapCrawlerCtrlSoapBindingProxy.h):
@code
  class CrawlerCtrlSoapBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapCrawlerCtrlSoapBindingService.h):
@code
  class CrawlerCtrlSoapBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap nyapc1 service method-style:	getWraptype document
//gsoap nyapc1 service method-encoding:	getWraptype literal
//gsoap nyapc1 service method-action:	getWraptype ""
int __nyapc1__getWraptype(
    _nyapc1__getWraptype*               nyapc1__getWraptype,	///< Request parameter
    _nyapc1__getWraptypeResponse*       nyapc1__getWraptypeResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings are adopted from XML schemas as part of the WSDL types section or when running wsdl2h on a set of schemas.

The following readers and writers are C/C++ data type (de)serializers auto-generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the (de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in your code to import these data type and function declarations. Only use the soapcpp2-generated files in your project build. Do not include the wsdl2h-generated .h file in your code.

XML content can be retrieved from:
  - a FILE* fd, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

XML content can be stored to:
  - a FILE* fd, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback


@section nyapc1 Top-level root elements of schema "http://crawler.nyapc"

  - <nyapc1:add> @ref _nyapc1__add
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__add(struct soap*, _nyapc1__add*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__add(struct soap*, _nyapc1__add*);
    @endcode

  - <nyapc1:addResponse> @ref _nyapc1__addResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__addResponse(struct soap*, _nyapc1__addResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__addResponse(struct soap*, _nyapc1__addResponse*);
    @endcode

  - <nyapc1:getVersion> @ref _nyapc1__getVersion
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getVersion(struct soap*, _nyapc1__getVersion*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getVersion(struct soap*, _nyapc1__getVersion*);
    @endcode

  - <nyapc1:getVersionResponse> @ref _nyapc1__getVersionResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getVersionResponse(struct soap*, _nyapc1__getVersionResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getVersionResponse(struct soap*, _nyapc1__getVersionResponse*);
    @endcode

  - <nyapc1:getJob> @ref _nyapc1__getJob
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJob(struct soap*, _nyapc1__getJob*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJob(struct soap*, _nyapc1__getJob*);
    @endcode

  - <nyapc1:getJobResponse> @ref _nyapc1__getJobResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobResponse(struct soap*, _nyapc1__getJobResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobResponse(struct soap*, _nyapc1__getJobResponse*);
    @endcode

  - <nyapc1:addJob> @ref _nyapc1__addJob
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__addJob(struct soap*, _nyapc1__addJob*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__addJob(struct soap*, _nyapc1__addJob*);
    @endcode

  - <nyapc1:addJobResponse> @ref _nyapc1__addJobResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__addJobResponse(struct soap*, _nyapc1__addJobResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__addJobResponse(struct soap*, _nyapc1__addJobResponse*);
    @endcode

  - <nyapc1:hasTask> @ref _nyapc1__hasTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__hasTask(struct soap*, _nyapc1__hasTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__hasTask(struct soap*, _nyapc1__hasTask*);
    @endcode

  - <nyapc1:hasTaskResponse> @ref _nyapc1__hasTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__hasTaskResponse(struct soap*, _nyapc1__hasTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__hasTaskResponse(struct soap*, _nyapc1__hasTaskResponse*);
    @endcode

  - <nyapc1:updateJob> @ref _nyapc1__updateJob
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateJob(struct soap*, _nyapc1__updateJob*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateJob(struct soap*, _nyapc1__updateJob*);
    @endcode

  - <nyapc1:updateJobResponse> @ref _nyapc1__updateJobResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateJobResponse(struct soap*, _nyapc1__updateJobResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateJobResponse(struct soap*, _nyapc1__updateJobResponse*);
    @endcode

  - <nyapc1:getWrapper> @ref _nyapc1__getWrapper
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapper(struct soap*, _nyapc1__getWrapper*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapper(struct soap*, _nyapc1__getWrapper*);
    @endcode

  - <nyapc1:getWrapperResponse> @ref _nyapc1__getWrapperResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapperResponse(struct soap*, _nyapc1__getWrapperResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapperResponse(struct soap*, _nyapc1__getWrapperResponse*);
    @endcode

  - <nyapc1:addWrapper> @ref _nyapc1__addWrapper
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__addWrapper(struct soap*, _nyapc1__addWrapper*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__addWrapper(struct soap*, _nyapc1__addWrapper*);
    @endcode

  - <nyapc1:addWrapperResponse> @ref _nyapc1__addWrapperResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__addWrapperResponse(struct soap*, _nyapc1__addWrapperResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__addWrapperResponse(struct soap*, _nyapc1__addWrapperResponse*);
    @endcode

  - <nyapc1:getTask> @ref _nyapc1__getTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTask(struct soap*, _nyapc1__getTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTask(struct soap*, _nyapc1__getTask*);
    @endcode

  - <nyapc1:getTaskResponse> @ref _nyapc1__getTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTaskResponse(struct soap*, _nyapc1__getTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTaskResponse(struct soap*, _nyapc1__getTaskResponse*);
    @endcode

  - <nyapc1:getWrapTask> @ref _nyapc1__getWrapTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapTask(struct soap*, _nyapc1__getWrapTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapTask(struct soap*, _nyapc1__getWrapTask*);
    @endcode

  - <nyapc1:getWrapTaskResponse> @ref _nyapc1__getWrapTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapTaskResponse(struct soap*, _nyapc1__getWrapTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapTaskResponse(struct soap*, _nyapc1__getWrapTaskResponse*);
    @endcode

  - <nyapc1:takeWrapTask> @ref _nyapc1__takeWrapTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__takeWrapTask(struct soap*, _nyapc1__takeWrapTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__takeWrapTask(struct soap*, _nyapc1__takeWrapTask*);
    @endcode

  - <nyapc1:takeWrapTaskResponse> @ref _nyapc1__takeWrapTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__takeWrapTaskResponse(struct soap*, _nyapc1__takeWrapTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__takeWrapTaskResponse(struct soap*, _nyapc1__takeWrapTaskResponse*);
    @endcode

  - <nyapc1:getWrapInvalidTask> @ref _nyapc1__getWrapInvalidTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapInvalidTask(struct soap*, _nyapc1__getWrapInvalidTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapInvalidTask(struct soap*, _nyapc1__getWrapInvalidTask*);
    @endcode

  - <nyapc1:getWrapInvalidTaskResponse> @ref _nyapc1__getWrapInvalidTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapInvalidTaskResponse(struct soap*, _nyapc1__getWrapInvalidTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapInvalidTaskResponse(struct soap*, _nyapc1__getWrapInvalidTaskResponse*);
    @endcode

  - <nyapc1:updateWrapper> @ref _nyapc1__updateWrapper
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapper(struct soap*, _nyapc1__updateWrapper*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapper(struct soap*, _nyapc1__updateWrapper*);
    @endcode

  - <nyapc1:updateWrapperResponse> @ref _nyapc1__updateWrapperResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapperResponse(struct soap*, _nyapc1__updateWrapperResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapperResponse(struct soap*, _nyapc1__updateWrapperResponse*);
    @endcode

  - <nyapc1:updateWrapperCheckOk> @ref _nyapc1__updateWrapperCheckOk
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapperCheckOk(struct soap*, _nyapc1__updateWrapperCheckOk*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapperCheckOk(struct soap*, _nyapc1__updateWrapperCheckOk*);
    @endcode

  - <nyapc1:updateWrapperCheckOkResponse> @ref _nyapc1__updateWrapperCheckOkResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapperCheckOkResponse(struct soap*, _nyapc1__updateWrapperCheckOkResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapperCheckOkResponse(struct soap*, _nyapc1__updateWrapperCheckOkResponse*);
    @endcode

  - <nyapc1:getStat> @ref _nyapc1__getStat
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getStat(struct soap*, _nyapc1__getStat*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getStat(struct soap*, _nyapc1__getStat*);
    @endcode

  - <nyapc1:getStatResponse> @ref _nyapc1__getStatResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getStatResponse(struct soap*, _nyapc1__getStatResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getStatResponse(struct soap*, _nyapc1__getStatResponse*);
    @endcode

  - <nyapc1:putResult> @ref _nyapc1__putResult
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__putResult(struct soap*, _nyapc1__putResult*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__putResult(struct soap*, _nyapc1__putResult*);
    @endcode

  - <nyapc1:putResultResponse> @ref _nyapc1__putResultResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__putResultResponse(struct soap*, _nyapc1__putResultResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__putResultResponse(struct soap*, _nyapc1__putResultResponse*);
    @endcode

  - <nyapc1:getJobID> @ref _nyapc1__getJobID
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobID(struct soap*, _nyapc1__getJobID*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobID(struct soap*, _nyapc1__getJobID*);
    @endcode

  - <nyapc1:getJobIDResponse> @ref _nyapc1__getJobIDResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobIDResponse(struct soap*, _nyapc1__getJobIDResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobIDResponse(struct soap*, _nyapc1__getJobIDResponse*);
    @endcode

  - <nyapc1:getJobs> @ref _nyapc1__getJobs
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobs(struct soap*, _nyapc1__getJobs*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobs(struct soap*, _nyapc1__getJobs*);
    @endcode

  - <nyapc1:getJobsResponse> @ref _nyapc1__getJobsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobsResponse(struct soap*, _nyapc1__getJobsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobsResponse(struct soap*, _nyapc1__getJobsResponse*);
    @endcode

  - <nyapc1:getJobsWrapStatInvalid> @ref _nyapc1__getJobsWrapStatInvalid
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobsWrapStatInvalid(struct soap*, _nyapc1__getJobsWrapStatInvalid*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobsWrapStatInvalid(struct soap*, _nyapc1__getJobsWrapStatInvalid*);
    @endcode

  - <nyapc1:getJobsWrapStatInvalidResponse> @ref _nyapc1__getJobsWrapStatInvalidResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getJobsWrapStatInvalidResponse(struct soap*, _nyapc1__getJobsWrapStatInvalidResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getJobsWrapStatInvalidResponse(struct soap*, _nyapc1__getJobsWrapStatInvalidResponse*);
    @endcode

  - <nyapc1:getWrapGen> @ref _nyapc1__getWrapGen
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapGen(struct soap*, _nyapc1__getWrapGen*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapGen(struct soap*, _nyapc1__getWrapGen*);
    @endcode

  - <nyapc1:getWrapGenResponse> @ref _nyapc1__getWrapGenResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapGenResponse(struct soap*, _nyapc1__getWrapGenResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapGenResponse(struct soap*, _nyapc1__getWrapGenResponse*);
    @endcode

  - <nyapc1:updateWrapGen> @ref _nyapc1__updateWrapGen
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapGen(struct soap*, _nyapc1__updateWrapGen*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapGen(struct soap*, _nyapc1__updateWrapGen*);
    @endcode

  - <nyapc1:updateWrapGenResponse> @ref _nyapc1__updateWrapGenResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateWrapGenResponse(struct soap*, _nyapc1__updateWrapGenResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateWrapGenResponse(struct soap*, _nyapc1__updateWrapGenResponse*);
    @endcode

  - <nyapc1:getTaskQueue> @ref _nyapc1__getTaskQueue
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTaskQueue(struct soap*, _nyapc1__getTaskQueue*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTaskQueue(struct soap*, _nyapc1__getTaskQueue*);
    @endcode

  - <nyapc1:getTaskQueueResponse> @ref _nyapc1__getTaskQueueResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTaskQueueResponse(struct soap*, _nyapc1__getTaskQueueResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTaskQueueResponse(struct soap*, _nyapc1__getTaskQueueResponse*);
    @endcode

  - <nyapc1:getWrapTaskQueue> @ref _nyapc1__getWrapTaskQueue
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapTaskQueue(struct soap*, _nyapc1__getWrapTaskQueue*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapTaskQueue(struct soap*, _nyapc1__getWrapTaskQueue*);
    @endcode

  - <nyapc1:getWrapTaskQueueResponse> @ref _nyapc1__getWrapTaskQueueResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapTaskQueueResponse(struct soap*, _nyapc1__getWrapTaskQueueResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapTaskQueueResponse(struct soap*, _nyapc1__getWrapTaskQueueResponse*);
    @endcode

  - <nyapc1:takeTask> @ref _nyapc1__takeTask
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__takeTask(struct soap*, _nyapc1__takeTask*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__takeTask(struct soap*, _nyapc1__takeTask*);
    @endcode

  - <nyapc1:takeTaskResponse> @ref _nyapc1__takeTaskResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__takeTaskResponse(struct soap*, _nyapc1__takeTaskResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__takeTaskResponse(struct soap*, _nyapc1__takeTaskResponse*);
    @endcode

  - <nyapc1:getTaskByJobId> @ref _nyapc1__getTaskByJobId
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTaskByJobId(struct soap*, _nyapc1__getTaskByJobId*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTaskByJobId(struct soap*, _nyapc1__getTaskByJobId*);
    @endcode

  - <nyapc1:getTaskByJobIdResponse> @ref _nyapc1__getTaskByJobIdResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getTaskByJobIdResponse(struct soap*, _nyapc1__getTaskByJobIdResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getTaskByJobIdResponse(struct soap*, _nyapc1__getTaskByJobIdResponse*);
    @endcode

  - <nyapc1:delJob> @ref _nyapc1__delJob
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__delJob(struct soap*, _nyapc1__delJob*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__delJob(struct soap*, _nyapc1__delJob*);
    @endcode

  - <nyapc1:delJobResponse> @ref _nyapc1__delJobResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__delJobResponse(struct soap*, _nyapc1__delJobResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__delJobResponse(struct soap*, _nyapc1__delJobResponse*);
    @endcode

  - <nyapc1:updateJobUrl> @ref _nyapc1__updateJobUrl
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateJobUrl(struct soap*, _nyapc1__updateJobUrl*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateJobUrl(struct soap*, _nyapc1__updateJobUrl*);
    @endcode

  - <nyapc1:updateJobUrlResponse> @ref _nyapc1__updateJobUrlResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__updateJobUrlResponse(struct soap*, _nyapc1__updateJobUrlResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__updateJobUrlResponse(struct soap*, _nyapc1__updateJobUrlResponse*);
    @endcode

  - <nyapc1:getWrapInvalidTaskByJobId> @ref _nyapc1__getWrapInvalidTaskByJobId
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapInvalidTaskByJobId(struct soap*, _nyapc1__getWrapInvalidTaskByJobId*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapInvalidTaskByJobId(struct soap*, _nyapc1__getWrapInvalidTaskByJobId*);
    @endcode

  - <nyapc1:getWrapInvalidTaskByJobIdResponse> @ref _nyapc1__getWrapInvalidTaskByJobIdResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap*, _nyapc1__getWrapInvalidTaskByJobIdResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap*, _nyapc1__getWrapInvalidTaskByJobIdResponse*);
    @endcode

  - <nyapc1:getWrapId> @ref _nyapc1__getWrapId
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapId(struct soap*, _nyapc1__getWrapId*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapId(struct soap*, _nyapc1__getWrapId*);
    @endcode

  - <nyapc1:getWrapIdResponse> @ref _nyapc1__getWrapIdResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWrapIdResponse(struct soap*, _nyapc1__getWrapIdResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWrapIdResponse(struct soap*, _nyapc1__getWrapIdResponse*);
    @endcode

  - <nyapc1:getWraptype> @ref _nyapc1__getWraptype
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWraptype(struct soap*, _nyapc1__getWraptype*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWraptype(struct soap*, _nyapc1__getWraptype*);
    @endcode

  - <nyapc1:getWraptypeResponse> @ref _nyapc1__getWraptypeResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__nyapc1__getWraptypeResponse(struct soap*, _nyapc1__getWraptypeResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__nyapc1__getWraptypeResponse(struct soap*, _nyapc1__getWraptypeResponse*);
    @endcode

@section nyapc2 Top-level root elements of schema "http://dao.crawler.nyapc"

*/

/* End of CrawlerCtrl.h */
