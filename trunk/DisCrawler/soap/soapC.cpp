/* soapC.cpp
   Generated by gSOAP 2.7.15 from CrawlerCtrl.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.15 2010-02-02 08:50:57 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_nyapc2__AttSuperClass:
		return soap_in_nyapc2__AttSuperClass(soap, NULL, NULL, "nyapc2:AttSuperClass");
	case SOAP_TYPE_nyapc1__Task:
		return soap_in_nyapc1__Task(soap, NULL, NULL, "nyapc1:Task");
	case SOAP_TYPE_nyapc1__JobAtt:
		return soap_in_nyapc1__JobAtt(soap, NULL, NULL, "nyapc1:JobAtt");
	case SOAP_TYPE_PointerTo_nyapc1__getWraptypeResponse:
		return soap_in_PointerTo_nyapc1__getWraptypeResponse(soap, NULL, NULL, "nyapc1:getWraptypeResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWraptype:
		return soap_in_PointerTo_nyapc1__getWraptype(soap, NULL, NULL, "nyapc1:getWraptype");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapIdResponse:
		return soap_in_PointerTo_nyapc1__getWrapIdResponse(soap, NULL, NULL, "nyapc1:getWrapIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapId:
		return soap_in_PointerTo_nyapc1__getWrapId(soap, NULL, NULL, "nyapc1:getWrapId");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse:
		return soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(soap, NULL, NULL, "nyapc1:getWrapInvalidTaskByJobIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobId:
		return soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, NULL, NULL, "nyapc1:getWrapInvalidTaskByJobId");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrlResponse:
		return soap_in_PointerTo_nyapc1__updateJobUrlResponse(soap, NULL, NULL, "nyapc1:updateJobUrlResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrl:
		return soap_in_PointerTo_nyapc1__updateJobUrl(soap, NULL, NULL, "nyapc1:updateJobUrl");
	case SOAP_TYPE_PointerTo_nyapc1__delJobResponse:
		return soap_in_PointerTo_nyapc1__delJobResponse(soap, NULL, NULL, "nyapc1:delJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__delJob:
		return soap_in_PointerTo_nyapc1__delJob(soap, NULL, NULL, "nyapc1:delJob");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobIdResponse:
		return soap_in_PointerTo_nyapc1__getTaskByJobIdResponse(soap, NULL, NULL, "nyapc1:getTaskByJobIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobId:
		return soap_in_PointerTo_nyapc1__getTaskByJobId(soap, NULL, NULL, "nyapc1:getTaskByJobId");
	case SOAP_TYPE_PointerTo_nyapc1__takeTaskResponse:
		return soap_in_PointerTo_nyapc1__takeTaskResponse(soap, NULL, NULL, "nyapc1:takeTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__takeTask:
		return soap_in_PointerTo_nyapc1__takeTask(soap, NULL, NULL, "nyapc1:takeTask");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueueResponse:
		return soap_in_PointerTo_nyapc1__getWrapTaskQueueResponse(soap, NULL, NULL, "nyapc1:getWrapTaskQueueResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueue:
		return soap_in_PointerTo_nyapc1__getWrapTaskQueue(soap, NULL, NULL, "nyapc1:getWrapTaskQueue");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueueResponse:
		return soap_in_PointerTo_nyapc1__getTaskQueueResponse(soap, NULL, NULL, "nyapc1:getTaskQueueResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueue:
		return soap_in_PointerTo_nyapc1__getTaskQueue(soap, NULL, NULL, "nyapc1:getTaskQueue");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGenResponse:
		return soap_in_PointerTo_nyapc1__updateWrapGenResponse(soap, NULL, NULL, "nyapc1:updateWrapGenResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGen:
		return soap_in_PointerTo_nyapc1__updateWrapGen(soap, NULL, NULL, "nyapc1:updateWrapGen");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGenResponse:
		return soap_in_PointerTo_nyapc1__getWrapGenResponse(soap, NULL, NULL, "nyapc1:getWrapGenResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGen:
		return soap_in_PointerTo_nyapc1__getWrapGen(soap, NULL, NULL, "nyapc1:getWrapGen");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalidResponse:
		return soap_in_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(soap, NULL, NULL, "nyapc1:getJobsWrapStatInvalidResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalid:
		return soap_in_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, NULL, NULL, "nyapc1:getJobsWrapStatInvalid");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsResponse:
		return soap_in_PointerTo_nyapc1__getJobsResponse(soap, NULL, NULL, "nyapc1:getJobsResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobs:
		return soap_in_PointerTo_nyapc1__getJobs(soap, NULL, NULL, "nyapc1:getJobs");
	case SOAP_TYPE_PointerTo_nyapc1__getJobIDResponse:
		return soap_in_PointerTo_nyapc1__getJobIDResponse(soap, NULL, NULL, "nyapc1:getJobIDResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobID:
		return soap_in_PointerTo_nyapc1__getJobID(soap, NULL, NULL, "nyapc1:getJobID");
	case SOAP_TYPE_PointerTo_nyapc1__putResultResponse:
		return soap_in_PointerTo_nyapc1__putResultResponse(soap, NULL, NULL, "nyapc1:putResultResponse");
	case SOAP_TYPE_PointerTo_nyapc1__putResult:
		return soap_in_PointerTo_nyapc1__putResult(soap, NULL, NULL, "nyapc1:putResult");
	case SOAP_TYPE_PointerTo_nyapc1__getStatResponse:
		return soap_in_PointerTo_nyapc1__getStatResponse(soap, NULL, NULL, "nyapc1:getStatResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getStat:
		return soap_in_PointerTo_nyapc1__getStat(soap, NULL, NULL, "nyapc1:getStat");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOkResponse:
		return soap_in_PointerTo_nyapc1__updateWrapperCheckOkResponse(soap, NULL, NULL, "nyapc1:updateWrapperCheckOkResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOk:
		return soap_in_PointerTo_nyapc1__updateWrapperCheckOk(soap, NULL, NULL, "nyapc1:updateWrapperCheckOk");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperResponse:
		return soap_in_PointerTo_nyapc1__updateWrapperResponse(soap, NULL, NULL, "nyapc1:updateWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapper:
		return soap_in_PointerTo_nyapc1__updateWrapper(soap, NULL, NULL, "nyapc1:updateWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskResponse:
		return soap_in_PointerTo_nyapc1__getWrapInvalidTaskResponse(soap, NULL, NULL, "nyapc1:getWrapInvalidTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTask:
		return soap_in_PointerTo_nyapc1__getWrapInvalidTask(soap, NULL, NULL, "nyapc1:getWrapInvalidTask");
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTaskResponse:
		return soap_in_PointerTo_nyapc1__takeWrapTaskResponse(soap, NULL, NULL, "nyapc1:takeWrapTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTask:
		return soap_in_PointerTo_nyapc1__takeWrapTask(soap, NULL, NULL, "nyapc1:takeWrapTask");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskResponse:
		return soap_in_PointerTo_nyapc1__getWrapTaskResponse(soap, NULL, NULL, "nyapc1:getWrapTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTask:
		return soap_in_PointerTo_nyapc1__getWrapTask(soap, NULL, NULL, "nyapc1:getWrapTask");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskResponse:
		return soap_in_PointerTo_nyapc1__getTaskResponse(soap, NULL, NULL, "nyapc1:getTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTask:
		return soap_in_PointerTo_nyapc1__getTask(soap, NULL, NULL, "nyapc1:getTask");
	case SOAP_TYPE_PointerTo_nyapc1__addWrapperResponse:
		return soap_in_PointerTo_nyapc1__addWrapperResponse(soap, NULL, NULL, "nyapc1:addWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__addWrapper:
		return soap_in_PointerTo_nyapc1__addWrapper(soap, NULL, NULL, "nyapc1:addWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapperResponse:
		return soap_in_PointerTo_nyapc1__getWrapperResponse(soap, NULL, NULL, "nyapc1:getWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapper:
		return soap_in_PointerTo_nyapc1__getWrapper(soap, NULL, NULL, "nyapc1:getWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobResponse:
		return soap_in_PointerTo_nyapc1__updateJobResponse(soap, NULL, NULL, "nyapc1:updateJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateJob:
		return soap_in_PointerTo_nyapc1__updateJob(soap, NULL, NULL, "nyapc1:updateJob");
	case SOAP_TYPE_PointerTo_nyapc1__hasTaskResponse:
		return soap_in_PointerTo_nyapc1__hasTaskResponse(soap, NULL, NULL, "nyapc1:hasTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__hasTask:
		return soap_in_PointerTo_nyapc1__hasTask(soap, NULL, NULL, "nyapc1:hasTask");
	case SOAP_TYPE_PointerTo_nyapc1__addJobResponse:
		return soap_in_PointerTo_nyapc1__addJobResponse(soap, NULL, NULL, "nyapc1:addJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__addJob:
		return soap_in_PointerTo_nyapc1__addJob(soap, NULL, NULL, "nyapc1:addJob");
	case SOAP_TYPE_PointerTo_nyapc1__getJobResponse:
		return soap_in_PointerTo_nyapc1__getJobResponse(soap, NULL, NULL, "nyapc1:getJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJob:
		return soap_in_PointerTo_nyapc1__getJob(soap, NULL, NULL, "nyapc1:getJob");
	case SOAP_TYPE_PointerTo_nyapc1__getVersionResponse:
		return soap_in_PointerTo_nyapc1__getVersionResponse(soap, NULL, NULL, "nyapc1:getVersionResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getVersion:
		return soap_in_PointerTo_nyapc1__getVersion(soap, NULL, NULL, "nyapc1:getVersion");
	case SOAP_TYPE_PointerTo_nyapc1__addResponse:
		return soap_in_PointerTo_nyapc1__addResponse(soap, NULL, NULL, "nyapc1:addResponse");
	case SOAP_TYPE_PointerTo_nyapc1__add:
		return soap_in_PointerTo_nyapc1__add(soap, NULL, NULL, "nyapc1:add");
	case SOAP_TYPE_PointerTonyapc1__Task:
		return soap_in_PointerTonyapc1__Task(soap, NULL, NULL, "nyapc1:Task");
	case SOAP_TYPE_PointerTonyapc1__JobAtt:
		return soap_in_PointerTonyapc1__JobAtt(soap, NULL, NULL, "nyapc1:JobAtt");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc2:AttSuperClass"))
		{	*type = SOAP_TYPE_nyapc2__AttSuperClass;
			return soap_in_nyapc2__AttSuperClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:Task"))
		{	*type = SOAP_TYPE_nyapc1__Task;
			return soap_in_nyapc1__Task(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:JobAtt"))
		{	*type = SOAP_TYPE_nyapc1__JobAtt;
			return soap_in_nyapc1__JobAtt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "nyapc1:getWraptypeResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWraptypeResponse;
			return soap_in__nyapc1__getWraptypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWraptype"))
		{	*type = SOAP_TYPE__nyapc1__getWraptype;
			return soap_in__nyapc1__getWraptype(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapIdResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapIdResponse;
			return soap_in__nyapc1__getWrapIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapId"))
		{	*type = SOAP_TYPE__nyapc1__getWrapId;
			return soap_in__nyapc1__getWrapId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapInvalidTaskByJobIdResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse;
			return soap_in__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapInvalidTaskByJobId"))
		{	*type = SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId;
			return soap_in__nyapc1__getWrapInvalidTaskByJobId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateJobUrlResponse"))
		{	*type = SOAP_TYPE__nyapc1__updateJobUrlResponse;
			return soap_in__nyapc1__updateJobUrlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateJobUrl"))
		{	*type = SOAP_TYPE__nyapc1__updateJobUrl;
			return soap_in__nyapc1__updateJobUrl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:delJobResponse"))
		{	*type = SOAP_TYPE__nyapc1__delJobResponse;
			return soap_in__nyapc1__delJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:delJob"))
		{	*type = SOAP_TYPE__nyapc1__delJob;
			return soap_in__nyapc1__delJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTaskByJobIdResponse"))
		{	*type = SOAP_TYPE__nyapc1__getTaskByJobIdResponse;
			return soap_in__nyapc1__getTaskByJobIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTaskByJobId"))
		{	*type = SOAP_TYPE__nyapc1__getTaskByJobId;
			return soap_in__nyapc1__getTaskByJobId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:takeTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__takeTaskResponse;
			return soap_in__nyapc1__takeTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:takeTask"))
		{	*type = SOAP_TYPE__nyapc1__takeTask;
			return soap_in__nyapc1__takeTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapTaskQueueResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapTaskQueueResponse;
			return soap_in__nyapc1__getWrapTaskQueueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapTaskQueue"))
		{	*type = SOAP_TYPE__nyapc1__getWrapTaskQueue;
			return soap_in__nyapc1__getWrapTaskQueue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTaskQueueResponse"))
		{	*type = SOAP_TYPE__nyapc1__getTaskQueueResponse;
			return soap_in__nyapc1__getTaskQueueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTaskQueue"))
		{	*type = SOAP_TYPE__nyapc1__getTaskQueue;
			return soap_in__nyapc1__getTaskQueue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapGenResponse"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapGenResponse;
			return soap_in__nyapc1__updateWrapGenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapGen"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapGen;
			return soap_in__nyapc1__updateWrapGen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapGenResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapGenResponse;
			return soap_in__nyapc1__getWrapGenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapGen"))
		{	*type = SOAP_TYPE__nyapc1__getWrapGen;
			return soap_in__nyapc1__getWrapGen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobsWrapStatInvalidResponse"))
		{	*type = SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse;
			return soap_in__nyapc1__getJobsWrapStatInvalidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobsWrapStatInvalid"))
		{	*type = SOAP_TYPE__nyapc1__getJobsWrapStatInvalid;
			return soap_in__nyapc1__getJobsWrapStatInvalid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobsResponse"))
		{	*type = SOAP_TYPE__nyapc1__getJobsResponse;
			return soap_in__nyapc1__getJobsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobs"))
		{	*type = SOAP_TYPE__nyapc1__getJobs;
			return soap_in__nyapc1__getJobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobIDResponse"))
		{	*type = SOAP_TYPE__nyapc1__getJobIDResponse;
			return soap_in__nyapc1__getJobIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobID"))
		{	*type = SOAP_TYPE__nyapc1__getJobID;
			return soap_in__nyapc1__getJobID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:putResultResponse"))
		{	*type = SOAP_TYPE__nyapc1__putResultResponse;
			return soap_in__nyapc1__putResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:putResult"))
		{	*type = SOAP_TYPE__nyapc1__putResult;
			return soap_in__nyapc1__putResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getStatResponse"))
		{	*type = SOAP_TYPE__nyapc1__getStatResponse;
			return soap_in__nyapc1__getStatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getStat"))
		{	*type = SOAP_TYPE__nyapc1__getStat;
			return soap_in__nyapc1__getStat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapperCheckOkResponse"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse;
			return soap_in__nyapc1__updateWrapperCheckOkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapperCheckOk"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapperCheckOk;
			return soap_in__nyapc1__updateWrapperCheckOk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapperResponse"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapperResponse;
			return soap_in__nyapc1__updateWrapperResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateWrapper"))
		{	*type = SOAP_TYPE__nyapc1__updateWrapper;
			return soap_in__nyapc1__updateWrapper(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapInvalidTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse;
			return soap_in__nyapc1__getWrapInvalidTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapInvalidTask"))
		{	*type = SOAP_TYPE__nyapc1__getWrapInvalidTask;
			return soap_in__nyapc1__getWrapInvalidTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:takeWrapTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__takeWrapTaskResponse;
			return soap_in__nyapc1__takeWrapTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:takeWrapTask"))
		{	*type = SOAP_TYPE__nyapc1__takeWrapTask;
			return soap_in__nyapc1__takeWrapTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapTaskResponse;
			return soap_in__nyapc1__getWrapTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapTask"))
		{	*type = SOAP_TYPE__nyapc1__getWrapTask;
			return soap_in__nyapc1__getWrapTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__getTaskResponse;
			return soap_in__nyapc1__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getTask"))
		{	*type = SOAP_TYPE__nyapc1__getTask;
			return soap_in__nyapc1__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:addWrapperResponse"))
		{	*type = SOAP_TYPE__nyapc1__addWrapperResponse;
			return soap_in__nyapc1__addWrapperResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:addWrapper"))
		{	*type = SOAP_TYPE__nyapc1__addWrapper;
			return soap_in__nyapc1__addWrapper(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapperResponse"))
		{	*type = SOAP_TYPE__nyapc1__getWrapperResponse;
			return soap_in__nyapc1__getWrapperResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getWrapper"))
		{	*type = SOAP_TYPE__nyapc1__getWrapper;
			return soap_in__nyapc1__getWrapper(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateJobResponse"))
		{	*type = SOAP_TYPE__nyapc1__updateJobResponse;
			return soap_in__nyapc1__updateJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:updateJob"))
		{	*type = SOAP_TYPE__nyapc1__updateJob;
			return soap_in__nyapc1__updateJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:hasTaskResponse"))
		{	*type = SOAP_TYPE__nyapc1__hasTaskResponse;
			return soap_in__nyapc1__hasTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:hasTask"))
		{	*type = SOAP_TYPE__nyapc1__hasTask;
			return soap_in__nyapc1__hasTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:addJobResponse"))
		{	*type = SOAP_TYPE__nyapc1__addJobResponse;
			return soap_in__nyapc1__addJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:addJob"))
		{	*type = SOAP_TYPE__nyapc1__addJob;
			return soap_in__nyapc1__addJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJobResponse"))
		{	*type = SOAP_TYPE__nyapc1__getJobResponse;
			return soap_in__nyapc1__getJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getJob"))
		{	*type = SOAP_TYPE__nyapc1__getJob;
			return soap_in__nyapc1__getJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getVersionResponse"))
		{	*type = SOAP_TYPE__nyapc1__getVersionResponse;
			return soap_in__nyapc1__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:getVersion"))
		{	*type = SOAP_TYPE__nyapc1__getVersion;
			return soap_in__nyapc1__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:addResponse"))
		{	*type = SOAP_TYPE__nyapc1__addResponse;
			return soap_in__nyapc1__addResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "nyapc1:add"))
		{	*type = SOAP_TYPE__nyapc1__add;
			return soap_in__nyapc1__add(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_nyapc2__AttSuperClass:
		return ((nyapc2__AttSuperClass *)ptr)->soap_out(soap, tag, id, "nyapc2:AttSuperClass");
	case SOAP_TYPE__nyapc1__getWraptypeResponse:
		return ((_nyapc1__getWraptypeResponse *)ptr)->soap_out(soap, "nyapc1:getWraptypeResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWraptype:
		return ((_nyapc1__getWraptype *)ptr)->soap_out(soap, "nyapc1:getWraptype", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapIdResponse:
		return ((_nyapc1__getWrapIdResponse *)ptr)->soap_out(soap, "nyapc1:getWrapIdResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapId:
		return ((_nyapc1__getWrapId *)ptr)->soap_out(soap, "nyapc1:getWrapId", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse:
		return ((_nyapc1__getWrapInvalidTaskByJobIdResponse *)ptr)->soap_out(soap, "nyapc1:getWrapInvalidTaskByJobIdResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId:
		return ((_nyapc1__getWrapInvalidTaskByJobId *)ptr)->soap_out(soap, "nyapc1:getWrapInvalidTaskByJobId", id, NULL);
	case SOAP_TYPE__nyapc1__updateJobUrlResponse:
		return ((_nyapc1__updateJobUrlResponse *)ptr)->soap_out(soap, "nyapc1:updateJobUrlResponse", id, NULL);
	case SOAP_TYPE__nyapc1__updateJobUrl:
		return ((_nyapc1__updateJobUrl *)ptr)->soap_out(soap, "nyapc1:updateJobUrl", id, NULL);
	case SOAP_TYPE__nyapc1__delJobResponse:
		return ((_nyapc1__delJobResponse *)ptr)->soap_out(soap, "nyapc1:delJobResponse", id, NULL);
	case SOAP_TYPE__nyapc1__delJob:
		return ((_nyapc1__delJob *)ptr)->soap_out(soap, "nyapc1:delJob", id, NULL);
	case SOAP_TYPE__nyapc1__getTaskByJobIdResponse:
		return ((_nyapc1__getTaskByJobIdResponse *)ptr)->soap_out(soap, "nyapc1:getTaskByJobIdResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getTaskByJobId:
		return ((_nyapc1__getTaskByJobId *)ptr)->soap_out(soap, "nyapc1:getTaskByJobId", id, NULL);
	case SOAP_TYPE__nyapc1__takeTaskResponse:
		return ((_nyapc1__takeTaskResponse *)ptr)->soap_out(soap, "nyapc1:takeTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__takeTask:
		return ((_nyapc1__takeTask *)ptr)->soap_out(soap, "nyapc1:takeTask", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapTaskQueueResponse:
		return ((_nyapc1__getWrapTaskQueueResponse *)ptr)->soap_out(soap, "nyapc1:getWrapTaskQueueResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapTaskQueue:
		return ((_nyapc1__getWrapTaskQueue *)ptr)->soap_out(soap, "nyapc1:getWrapTaskQueue", id, NULL);
	case SOAP_TYPE__nyapc1__getTaskQueueResponse:
		return ((_nyapc1__getTaskQueueResponse *)ptr)->soap_out(soap, "nyapc1:getTaskQueueResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getTaskQueue:
		return ((_nyapc1__getTaskQueue *)ptr)->soap_out(soap, "nyapc1:getTaskQueue", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapGenResponse:
		return ((_nyapc1__updateWrapGenResponse *)ptr)->soap_out(soap, "nyapc1:updateWrapGenResponse", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapGen:
		return ((_nyapc1__updateWrapGen *)ptr)->soap_out(soap, "nyapc1:updateWrapGen", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapGenResponse:
		return ((_nyapc1__getWrapGenResponse *)ptr)->soap_out(soap, "nyapc1:getWrapGenResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapGen:
		return ((_nyapc1__getWrapGen *)ptr)->soap_out(soap, "nyapc1:getWrapGen", id, NULL);
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse:
		return ((_nyapc1__getJobsWrapStatInvalidResponse *)ptr)->soap_out(soap, "nyapc1:getJobsWrapStatInvalidResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalid:
		return ((_nyapc1__getJobsWrapStatInvalid *)ptr)->soap_out(soap, "nyapc1:getJobsWrapStatInvalid", id, NULL);
	case SOAP_TYPE__nyapc1__getJobsResponse:
		return ((_nyapc1__getJobsResponse *)ptr)->soap_out(soap, "nyapc1:getJobsResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getJobs:
		return ((_nyapc1__getJobs *)ptr)->soap_out(soap, "nyapc1:getJobs", id, NULL);
	case SOAP_TYPE__nyapc1__getJobIDResponse:
		return ((_nyapc1__getJobIDResponse *)ptr)->soap_out(soap, "nyapc1:getJobIDResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getJobID:
		return ((_nyapc1__getJobID *)ptr)->soap_out(soap, "nyapc1:getJobID", id, NULL);
	case SOAP_TYPE__nyapc1__putResultResponse:
		return ((_nyapc1__putResultResponse *)ptr)->soap_out(soap, "nyapc1:putResultResponse", id, NULL);
	case SOAP_TYPE__nyapc1__putResult:
		return ((_nyapc1__putResult *)ptr)->soap_out(soap, "nyapc1:putResult", id, NULL);
	case SOAP_TYPE__nyapc1__getStatResponse:
		return ((_nyapc1__getStatResponse *)ptr)->soap_out(soap, "nyapc1:getStatResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getStat:
		return ((_nyapc1__getStat *)ptr)->soap_out(soap, "nyapc1:getStat", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse:
		return ((_nyapc1__updateWrapperCheckOkResponse *)ptr)->soap_out(soap, "nyapc1:updateWrapperCheckOkResponse", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapperCheckOk:
		return ((_nyapc1__updateWrapperCheckOk *)ptr)->soap_out(soap, "nyapc1:updateWrapperCheckOk", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapperResponse:
		return ((_nyapc1__updateWrapperResponse *)ptr)->soap_out(soap, "nyapc1:updateWrapperResponse", id, NULL);
	case SOAP_TYPE__nyapc1__updateWrapper:
		return ((_nyapc1__updateWrapper *)ptr)->soap_out(soap, "nyapc1:updateWrapper", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse:
		return ((_nyapc1__getWrapInvalidTaskResponse *)ptr)->soap_out(soap, "nyapc1:getWrapInvalidTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapInvalidTask:
		return ((_nyapc1__getWrapInvalidTask *)ptr)->soap_out(soap, "nyapc1:getWrapInvalidTask", id, NULL);
	case SOAP_TYPE__nyapc1__takeWrapTaskResponse:
		return ((_nyapc1__takeWrapTaskResponse *)ptr)->soap_out(soap, "nyapc1:takeWrapTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__takeWrapTask:
		return ((_nyapc1__takeWrapTask *)ptr)->soap_out(soap, "nyapc1:takeWrapTask", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapTaskResponse:
		return ((_nyapc1__getWrapTaskResponse *)ptr)->soap_out(soap, "nyapc1:getWrapTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapTask:
		return ((_nyapc1__getWrapTask *)ptr)->soap_out(soap, "nyapc1:getWrapTask", id, NULL);
	case SOAP_TYPE__nyapc1__getTaskResponse:
		return ((_nyapc1__getTaskResponse *)ptr)->soap_out(soap, "nyapc1:getTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getTask:
		return ((_nyapc1__getTask *)ptr)->soap_out(soap, "nyapc1:getTask", id, NULL);
	case SOAP_TYPE__nyapc1__addWrapperResponse:
		return ((_nyapc1__addWrapperResponse *)ptr)->soap_out(soap, "nyapc1:addWrapperResponse", id, NULL);
	case SOAP_TYPE__nyapc1__addWrapper:
		return ((_nyapc1__addWrapper *)ptr)->soap_out(soap, "nyapc1:addWrapper", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapperResponse:
		return ((_nyapc1__getWrapperResponse *)ptr)->soap_out(soap, "nyapc1:getWrapperResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getWrapper:
		return ((_nyapc1__getWrapper *)ptr)->soap_out(soap, "nyapc1:getWrapper", id, NULL);
	case SOAP_TYPE__nyapc1__updateJobResponse:
		return ((_nyapc1__updateJobResponse *)ptr)->soap_out(soap, "nyapc1:updateJobResponse", id, NULL);
	case SOAP_TYPE__nyapc1__updateJob:
		return ((_nyapc1__updateJob *)ptr)->soap_out(soap, "nyapc1:updateJob", id, NULL);
	case SOAP_TYPE__nyapc1__hasTaskResponse:
		return ((_nyapc1__hasTaskResponse *)ptr)->soap_out(soap, "nyapc1:hasTaskResponse", id, NULL);
	case SOAP_TYPE__nyapc1__hasTask:
		return ((_nyapc1__hasTask *)ptr)->soap_out(soap, "nyapc1:hasTask", id, NULL);
	case SOAP_TYPE__nyapc1__addJobResponse:
		return ((_nyapc1__addJobResponse *)ptr)->soap_out(soap, "nyapc1:addJobResponse", id, NULL);
	case SOAP_TYPE__nyapc1__addJob:
		return ((_nyapc1__addJob *)ptr)->soap_out(soap, "nyapc1:addJob", id, NULL);
	case SOAP_TYPE__nyapc1__getJobResponse:
		return ((_nyapc1__getJobResponse *)ptr)->soap_out(soap, "nyapc1:getJobResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getJob:
		return ((_nyapc1__getJob *)ptr)->soap_out(soap, "nyapc1:getJob", id, NULL);
	case SOAP_TYPE__nyapc1__getVersionResponse:
		return ((_nyapc1__getVersionResponse *)ptr)->soap_out(soap, "nyapc1:getVersionResponse", id, NULL);
	case SOAP_TYPE__nyapc1__getVersion:
		return ((_nyapc1__getVersion *)ptr)->soap_out(soap, "nyapc1:getVersion", id, NULL);
	case SOAP_TYPE__nyapc1__addResponse:
		return ((_nyapc1__addResponse *)ptr)->soap_out(soap, "nyapc1:addResponse", id, NULL);
	case SOAP_TYPE__nyapc1__add:
		return ((_nyapc1__add *)ptr)->soap_out(soap, "nyapc1:add", id, NULL);
	case SOAP_TYPE_nyapc1__Task:
		return ((nyapc1__Task *)ptr)->soap_out(soap, tag, id, "nyapc1:Task");
	case SOAP_TYPE_nyapc1__JobAtt:
		return ((nyapc1__JobAtt *)ptr)->soap_out(soap, tag, id, "nyapc1:JobAtt");
	case SOAP_TYPE_PointerTo_nyapc1__getWraptypeResponse:
		return soap_out_PointerTo_nyapc1__getWraptypeResponse(soap, tag, id, (_nyapc1__getWraptypeResponse *const*)ptr, "nyapc1:getWraptypeResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWraptype:
		return soap_out_PointerTo_nyapc1__getWraptype(soap, tag, id, (_nyapc1__getWraptype *const*)ptr, "nyapc1:getWraptype");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapIdResponse:
		return soap_out_PointerTo_nyapc1__getWrapIdResponse(soap, tag, id, (_nyapc1__getWrapIdResponse *const*)ptr, "nyapc1:getWrapIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapId:
		return soap_out_PointerTo_nyapc1__getWrapId(soap, tag, id, (_nyapc1__getWrapId *const*)ptr, "nyapc1:getWrapId");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse:
		return soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag, id, (_nyapc1__getWrapInvalidTaskByJobIdResponse *const*)ptr, "nyapc1:getWrapInvalidTaskByJobIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobId:
		return soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, tag, id, (_nyapc1__getWrapInvalidTaskByJobId *const*)ptr, "nyapc1:getWrapInvalidTaskByJobId");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrlResponse:
		return soap_out_PointerTo_nyapc1__updateJobUrlResponse(soap, tag, id, (_nyapc1__updateJobUrlResponse *const*)ptr, "nyapc1:updateJobUrlResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrl:
		return soap_out_PointerTo_nyapc1__updateJobUrl(soap, tag, id, (_nyapc1__updateJobUrl *const*)ptr, "nyapc1:updateJobUrl");
	case SOAP_TYPE_PointerTo_nyapc1__delJobResponse:
		return soap_out_PointerTo_nyapc1__delJobResponse(soap, tag, id, (_nyapc1__delJobResponse *const*)ptr, "nyapc1:delJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__delJob:
		return soap_out_PointerTo_nyapc1__delJob(soap, tag, id, (_nyapc1__delJob *const*)ptr, "nyapc1:delJob");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobIdResponse:
		return soap_out_PointerTo_nyapc1__getTaskByJobIdResponse(soap, tag, id, (_nyapc1__getTaskByJobIdResponse *const*)ptr, "nyapc1:getTaskByJobIdResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobId:
		return soap_out_PointerTo_nyapc1__getTaskByJobId(soap, tag, id, (_nyapc1__getTaskByJobId *const*)ptr, "nyapc1:getTaskByJobId");
	case SOAP_TYPE_PointerTo_nyapc1__takeTaskResponse:
		return soap_out_PointerTo_nyapc1__takeTaskResponse(soap, tag, id, (_nyapc1__takeTaskResponse *const*)ptr, "nyapc1:takeTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__takeTask:
		return soap_out_PointerTo_nyapc1__takeTask(soap, tag, id, (_nyapc1__takeTask *const*)ptr, "nyapc1:takeTask");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueueResponse:
		return soap_out_PointerTo_nyapc1__getWrapTaskQueueResponse(soap, tag, id, (_nyapc1__getWrapTaskQueueResponse *const*)ptr, "nyapc1:getWrapTaskQueueResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueue:
		return soap_out_PointerTo_nyapc1__getWrapTaskQueue(soap, tag, id, (_nyapc1__getWrapTaskQueue *const*)ptr, "nyapc1:getWrapTaskQueue");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueueResponse:
		return soap_out_PointerTo_nyapc1__getTaskQueueResponse(soap, tag, id, (_nyapc1__getTaskQueueResponse *const*)ptr, "nyapc1:getTaskQueueResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueue:
		return soap_out_PointerTo_nyapc1__getTaskQueue(soap, tag, id, (_nyapc1__getTaskQueue *const*)ptr, "nyapc1:getTaskQueue");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGenResponse:
		return soap_out_PointerTo_nyapc1__updateWrapGenResponse(soap, tag, id, (_nyapc1__updateWrapGenResponse *const*)ptr, "nyapc1:updateWrapGenResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGen:
		return soap_out_PointerTo_nyapc1__updateWrapGen(soap, tag, id, (_nyapc1__updateWrapGen *const*)ptr, "nyapc1:updateWrapGen");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGenResponse:
		return soap_out_PointerTo_nyapc1__getWrapGenResponse(soap, tag, id, (_nyapc1__getWrapGenResponse *const*)ptr, "nyapc1:getWrapGenResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGen:
		return soap_out_PointerTo_nyapc1__getWrapGen(soap, tag, id, (_nyapc1__getWrapGen *const*)ptr, "nyapc1:getWrapGen");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalidResponse:
		return soap_out_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(soap, tag, id, (_nyapc1__getJobsWrapStatInvalidResponse *const*)ptr, "nyapc1:getJobsWrapStatInvalidResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalid:
		return soap_out_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, tag, id, (_nyapc1__getJobsWrapStatInvalid *const*)ptr, "nyapc1:getJobsWrapStatInvalid");
	case SOAP_TYPE_PointerTo_nyapc1__getJobsResponse:
		return soap_out_PointerTo_nyapc1__getJobsResponse(soap, tag, id, (_nyapc1__getJobsResponse *const*)ptr, "nyapc1:getJobsResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobs:
		return soap_out_PointerTo_nyapc1__getJobs(soap, tag, id, (_nyapc1__getJobs *const*)ptr, "nyapc1:getJobs");
	case SOAP_TYPE_PointerTo_nyapc1__getJobIDResponse:
		return soap_out_PointerTo_nyapc1__getJobIDResponse(soap, tag, id, (_nyapc1__getJobIDResponse *const*)ptr, "nyapc1:getJobIDResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJobID:
		return soap_out_PointerTo_nyapc1__getJobID(soap, tag, id, (_nyapc1__getJobID *const*)ptr, "nyapc1:getJobID");
	case SOAP_TYPE_PointerTo_nyapc1__putResultResponse:
		return soap_out_PointerTo_nyapc1__putResultResponse(soap, tag, id, (_nyapc1__putResultResponse *const*)ptr, "nyapc1:putResultResponse");
	case SOAP_TYPE_PointerTo_nyapc1__putResult:
		return soap_out_PointerTo_nyapc1__putResult(soap, tag, id, (_nyapc1__putResult *const*)ptr, "nyapc1:putResult");
	case SOAP_TYPE_PointerTo_nyapc1__getStatResponse:
		return soap_out_PointerTo_nyapc1__getStatResponse(soap, tag, id, (_nyapc1__getStatResponse *const*)ptr, "nyapc1:getStatResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getStat:
		return soap_out_PointerTo_nyapc1__getStat(soap, tag, id, (_nyapc1__getStat *const*)ptr, "nyapc1:getStat");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOkResponse:
		return soap_out_PointerTo_nyapc1__updateWrapperCheckOkResponse(soap, tag, id, (_nyapc1__updateWrapperCheckOkResponse *const*)ptr, "nyapc1:updateWrapperCheckOkResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOk:
		return soap_out_PointerTo_nyapc1__updateWrapperCheckOk(soap, tag, id, (_nyapc1__updateWrapperCheckOk *const*)ptr, "nyapc1:updateWrapperCheckOk");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperResponse:
		return soap_out_PointerTo_nyapc1__updateWrapperResponse(soap, tag, id, (_nyapc1__updateWrapperResponse *const*)ptr, "nyapc1:updateWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapper:
		return soap_out_PointerTo_nyapc1__updateWrapper(soap, tag, id, (_nyapc1__updateWrapper *const*)ptr, "nyapc1:updateWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskResponse:
		return soap_out_PointerTo_nyapc1__getWrapInvalidTaskResponse(soap, tag, id, (_nyapc1__getWrapInvalidTaskResponse *const*)ptr, "nyapc1:getWrapInvalidTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTask:
		return soap_out_PointerTo_nyapc1__getWrapInvalidTask(soap, tag, id, (_nyapc1__getWrapInvalidTask *const*)ptr, "nyapc1:getWrapInvalidTask");
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTaskResponse:
		return soap_out_PointerTo_nyapc1__takeWrapTaskResponse(soap, tag, id, (_nyapc1__takeWrapTaskResponse *const*)ptr, "nyapc1:takeWrapTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTask:
		return soap_out_PointerTo_nyapc1__takeWrapTask(soap, tag, id, (_nyapc1__takeWrapTask *const*)ptr, "nyapc1:takeWrapTask");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskResponse:
		return soap_out_PointerTo_nyapc1__getWrapTaskResponse(soap, tag, id, (_nyapc1__getWrapTaskResponse *const*)ptr, "nyapc1:getWrapTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTask:
		return soap_out_PointerTo_nyapc1__getWrapTask(soap, tag, id, (_nyapc1__getWrapTask *const*)ptr, "nyapc1:getWrapTask");
	case SOAP_TYPE_PointerTo_nyapc1__getTaskResponse:
		return soap_out_PointerTo_nyapc1__getTaskResponse(soap, tag, id, (_nyapc1__getTaskResponse *const*)ptr, "nyapc1:getTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getTask:
		return soap_out_PointerTo_nyapc1__getTask(soap, tag, id, (_nyapc1__getTask *const*)ptr, "nyapc1:getTask");
	case SOAP_TYPE_PointerTo_nyapc1__addWrapperResponse:
		return soap_out_PointerTo_nyapc1__addWrapperResponse(soap, tag, id, (_nyapc1__addWrapperResponse *const*)ptr, "nyapc1:addWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__addWrapper:
		return soap_out_PointerTo_nyapc1__addWrapper(soap, tag, id, (_nyapc1__addWrapper *const*)ptr, "nyapc1:addWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapperResponse:
		return soap_out_PointerTo_nyapc1__getWrapperResponse(soap, tag, id, (_nyapc1__getWrapperResponse *const*)ptr, "nyapc1:getWrapperResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getWrapper:
		return soap_out_PointerTo_nyapc1__getWrapper(soap, tag, id, (_nyapc1__getWrapper *const*)ptr, "nyapc1:getWrapper");
	case SOAP_TYPE_PointerTo_nyapc1__updateJobResponse:
		return soap_out_PointerTo_nyapc1__updateJobResponse(soap, tag, id, (_nyapc1__updateJobResponse *const*)ptr, "nyapc1:updateJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__updateJob:
		return soap_out_PointerTo_nyapc1__updateJob(soap, tag, id, (_nyapc1__updateJob *const*)ptr, "nyapc1:updateJob");
	case SOAP_TYPE_PointerTo_nyapc1__hasTaskResponse:
		return soap_out_PointerTo_nyapc1__hasTaskResponse(soap, tag, id, (_nyapc1__hasTaskResponse *const*)ptr, "nyapc1:hasTaskResponse");
	case SOAP_TYPE_PointerTo_nyapc1__hasTask:
		return soap_out_PointerTo_nyapc1__hasTask(soap, tag, id, (_nyapc1__hasTask *const*)ptr, "nyapc1:hasTask");
	case SOAP_TYPE_PointerTo_nyapc1__addJobResponse:
		return soap_out_PointerTo_nyapc1__addJobResponse(soap, tag, id, (_nyapc1__addJobResponse *const*)ptr, "nyapc1:addJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__addJob:
		return soap_out_PointerTo_nyapc1__addJob(soap, tag, id, (_nyapc1__addJob *const*)ptr, "nyapc1:addJob");
	case SOAP_TYPE_PointerTo_nyapc1__getJobResponse:
		return soap_out_PointerTo_nyapc1__getJobResponse(soap, tag, id, (_nyapc1__getJobResponse *const*)ptr, "nyapc1:getJobResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getJob:
		return soap_out_PointerTo_nyapc1__getJob(soap, tag, id, (_nyapc1__getJob *const*)ptr, "nyapc1:getJob");
	case SOAP_TYPE_PointerTo_nyapc1__getVersionResponse:
		return soap_out_PointerTo_nyapc1__getVersionResponse(soap, tag, id, (_nyapc1__getVersionResponse *const*)ptr, "nyapc1:getVersionResponse");
	case SOAP_TYPE_PointerTo_nyapc1__getVersion:
		return soap_out_PointerTo_nyapc1__getVersion(soap, tag, id, (_nyapc1__getVersion *const*)ptr, "nyapc1:getVersion");
	case SOAP_TYPE_PointerTo_nyapc1__addResponse:
		return soap_out_PointerTo_nyapc1__addResponse(soap, tag, id, (_nyapc1__addResponse *const*)ptr, "nyapc1:addResponse");
	case SOAP_TYPE_PointerTo_nyapc1__add:
		return soap_out_PointerTo_nyapc1__add(soap, tag, id, (_nyapc1__add *const*)ptr, "nyapc1:add");
	case SOAP_TYPE_PointerTonyapc1__Task:
		return soap_out_PointerTonyapc1__Task(soap, tag, id, (nyapc1__Task *const*)ptr, "nyapc1:Task");
	case SOAP_TYPE_PointerTonyapc1__JobAtt:
		return soap_out_PointerTonyapc1__JobAtt(soap, tag, id, (nyapc1__JobAtt *const*)ptr, "nyapc1:JobAtt");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_nyapc2__AttSuperClass:
		((nyapc2__AttSuperClass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWraptypeResponse:
		((_nyapc1__getWraptypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWraptype:
		((_nyapc1__getWraptype *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapIdResponse:
		((_nyapc1__getWrapIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapId:
		((_nyapc1__getWrapId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse:
		((_nyapc1__getWrapInvalidTaskByJobIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId:
		((_nyapc1__getWrapInvalidTaskByJobId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateJobUrlResponse:
		((_nyapc1__updateJobUrlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateJobUrl:
		((_nyapc1__updateJobUrl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__delJobResponse:
		((_nyapc1__delJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__delJob:
		((_nyapc1__delJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTaskByJobIdResponse:
		((_nyapc1__getTaskByJobIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTaskByJobId:
		((_nyapc1__getTaskByJobId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__takeTaskResponse:
		((_nyapc1__takeTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__takeTask:
		((_nyapc1__takeTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskQueueResponse:
		((_nyapc1__getWrapTaskQueueResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskQueue:
		((_nyapc1__getWrapTaskQueue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTaskQueueResponse:
		((_nyapc1__getTaskQueueResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTaskQueue:
		((_nyapc1__getTaskQueue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapGenResponse:
		((_nyapc1__updateWrapGenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapGen:
		((_nyapc1__updateWrapGen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapGenResponse:
		((_nyapc1__getWrapGenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapGen:
		((_nyapc1__getWrapGen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse:
		((_nyapc1__getJobsWrapStatInvalidResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalid:
		((_nyapc1__getJobsWrapStatInvalid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobsResponse:
		((_nyapc1__getJobsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobs:
		((_nyapc1__getJobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobIDResponse:
		((_nyapc1__getJobIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobID:
		((_nyapc1__getJobID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__putResultResponse:
		((_nyapc1__putResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__putResult:
		((_nyapc1__putResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getStatResponse:
		((_nyapc1__getStatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getStat:
		((_nyapc1__getStat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse:
		((_nyapc1__updateWrapperCheckOkResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapperCheckOk:
		((_nyapc1__updateWrapperCheckOk *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapperResponse:
		((_nyapc1__updateWrapperResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateWrapper:
		((_nyapc1__updateWrapper *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse:
		((_nyapc1__getWrapInvalidTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTask:
		((_nyapc1__getWrapInvalidTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__takeWrapTaskResponse:
		((_nyapc1__takeWrapTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__takeWrapTask:
		((_nyapc1__takeWrapTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskResponse:
		((_nyapc1__getWrapTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapTask:
		((_nyapc1__getWrapTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTaskResponse:
		((_nyapc1__getTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getTask:
		((_nyapc1__getTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__addWrapperResponse:
		((_nyapc1__addWrapperResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__addWrapper:
		((_nyapc1__addWrapper *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapperResponse:
		((_nyapc1__getWrapperResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getWrapper:
		((_nyapc1__getWrapper *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateJobResponse:
		((_nyapc1__updateJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__updateJob:
		((_nyapc1__updateJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__hasTaskResponse:
		((_nyapc1__hasTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__hasTask:
		((_nyapc1__hasTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__addJobResponse:
		((_nyapc1__addJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__addJob:
		((_nyapc1__addJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJobResponse:
		((_nyapc1__getJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getJob:
		((_nyapc1__getJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getVersionResponse:
		((_nyapc1__getVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__getVersion:
		((_nyapc1__getVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__addResponse:
		((_nyapc1__addResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__nyapc1__add:
		((_nyapc1__add *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_nyapc1__Task:
		((nyapc1__Task *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_nyapc1__JobAtt:
		((nyapc1__JobAtt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___nyapc1__getWraptype:
		soap_serialize___nyapc1__getWraptype(soap, (const struct __nyapc1__getWraptype *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapId:
		soap_serialize___nyapc1__getWrapId(soap, (const struct __nyapc1__getWrapId *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId:
		soap_serialize___nyapc1__getWrapInvalidTaskByJobId(soap, (const struct __nyapc1__getWrapInvalidTaskByJobId *)ptr);
		break;
	case SOAP_TYPE___nyapc1__updateJobUrl:
		soap_serialize___nyapc1__updateJobUrl(soap, (const struct __nyapc1__updateJobUrl *)ptr);
		break;
	case SOAP_TYPE___nyapc1__delJob:
		soap_serialize___nyapc1__delJob(soap, (const struct __nyapc1__delJob *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getTaskByJobId:
		soap_serialize___nyapc1__getTaskByJobId(soap, (const struct __nyapc1__getTaskByJobId *)ptr);
		break;
	case SOAP_TYPE___nyapc1__takeTask:
		soap_serialize___nyapc1__takeTask(soap, (const struct __nyapc1__takeTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapTaskQueue:
		soap_serialize___nyapc1__getWrapTaskQueue(soap, (const struct __nyapc1__getWrapTaskQueue *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getTaskQueue:
		soap_serialize___nyapc1__getTaskQueue(soap, (const struct __nyapc1__getTaskQueue *)ptr);
		break;
	case SOAP_TYPE___nyapc1__updateWrapGen:
		soap_serialize___nyapc1__updateWrapGen(soap, (const struct __nyapc1__updateWrapGen *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapGen:
		soap_serialize___nyapc1__getWrapGen(soap, (const struct __nyapc1__getWrapGen *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getJobsWrapStatInvalid:
		soap_serialize___nyapc1__getJobsWrapStatInvalid(soap, (const struct __nyapc1__getJobsWrapStatInvalid *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getJobs:
		soap_serialize___nyapc1__getJobs(soap, (const struct __nyapc1__getJobs *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getJobID:
		soap_serialize___nyapc1__getJobID(soap, (const struct __nyapc1__getJobID *)ptr);
		break;
	case SOAP_TYPE___nyapc1__putResult:
		soap_serialize___nyapc1__putResult(soap, (const struct __nyapc1__putResult *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getStat:
		soap_serialize___nyapc1__getStat(soap, (const struct __nyapc1__getStat *)ptr);
		break;
	case SOAP_TYPE___nyapc1__updateWrapperCheckOk:
		soap_serialize___nyapc1__updateWrapperCheckOk(soap, (const struct __nyapc1__updateWrapperCheckOk *)ptr);
		break;
	case SOAP_TYPE___nyapc1__updateWrapper:
		soap_serialize___nyapc1__updateWrapper(soap, (const struct __nyapc1__updateWrapper *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapInvalidTask:
		soap_serialize___nyapc1__getWrapInvalidTask(soap, (const struct __nyapc1__getWrapInvalidTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__takeWrapTask:
		soap_serialize___nyapc1__takeWrapTask(soap, (const struct __nyapc1__takeWrapTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapTask:
		soap_serialize___nyapc1__getWrapTask(soap, (const struct __nyapc1__getWrapTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getTask:
		soap_serialize___nyapc1__getTask(soap, (const struct __nyapc1__getTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__addWrapper:
		soap_serialize___nyapc1__addWrapper(soap, (const struct __nyapc1__addWrapper *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getWrapper:
		soap_serialize___nyapc1__getWrapper(soap, (const struct __nyapc1__getWrapper *)ptr);
		break;
	case SOAP_TYPE___nyapc1__updateJob:
		soap_serialize___nyapc1__updateJob(soap, (const struct __nyapc1__updateJob *)ptr);
		break;
	case SOAP_TYPE___nyapc1__hasTask:
		soap_serialize___nyapc1__hasTask(soap, (const struct __nyapc1__hasTask *)ptr);
		break;
	case SOAP_TYPE___nyapc1__addJob:
		soap_serialize___nyapc1__addJob(soap, (const struct __nyapc1__addJob *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getJob:
		soap_serialize___nyapc1__getJob(soap, (const struct __nyapc1__getJob *)ptr);
		break;
	case SOAP_TYPE___nyapc1__getVersion:
		soap_serialize___nyapc1__getVersion(soap, (const struct __nyapc1__getVersion *)ptr);
		break;
	case SOAP_TYPE___nyapc1__add:
		soap_serialize___nyapc1__add(soap, (const struct __nyapc1__add *)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWraptypeResponse:
		soap_serialize_PointerTo_nyapc1__getWraptypeResponse(soap, (_nyapc1__getWraptypeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWraptype:
		soap_serialize_PointerTo_nyapc1__getWraptype(soap, (_nyapc1__getWraptype *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapIdResponse:
		soap_serialize_PointerTo_nyapc1__getWrapIdResponse(soap, (_nyapc1__getWrapIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapId:
		soap_serialize_PointerTo_nyapc1__getWrapId(soap, (_nyapc1__getWrapId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse:
		soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(soap, (_nyapc1__getWrapInvalidTaskByJobIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobId:
		soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, (_nyapc1__getWrapInvalidTaskByJobId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrlResponse:
		soap_serialize_PointerTo_nyapc1__updateJobUrlResponse(soap, (_nyapc1__updateJobUrlResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateJobUrl:
		soap_serialize_PointerTo_nyapc1__updateJobUrl(soap, (_nyapc1__updateJobUrl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__delJobResponse:
		soap_serialize_PointerTo_nyapc1__delJobResponse(soap, (_nyapc1__delJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__delJob:
		soap_serialize_PointerTo_nyapc1__delJob(soap, (_nyapc1__delJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobIdResponse:
		soap_serialize_PointerTo_nyapc1__getTaskByJobIdResponse(soap, (_nyapc1__getTaskByJobIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTaskByJobId:
		soap_serialize_PointerTo_nyapc1__getTaskByJobId(soap, (_nyapc1__getTaskByJobId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__takeTaskResponse:
		soap_serialize_PointerTo_nyapc1__takeTaskResponse(soap, (_nyapc1__takeTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__takeTask:
		soap_serialize_PointerTo_nyapc1__takeTask(soap, (_nyapc1__takeTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueueResponse:
		soap_serialize_PointerTo_nyapc1__getWrapTaskQueueResponse(soap, (_nyapc1__getWrapTaskQueueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueue:
		soap_serialize_PointerTo_nyapc1__getWrapTaskQueue(soap, (_nyapc1__getWrapTaskQueue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueueResponse:
		soap_serialize_PointerTo_nyapc1__getTaskQueueResponse(soap, (_nyapc1__getTaskQueueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTaskQueue:
		soap_serialize_PointerTo_nyapc1__getTaskQueue(soap, (_nyapc1__getTaskQueue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGenResponse:
		soap_serialize_PointerTo_nyapc1__updateWrapGenResponse(soap, (_nyapc1__updateWrapGenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapGen:
		soap_serialize_PointerTo_nyapc1__updateWrapGen(soap, (_nyapc1__updateWrapGen *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGenResponse:
		soap_serialize_PointerTo_nyapc1__getWrapGenResponse(soap, (_nyapc1__getWrapGenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapGen:
		soap_serialize_PointerTo_nyapc1__getWrapGen(soap, (_nyapc1__getWrapGen *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalidResponse:
		soap_serialize_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(soap, (_nyapc1__getJobsWrapStatInvalidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalid:
		soap_serialize_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, (_nyapc1__getJobsWrapStatInvalid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobsResponse:
		soap_serialize_PointerTo_nyapc1__getJobsResponse(soap, (_nyapc1__getJobsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobs:
		soap_serialize_PointerTo_nyapc1__getJobs(soap, (_nyapc1__getJobs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobIDResponse:
		soap_serialize_PointerTo_nyapc1__getJobIDResponse(soap, (_nyapc1__getJobIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobID:
		soap_serialize_PointerTo_nyapc1__getJobID(soap, (_nyapc1__getJobID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__putResultResponse:
		soap_serialize_PointerTo_nyapc1__putResultResponse(soap, (_nyapc1__putResultResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__putResult:
		soap_serialize_PointerTo_nyapc1__putResult(soap, (_nyapc1__putResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getStatResponse:
		soap_serialize_PointerTo_nyapc1__getStatResponse(soap, (_nyapc1__getStatResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getStat:
		soap_serialize_PointerTo_nyapc1__getStat(soap, (_nyapc1__getStat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOkResponse:
		soap_serialize_PointerTo_nyapc1__updateWrapperCheckOkResponse(soap, (_nyapc1__updateWrapperCheckOkResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOk:
		soap_serialize_PointerTo_nyapc1__updateWrapperCheckOk(soap, (_nyapc1__updateWrapperCheckOk *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapperResponse:
		soap_serialize_PointerTo_nyapc1__updateWrapperResponse(soap, (_nyapc1__updateWrapperResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateWrapper:
		soap_serialize_PointerTo_nyapc1__updateWrapper(soap, (_nyapc1__updateWrapper *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskResponse:
		soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskResponse(soap, (_nyapc1__getWrapInvalidTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTask:
		soap_serialize_PointerTo_nyapc1__getWrapInvalidTask(soap, (_nyapc1__getWrapInvalidTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTaskResponse:
		soap_serialize_PointerTo_nyapc1__takeWrapTaskResponse(soap, (_nyapc1__takeWrapTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__takeWrapTask:
		soap_serialize_PointerTo_nyapc1__takeWrapTask(soap, (_nyapc1__takeWrapTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTaskResponse:
		soap_serialize_PointerTo_nyapc1__getWrapTaskResponse(soap, (_nyapc1__getWrapTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapTask:
		soap_serialize_PointerTo_nyapc1__getWrapTask(soap, (_nyapc1__getWrapTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTaskResponse:
		soap_serialize_PointerTo_nyapc1__getTaskResponse(soap, (_nyapc1__getTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getTask:
		soap_serialize_PointerTo_nyapc1__getTask(soap, (_nyapc1__getTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__addWrapperResponse:
		soap_serialize_PointerTo_nyapc1__addWrapperResponse(soap, (_nyapc1__addWrapperResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__addWrapper:
		soap_serialize_PointerTo_nyapc1__addWrapper(soap, (_nyapc1__addWrapper *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapperResponse:
		soap_serialize_PointerTo_nyapc1__getWrapperResponse(soap, (_nyapc1__getWrapperResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getWrapper:
		soap_serialize_PointerTo_nyapc1__getWrapper(soap, (_nyapc1__getWrapper *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateJobResponse:
		soap_serialize_PointerTo_nyapc1__updateJobResponse(soap, (_nyapc1__updateJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__updateJob:
		soap_serialize_PointerTo_nyapc1__updateJob(soap, (_nyapc1__updateJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__hasTaskResponse:
		soap_serialize_PointerTo_nyapc1__hasTaskResponse(soap, (_nyapc1__hasTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__hasTask:
		soap_serialize_PointerTo_nyapc1__hasTask(soap, (_nyapc1__hasTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__addJobResponse:
		soap_serialize_PointerTo_nyapc1__addJobResponse(soap, (_nyapc1__addJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__addJob:
		soap_serialize_PointerTo_nyapc1__addJob(soap, (_nyapc1__addJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJobResponse:
		soap_serialize_PointerTo_nyapc1__getJobResponse(soap, (_nyapc1__getJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getJob:
		soap_serialize_PointerTo_nyapc1__getJob(soap, (_nyapc1__getJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getVersionResponse:
		soap_serialize_PointerTo_nyapc1__getVersionResponse(soap, (_nyapc1__getVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__getVersion:
		soap_serialize_PointerTo_nyapc1__getVersion(soap, (_nyapc1__getVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__addResponse:
		soap_serialize_PointerTo_nyapc1__addResponse(soap, (_nyapc1__addResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_nyapc1__add:
		soap_serialize_PointerTo_nyapc1__add(soap, (_nyapc1__add *const*)ptr);
		break;
	case SOAP_TYPE_PointerTonyapc1__Task:
		soap_serialize_PointerTonyapc1__Task(soap, (nyapc1__Task *const*)ptr);
		break;
	case SOAP_TYPE_PointerTonyapc1__JobAtt:
		soap_serialize_PointerTonyapc1__JobAtt(soap, (nyapc1__JobAtt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_nyapc1__JobAtt:
		return (void*)soap_instantiate_nyapc1__JobAtt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__add:
		return (void*)soap_instantiate__nyapc1__add(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__addResponse:
		return (void*)soap_instantiate__nyapc1__addResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getVersion:
		return (void*)soap_instantiate__nyapc1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getVersionResponse:
		return (void*)soap_instantiate__nyapc1__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJob:
		return (void*)soap_instantiate__nyapc1__getJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobResponse:
		return (void*)soap_instantiate__nyapc1__getJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__addJob:
		return (void*)soap_instantiate__nyapc1__addJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__addJobResponse:
		return (void*)soap_instantiate__nyapc1__addJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__hasTask:
		return (void*)soap_instantiate__nyapc1__hasTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__hasTaskResponse:
		return (void*)soap_instantiate__nyapc1__hasTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateJob:
		return (void*)soap_instantiate__nyapc1__updateJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateJobResponse:
		return (void*)soap_instantiate__nyapc1__updateJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapper:
		return (void*)soap_instantiate__nyapc1__getWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapperResponse:
		return (void*)soap_instantiate__nyapc1__getWrapperResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__addWrapper:
		return (void*)soap_instantiate__nyapc1__addWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__addWrapperResponse:
		return (void*)soap_instantiate__nyapc1__addWrapperResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTask:
		return (void*)soap_instantiate__nyapc1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTaskResponse:
		return (void*)soap_instantiate__nyapc1__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapTask:
		return (void*)soap_instantiate__nyapc1__getWrapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapTaskResponse:
		return (void*)soap_instantiate__nyapc1__getWrapTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__takeWrapTask:
		return (void*)soap_instantiate__nyapc1__takeWrapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__takeWrapTaskResponse:
		return (void*)soap_instantiate__nyapc1__takeWrapTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapInvalidTask:
		return (void*)soap_instantiate__nyapc1__getWrapInvalidTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse:
		return (void*)soap_instantiate__nyapc1__getWrapInvalidTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapper:
		return (void*)soap_instantiate__nyapc1__updateWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapperResponse:
		return (void*)soap_instantiate__nyapc1__updateWrapperResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapperCheckOk:
		return (void*)soap_instantiate__nyapc1__updateWrapperCheckOk(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse:
		return (void*)soap_instantiate__nyapc1__updateWrapperCheckOkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getStat:
		return (void*)soap_instantiate__nyapc1__getStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getStatResponse:
		return (void*)soap_instantiate__nyapc1__getStatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__putResult:
		return (void*)soap_instantiate__nyapc1__putResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__putResultResponse:
		return (void*)soap_instantiate__nyapc1__putResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobID:
		return (void*)soap_instantiate__nyapc1__getJobID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobIDResponse:
		return (void*)soap_instantiate__nyapc1__getJobIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobs:
		return (void*)soap_instantiate__nyapc1__getJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobsResponse:
		return (void*)soap_instantiate__nyapc1__getJobsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalid:
		return (void*)soap_instantiate__nyapc1__getJobsWrapStatInvalid(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse:
		return (void*)soap_instantiate__nyapc1__getJobsWrapStatInvalidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapGen:
		return (void*)soap_instantiate__nyapc1__getWrapGen(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapGenResponse:
		return (void*)soap_instantiate__nyapc1__getWrapGenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapGen:
		return (void*)soap_instantiate__nyapc1__updateWrapGen(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateWrapGenResponse:
		return (void*)soap_instantiate__nyapc1__updateWrapGenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTaskQueue:
		return (void*)soap_instantiate__nyapc1__getTaskQueue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTaskQueueResponse:
		return (void*)soap_instantiate__nyapc1__getTaskQueueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapTaskQueue:
		return (void*)soap_instantiate__nyapc1__getWrapTaskQueue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapTaskQueueResponse:
		return (void*)soap_instantiate__nyapc1__getWrapTaskQueueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__takeTask:
		return (void*)soap_instantiate__nyapc1__takeTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__takeTaskResponse:
		return (void*)soap_instantiate__nyapc1__takeTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTaskByJobId:
		return (void*)soap_instantiate__nyapc1__getTaskByJobId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getTaskByJobIdResponse:
		return (void*)soap_instantiate__nyapc1__getTaskByJobIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__delJob:
		return (void*)soap_instantiate__nyapc1__delJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__delJobResponse:
		return (void*)soap_instantiate__nyapc1__delJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateJobUrl:
		return (void*)soap_instantiate__nyapc1__updateJobUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__updateJobUrlResponse:
		return (void*)soap_instantiate__nyapc1__updateJobUrlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId:
		return (void*)soap_instantiate__nyapc1__getWrapInvalidTaskByJobId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse:
		return (void*)soap_instantiate__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapId:
		return (void*)soap_instantiate__nyapc1__getWrapId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWrapIdResponse:
		return (void*)soap_instantiate__nyapc1__getWrapIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWraptype:
		return (void*)soap_instantiate__nyapc1__getWraptype(soap, -1, type, arrayType, n);
	case SOAP_TYPE__nyapc1__getWraptypeResponse:
		return (void*)soap_instantiate__nyapc1__getWraptypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_nyapc2__AttSuperClass:
		return (void*)soap_instantiate_nyapc2__AttSuperClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_nyapc1__Task:
		return (void*)soap_instantiate_nyapc1__Task(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__add:
		return (void*)soap_instantiate___nyapc1__add(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getVersion:
		return (void*)soap_instantiate___nyapc1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getJob:
		return (void*)soap_instantiate___nyapc1__getJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__addJob:
		return (void*)soap_instantiate___nyapc1__addJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__hasTask:
		return (void*)soap_instantiate___nyapc1__hasTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__updateJob:
		return (void*)soap_instantiate___nyapc1__updateJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapper:
		return (void*)soap_instantiate___nyapc1__getWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__addWrapper:
		return (void*)soap_instantiate___nyapc1__addWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getTask:
		return (void*)soap_instantiate___nyapc1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapTask:
		return (void*)soap_instantiate___nyapc1__getWrapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__takeWrapTask:
		return (void*)soap_instantiate___nyapc1__takeWrapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapInvalidTask:
		return (void*)soap_instantiate___nyapc1__getWrapInvalidTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__updateWrapper:
		return (void*)soap_instantiate___nyapc1__updateWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__updateWrapperCheckOk:
		return (void*)soap_instantiate___nyapc1__updateWrapperCheckOk(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getStat:
		return (void*)soap_instantiate___nyapc1__getStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__putResult:
		return (void*)soap_instantiate___nyapc1__putResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getJobID:
		return (void*)soap_instantiate___nyapc1__getJobID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getJobs:
		return (void*)soap_instantiate___nyapc1__getJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getJobsWrapStatInvalid:
		return (void*)soap_instantiate___nyapc1__getJobsWrapStatInvalid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapGen:
		return (void*)soap_instantiate___nyapc1__getWrapGen(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__updateWrapGen:
		return (void*)soap_instantiate___nyapc1__updateWrapGen(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getTaskQueue:
		return (void*)soap_instantiate___nyapc1__getTaskQueue(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapTaskQueue:
		return (void*)soap_instantiate___nyapc1__getWrapTaskQueue(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__takeTask:
		return (void*)soap_instantiate___nyapc1__takeTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getTaskByJobId:
		return (void*)soap_instantiate___nyapc1__getTaskByJobId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__delJob:
		return (void*)soap_instantiate___nyapc1__delJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__updateJobUrl:
		return (void*)soap_instantiate___nyapc1__updateJobUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId:
		return (void*)soap_instantiate___nyapc1__getWrapInvalidTaskByJobId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWrapId:
		return (void*)soap_instantiate___nyapc1__getWrapId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___nyapc1__getWraptype:
		return (void*)soap_instantiate___nyapc1__getWraptype(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTonyapc1__JobAtt:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_nyapc1__JobAtt:
		if (p->size < 0)
			delete (nyapc1__JobAtt*)p->ptr;
		else
			delete[] (nyapc1__JobAtt*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__add:
		if (p->size < 0)
			delete (_nyapc1__add*)p->ptr;
		else
			delete[] (_nyapc1__add*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__addResponse:
		if (p->size < 0)
			delete (_nyapc1__addResponse*)p->ptr;
		else
			delete[] (_nyapc1__addResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getVersion:
		if (p->size < 0)
			delete (_nyapc1__getVersion*)p->ptr;
		else
			delete[] (_nyapc1__getVersion*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getVersionResponse:
		if (p->size < 0)
			delete (_nyapc1__getVersionResponse*)p->ptr;
		else
			delete[] (_nyapc1__getVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJob:
		if (p->size < 0)
			delete (_nyapc1__getJob*)p->ptr;
		else
			delete[] (_nyapc1__getJob*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobResponse:
		if (p->size < 0)
			delete (_nyapc1__getJobResponse*)p->ptr;
		else
			delete[] (_nyapc1__getJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__addJob:
		if (p->size < 0)
			delete (_nyapc1__addJob*)p->ptr;
		else
			delete[] (_nyapc1__addJob*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__addJobResponse:
		if (p->size < 0)
			delete (_nyapc1__addJobResponse*)p->ptr;
		else
			delete[] (_nyapc1__addJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__hasTask:
		if (p->size < 0)
			delete (_nyapc1__hasTask*)p->ptr;
		else
			delete[] (_nyapc1__hasTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__hasTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__hasTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__hasTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateJob:
		if (p->size < 0)
			delete (_nyapc1__updateJob*)p->ptr;
		else
			delete[] (_nyapc1__updateJob*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateJobResponse:
		if (p->size < 0)
			delete (_nyapc1__updateJobResponse*)p->ptr;
		else
			delete[] (_nyapc1__updateJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapper:
		if (p->size < 0)
			delete (_nyapc1__getWrapper*)p->ptr;
		else
			delete[] (_nyapc1__getWrapper*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapperResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapperResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapperResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__addWrapper:
		if (p->size < 0)
			delete (_nyapc1__addWrapper*)p->ptr;
		else
			delete[] (_nyapc1__addWrapper*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__addWrapperResponse:
		if (p->size < 0)
			delete (_nyapc1__addWrapperResponse*)p->ptr;
		else
			delete[] (_nyapc1__addWrapperResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTask:
		if (p->size < 0)
			delete (_nyapc1__getTask*)p->ptr;
		else
			delete[] (_nyapc1__getTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__getTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__getTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapTask:
		if (p->size < 0)
			delete (_nyapc1__getWrapTask*)p->ptr;
		else
			delete[] (_nyapc1__getWrapTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__takeWrapTask:
		if (p->size < 0)
			delete (_nyapc1__takeWrapTask*)p->ptr;
		else
			delete[] (_nyapc1__takeWrapTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__takeWrapTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__takeWrapTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__takeWrapTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTask:
		if (p->size < 0)
			delete (_nyapc1__getWrapInvalidTask*)p->ptr;
		else
			delete[] (_nyapc1__getWrapInvalidTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapInvalidTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapInvalidTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapper:
		if (p->size < 0)
			delete (_nyapc1__updateWrapper*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapper*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapperResponse:
		if (p->size < 0)
			delete (_nyapc1__updateWrapperResponse*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapperResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapperCheckOk:
		if (p->size < 0)
			delete (_nyapc1__updateWrapperCheckOk*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapperCheckOk*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse:
		if (p->size < 0)
			delete (_nyapc1__updateWrapperCheckOkResponse*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapperCheckOkResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getStat:
		if (p->size < 0)
			delete (_nyapc1__getStat*)p->ptr;
		else
			delete[] (_nyapc1__getStat*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getStatResponse:
		if (p->size < 0)
			delete (_nyapc1__getStatResponse*)p->ptr;
		else
			delete[] (_nyapc1__getStatResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__putResult:
		if (p->size < 0)
			delete (_nyapc1__putResult*)p->ptr;
		else
			delete[] (_nyapc1__putResult*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__putResultResponse:
		if (p->size < 0)
			delete (_nyapc1__putResultResponse*)p->ptr;
		else
			delete[] (_nyapc1__putResultResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobID:
		if (p->size < 0)
			delete (_nyapc1__getJobID*)p->ptr;
		else
			delete[] (_nyapc1__getJobID*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobIDResponse:
		if (p->size < 0)
			delete (_nyapc1__getJobIDResponse*)p->ptr;
		else
			delete[] (_nyapc1__getJobIDResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobs:
		if (p->size < 0)
			delete (_nyapc1__getJobs*)p->ptr;
		else
			delete[] (_nyapc1__getJobs*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobsResponse:
		if (p->size < 0)
			delete (_nyapc1__getJobsResponse*)p->ptr;
		else
			delete[] (_nyapc1__getJobsResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalid:
		if (p->size < 0)
			delete (_nyapc1__getJobsWrapStatInvalid*)p->ptr;
		else
			delete[] (_nyapc1__getJobsWrapStatInvalid*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse:
		if (p->size < 0)
			delete (_nyapc1__getJobsWrapStatInvalidResponse*)p->ptr;
		else
			delete[] (_nyapc1__getJobsWrapStatInvalidResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapGen:
		if (p->size < 0)
			delete (_nyapc1__getWrapGen*)p->ptr;
		else
			delete[] (_nyapc1__getWrapGen*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapGenResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapGenResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapGenResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapGen:
		if (p->size < 0)
			delete (_nyapc1__updateWrapGen*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapGen*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateWrapGenResponse:
		if (p->size < 0)
			delete (_nyapc1__updateWrapGenResponse*)p->ptr;
		else
			delete[] (_nyapc1__updateWrapGenResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTaskQueue:
		if (p->size < 0)
			delete (_nyapc1__getTaskQueue*)p->ptr;
		else
			delete[] (_nyapc1__getTaskQueue*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTaskQueueResponse:
		if (p->size < 0)
			delete (_nyapc1__getTaskQueueResponse*)p->ptr;
		else
			delete[] (_nyapc1__getTaskQueueResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskQueue:
		if (p->size < 0)
			delete (_nyapc1__getWrapTaskQueue*)p->ptr;
		else
			delete[] (_nyapc1__getWrapTaskQueue*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapTaskQueueResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapTaskQueueResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapTaskQueueResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__takeTask:
		if (p->size < 0)
			delete (_nyapc1__takeTask*)p->ptr;
		else
			delete[] (_nyapc1__takeTask*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__takeTaskResponse:
		if (p->size < 0)
			delete (_nyapc1__takeTaskResponse*)p->ptr;
		else
			delete[] (_nyapc1__takeTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTaskByJobId:
		if (p->size < 0)
			delete (_nyapc1__getTaskByJobId*)p->ptr;
		else
			delete[] (_nyapc1__getTaskByJobId*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getTaskByJobIdResponse:
		if (p->size < 0)
			delete (_nyapc1__getTaskByJobIdResponse*)p->ptr;
		else
			delete[] (_nyapc1__getTaskByJobIdResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__delJob:
		if (p->size < 0)
			delete (_nyapc1__delJob*)p->ptr;
		else
			delete[] (_nyapc1__delJob*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__delJobResponse:
		if (p->size < 0)
			delete (_nyapc1__delJobResponse*)p->ptr;
		else
			delete[] (_nyapc1__delJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateJobUrl:
		if (p->size < 0)
			delete (_nyapc1__updateJobUrl*)p->ptr;
		else
			delete[] (_nyapc1__updateJobUrl*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__updateJobUrlResponse:
		if (p->size < 0)
			delete (_nyapc1__updateJobUrlResponse*)p->ptr;
		else
			delete[] (_nyapc1__updateJobUrlResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId:
		if (p->size < 0)
			delete (_nyapc1__getWrapInvalidTaskByJobId*)p->ptr;
		else
			delete[] (_nyapc1__getWrapInvalidTaskByJobId*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapInvalidTaskByJobIdResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapInvalidTaskByJobIdResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapId:
		if (p->size < 0)
			delete (_nyapc1__getWrapId*)p->ptr;
		else
			delete[] (_nyapc1__getWrapId*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWrapIdResponse:
		if (p->size < 0)
			delete (_nyapc1__getWrapIdResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWrapIdResponse*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWraptype:
		if (p->size < 0)
			delete (_nyapc1__getWraptype*)p->ptr;
		else
			delete[] (_nyapc1__getWraptype*)p->ptr;
		break;
	case SOAP_TYPE__nyapc1__getWraptypeResponse:
		if (p->size < 0)
			delete (_nyapc1__getWraptypeResponse*)p->ptr;
		else
			delete[] (_nyapc1__getWraptypeResponse*)p->ptr;
		break;
	case SOAP_TYPE_nyapc2__AttSuperClass:
		if (p->size < 0)
			delete (nyapc2__AttSuperClass*)p->ptr;
		else
			delete[] (nyapc2__AttSuperClass*)p->ptr;
		break;
	case SOAP_TYPE_nyapc1__Task:
		if (p->size < 0)
			delete (nyapc1__Task*)p->ptr;
		else
			delete[] (nyapc1__Task*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__add:
		if (p->size < 0)
			delete (struct __nyapc1__add*)p->ptr;
		else
			delete[] (struct __nyapc1__add*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getVersion:
		if (p->size < 0)
			delete (struct __nyapc1__getVersion*)p->ptr;
		else
			delete[] (struct __nyapc1__getVersion*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getJob:
		if (p->size < 0)
			delete (struct __nyapc1__getJob*)p->ptr;
		else
			delete[] (struct __nyapc1__getJob*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__addJob:
		if (p->size < 0)
			delete (struct __nyapc1__addJob*)p->ptr;
		else
			delete[] (struct __nyapc1__addJob*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__hasTask:
		if (p->size < 0)
			delete (struct __nyapc1__hasTask*)p->ptr;
		else
			delete[] (struct __nyapc1__hasTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__updateJob:
		if (p->size < 0)
			delete (struct __nyapc1__updateJob*)p->ptr;
		else
			delete[] (struct __nyapc1__updateJob*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapper:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapper*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapper*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__addWrapper:
		if (p->size < 0)
			delete (struct __nyapc1__addWrapper*)p->ptr;
		else
			delete[] (struct __nyapc1__addWrapper*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getTask:
		if (p->size < 0)
			delete (struct __nyapc1__getTask*)p->ptr;
		else
			delete[] (struct __nyapc1__getTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapTask:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapTask*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__takeWrapTask:
		if (p->size < 0)
			delete (struct __nyapc1__takeWrapTask*)p->ptr;
		else
			delete[] (struct __nyapc1__takeWrapTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapInvalidTask:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapInvalidTask*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapInvalidTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__updateWrapper:
		if (p->size < 0)
			delete (struct __nyapc1__updateWrapper*)p->ptr;
		else
			delete[] (struct __nyapc1__updateWrapper*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__updateWrapperCheckOk:
		if (p->size < 0)
			delete (struct __nyapc1__updateWrapperCheckOk*)p->ptr;
		else
			delete[] (struct __nyapc1__updateWrapperCheckOk*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getStat:
		if (p->size < 0)
			delete (struct __nyapc1__getStat*)p->ptr;
		else
			delete[] (struct __nyapc1__getStat*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__putResult:
		if (p->size < 0)
			delete (struct __nyapc1__putResult*)p->ptr;
		else
			delete[] (struct __nyapc1__putResult*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getJobID:
		if (p->size < 0)
			delete (struct __nyapc1__getJobID*)p->ptr;
		else
			delete[] (struct __nyapc1__getJobID*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getJobs:
		if (p->size < 0)
			delete (struct __nyapc1__getJobs*)p->ptr;
		else
			delete[] (struct __nyapc1__getJobs*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getJobsWrapStatInvalid:
		if (p->size < 0)
			delete (struct __nyapc1__getJobsWrapStatInvalid*)p->ptr;
		else
			delete[] (struct __nyapc1__getJobsWrapStatInvalid*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapGen:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapGen*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapGen*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__updateWrapGen:
		if (p->size < 0)
			delete (struct __nyapc1__updateWrapGen*)p->ptr;
		else
			delete[] (struct __nyapc1__updateWrapGen*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getTaskQueue:
		if (p->size < 0)
			delete (struct __nyapc1__getTaskQueue*)p->ptr;
		else
			delete[] (struct __nyapc1__getTaskQueue*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapTaskQueue:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapTaskQueue*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapTaskQueue*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__takeTask:
		if (p->size < 0)
			delete (struct __nyapc1__takeTask*)p->ptr;
		else
			delete[] (struct __nyapc1__takeTask*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getTaskByJobId:
		if (p->size < 0)
			delete (struct __nyapc1__getTaskByJobId*)p->ptr;
		else
			delete[] (struct __nyapc1__getTaskByJobId*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__delJob:
		if (p->size < 0)
			delete (struct __nyapc1__delJob*)p->ptr;
		else
			delete[] (struct __nyapc1__delJob*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__updateJobUrl:
		if (p->size < 0)
			delete (struct __nyapc1__updateJobUrl*)p->ptr;
		else
			delete[] (struct __nyapc1__updateJobUrl*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapInvalidTaskByJobId*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapInvalidTaskByJobId*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWrapId:
		if (p->size < 0)
			delete (struct __nyapc1__getWrapId*)p->ptr;
		else
			delete[] (struct __nyapc1__getWrapId*)p->ptr;
		break;
	case SOAP_TYPE___nyapc1__getWraptype:
		if (p->size < 0)
			delete (struct __nyapc1__getWraptype*)p->ptr;
		else
			delete[] (struct __nyapc1__getWraptype*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTonyapc1__JobAtt:
		if (p->size < 0)
			delete (std::vector<nyapc1__JobAtt * >*)p->ptr;
		else
			delete[] (std::vector<nyapc1__JobAtt * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTonyapc1__JobAtt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<nyapc1__JobAtt * >*)p)[len] = *(nyapc1__JobAtt **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new (std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void nyapc2__AttSuperClass::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void nyapc2__AttSuperClass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int nyapc2__AttSuperClass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_nyapc2__AttSuperClass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_nyapc2__AttSuperClass(struct soap *soap, const char *tag, int id, const nyapc2__AttSuperClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_nyapc2__AttSuperClass), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *nyapc2__AttSuperClass::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_nyapc2__AttSuperClass(soap, tag, this, type);
}

SOAP_FMAC3 nyapc2__AttSuperClass * SOAP_FMAC4 soap_in_nyapc2__AttSuperClass(struct soap *soap, const char *tag, nyapc2__AttSuperClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (nyapc2__AttSuperClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_nyapc2__AttSuperClass, sizeof(nyapc2__AttSuperClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_nyapc2__AttSuperClass)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (nyapc2__AttSuperClass *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (nyapc2__AttSuperClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_nyapc2__AttSuperClass, 0, sizeof(nyapc2__AttSuperClass), 0, soap_copy_nyapc2__AttSuperClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int nyapc2__AttSuperClass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_nyapc2__AttSuperClass);
	if (this->soap_out(soap, tag?tag:"nyapc2:AttSuperClass", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *nyapc2__AttSuperClass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_nyapc2__AttSuperClass(soap, this, tag, type);
}

SOAP_FMAC3 nyapc2__AttSuperClass * SOAP_FMAC4 soap_get_nyapc2__AttSuperClass(struct soap *soap, nyapc2__AttSuperClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_nyapc2__AttSuperClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 nyapc2__AttSuperClass * SOAP_FMAC2 soap_instantiate_nyapc2__AttSuperClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_nyapc2__AttSuperClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_nyapc2__AttSuperClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "nyapc1:Task"))
	{	cp->type = SOAP_TYPE_nyapc1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new (nyapc1__Task);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(nyapc1__Task);
			((nyapc1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new (nyapc1__Task[n]);
			if (size)
				*size = n * sizeof(nyapc1__Task);
			for (int i = 0; i < n; i++)
				((nyapc1__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (nyapc1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new (nyapc2__AttSuperClass);
		if (size)
			*size = sizeof(nyapc2__AttSuperClass);
		((nyapc2__AttSuperClass*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (nyapc2__AttSuperClass[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(nyapc2__AttSuperClass);
		for (int i = 0; i < n; i++)
			((nyapc2__AttSuperClass*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (nyapc2__AttSuperClass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_nyapc2__AttSuperClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying nyapc2__AttSuperClass %p -> %p\n", q, p));
	*(nyapc2__AttSuperClass*)p = *(nyapc2__AttSuperClass*)q;
}

void _nyapc1__getWraptypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__getWraptypeResponse::getWraptypeReturn);
	/* transient soap skipped */
}

void _nyapc1__getWraptypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__getWraptypeResponse::getWraptypeReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__getWraptypeResponse::getWraptypeReturn);
	/* transient soap skipped */
}

int _nyapc1__getWraptypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWraptypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWraptypeResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWraptypeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWraptypeResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getWraptypeReturn");
	if (soap_out_std__string(soap, "nyapc1:getWraptypeReturn", -1, &(a->_nyapc1__getWraptypeResponse::getWraptypeReturn), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWraptypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWraptypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWraptypeResponse * SOAP_FMAC4 soap_in__nyapc1__getWraptypeResponse(struct soap *soap, const char *tag, _nyapc1__getWraptypeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWraptypeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWraptypeResponse, sizeof(_nyapc1__getWraptypeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWraptypeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWraptypeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWraptypeReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWraptypeReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:getWraptypeReturn", &(a->_nyapc1__getWraptypeResponse::getWraptypeReturn), "xsd:string"))
				{	soap_flag_getWraptypeReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWraptypeReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWraptypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWraptypeResponse, 0, sizeof(_nyapc1__getWraptypeResponse), 0, soap_copy__nyapc1__getWraptypeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWraptypeReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWraptypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWraptypeResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWraptypeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWraptypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWraptypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWraptypeResponse * SOAP_FMAC4 soap_get__nyapc1__getWraptypeResponse(struct soap *soap, _nyapc1__getWraptypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWraptypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWraptypeResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWraptypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWraptypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWraptypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWraptypeResponse);
		if (size)
			*size = sizeof(_nyapc1__getWraptypeResponse);
		((_nyapc1__getWraptypeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWraptypeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWraptypeResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWraptypeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWraptypeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWraptypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWraptypeResponse %p -> %p\n", q, p));
	*(_nyapc1__getWraptypeResponse*)p = *(_nyapc1__getWraptypeResponse*)q;
}

void _nyapc1__getWraptype::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWraptype::id);
	/* transient soap skipped */
}

void _nyapc1__getWraptype::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWraptype::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWraptype(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWraptype(struct soap *soap, const char *tag, int id, const _nyapc1__getWraptype *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWraptype), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__getWraptype::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWraptype::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWraptype(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWraptype * SOAP_FMAC4 soap_in__nyapc1__getWraptype(struct soap *soap, const char *tag, _nyapc1__getWraptype *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWraptype *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWraptype, sizeof(_nyapc1__getWraptype), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWraptype)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWraptype *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__getWraptype::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWraptype *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWraptype, 0, sizeof(_nyapc1__getWraptype), 0, soap_copy__nyapc1__getWraptype);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWraptype::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWraptype);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWraptype", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWraptype::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWraptype(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWraptype * SOAP_FMAC4 soap_get__nyapc1__getWraptype(struct soap *soap, _nyapc1__getWraptype *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWraptype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWraptype * SOAP_FMAC2 soap_instantiate__nyapc1__getWraptype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWraptype(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWraptype, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWraptype);
		if (size)
			*size = sizeof(_nyapc1__getWraptype);
		((_nyapc1__getWraptype*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWraptype[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWraptype);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWraptype*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWraptype*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWraptype(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWraptype %p -> %p\n", q, p));
	*(_nyapc1__getWraptype*)p = *(_nyapc1__getWraptype*)q;
}

void _nyapc1__getWrapIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->_nyapc1__getWrapIdResponse::getWrapIdReturn);
	/* transient soap skipped */
}

void _nyapc1__getWrapIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->_nyapc1__getWrapIdResponse::getWrapIdReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapIdResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapIdResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getWrapIdReturn");
	if (soap_out_std__vectorTemplateOfint(soap, "nyapc1:getWrapIdReturn", -1, &(a->_nyapc1__getWrapIdResponse::getWrapIdReturn), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapIdResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapIdResponse(struct soap *soap, const char *tag, _nyapc1__getWrapIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapIdResponse, sizeof(_nyapc1__getWrapIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "nyapc1:getWrapIdReturn", &(a->_nyapc1__getWrapIdResponse::getWrapIdReturn), "xsd:int"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapIdReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapIdResponse, 0, sizeof(_nyapc1__getWrapIdResponse), 0, soap_copy__nyapc1__getWrapIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((a->_nyapc1__getWrapIdResponse::getWrapIdReturn.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapIdResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapIdResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapIdResponse(struct soap *soap, _nyapc1__getWrapIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapIdResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapIdResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapIdResponse);
		((_nyapc1__getWrapIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapIdResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapIdResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapIdResponse*)p = *(_nyapc1__getWrapIdResponse*)q;
}

void _nyapc1__getWrapId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapId::jid);
	/* transient soap skipped */
}

void _nyapc1__getWrapId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapId(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapId), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:jid", -1, &(a->_nyapc1__getWrapId::jid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapId(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapId * SOAP_FMAC4 soap_in__nyapc1__getWrapId(struct soap *soap, const char *tag, _nyapc1__getWrapId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapId, sizeof(_nyapc1__getWrapId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:jid", &(a->_nyapc1__getWrapId::jid), "xsd:int"))
				{	soap_flag_jid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapId, 0, sizeof(_nyapc1__getWrapId), 0, soap_copy__nyapc1__getWrapId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_jid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapId);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapId(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapId * SOAP_FMAC4 soap_get__nyapc1__getWrapId(struct soap *soap, _nyapc1__getWrapId *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapId * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapId);
		if (size)
			*size = sizeof(_nyapc1__getWrapId);
		((_nyapc1__getWrapId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapId);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapId %p -> %p\n", q, p));
	*(_nyapc1__getWrapId*)p = *(_nyapc1__getWrapId*)q;
}

void _nyapc1__getWrapInvalidTaskByJobIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getWrapInvalidTaskByJobIdResponse::getWrapInvalidTaskByJobIdReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getWrapInvalidTaskByJobIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getWrapInvalidTaskByJobIdResponse::getWrapInvalidTaskByJobIdReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapInvalidTaskByJobIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapInvalidTaskByJobIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse), type))
		return soap->error;
	if (a->getWrapInvalidTaskByJobIdReturn)
		soap_element_result(soap, "nyapc1:getWrapInvalidTaskByJobIdReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getWrapInvalidTaskByJobIdReturn", -1, &(a->_nyapc1__getWrapInvalidTaskByJobIdResponse::getWrapInvalidTaskByJobIdReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapInvalidTaskByJobIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobIdResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskByJobIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapInvalidTaskByJobIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse, sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapInvalidTaskByJobIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapInvalidTaskByJobIdReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapInvalidTaskByJobIdReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getWrapInvalidTaskByJobIdReturn", &(a->_nyapc1__getWrapInvalidTaskByJobIdResponse::getWrapInvalidTaskByJobIdReturn), "nyapc1:Task"))
				{	soap_flag_getWrapInvalidTaskByJobIdReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapInvalidTaskByJobIdReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapInvalidTaskByJobIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse, 0, sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse), 0, soap_copy__nyapc1__getWrapInvalidTaskByJobIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapInvalidTaskByJobIdReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapInvalidTaskByJobIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapInvalidTaskByJobIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapInvalidTaskByJobIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobIdResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapInvalidTaskByJobIdResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapInvalidTaskByJobIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskByJobIdResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse);
		((_nyapc1__getWrapInvalidTaskByJobIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskByJobIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapInvalidTaskByJobIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapInvalidTaskByJobIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapInvalidTaskByJobIdResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapInvalidTaskByJobIdResponse*)p = *(_nyapc1__getWrapInvalidTaskByJobIdResponse*)q;
}

void _nyapc1__getWrapInvalidTaskByJobId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::cid);
	soap_default_int(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::jid);
	soap_default_std__string(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::type);
	soap_default_int(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::num);
	/* transient soap skipped */
}

void _nyapc1__getWrapInvalidTaskByJobId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__getWrapInvalidTaskByJobId::type);
	/* transient soap skipped */
}

int _nyapc1__getWrapInvalidTaskByJobId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapInvalidTaskByJobId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapInvalidTaskByJobId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getWrapInvalidTaskByJobId::cid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:jid", -1, &(a->_nyapc1__getWrapInvalidTaskByJobId::jid), "xsd:int"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:type", -1, &(a->_nyapc1__getWrapInvalidTaskByJobId::type), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getWrapInvalidTaskByJobId::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapInvalidTaskByJobId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapInvalidTaskByJobId(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC4 soap_in__nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskByJobId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapInvalidTaskByJobId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId, sizeof(_nyapc1__getWrapInvalidTaskByJobId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapInvalidTaskByJobId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_jid1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getWrapInvalidTaskByJobId::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_jid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:jid", &(a->_nyapc1__getWrapInvalidTaskByJobId::jid), "xsd:int"))
				{	soap_flag_jid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:type", &(a->_nyapc1__getWrapInvalidTaskByJobId::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getWrapInvalidTaskByJobId::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapInvalidTaskByJobId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId, 0, sizeof(_nyapc1__getWrapInvalidTaskByJobId), 0, soap_copy__nyapc1__getWrapInvalidTaskByJobId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0 || soap_flag_jid1 > 0 || soap_flag_type1 > 0 || soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapInvalidTaskByJobId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapInvalidTaskByJobId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapInvalidTaskByJobId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapInvalidTaskByJobId(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC4 soap_get__nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobId *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapInvalidTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapInvalidTaskByJobId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskByJobId);
		if (size)
			*size = sizeof(_nyapc1__getWrapInvalidTaskByJobId);
		((_nyapc1__getWrapInvalidTaskByJobId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskByJobId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapInvalidTaskByJobId);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapInvalidTaskByJobId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapInvalidTaskByJobId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapInvalidTaskByJobId %p -> %p\n", q, p));
	*(_nyapc1__getWrapInvalidTaskByJobId*)p = *(_nyapc1__getWrapInvalidTaskByJobId*)q;
}

void _nyapc1__updateJobUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__updateJobUrlResponse::updateJobUrlReturn);
	/* transient soap skipped */
}

void _nyapc1__updateJobUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateJobUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateJobUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateJobUrlResponse(struct soap *soap, const char *tag, int id, const _nyapc1__updateJobUrlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateJobUrlResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:updateJobUrlReturn");
	if (soap_out_bool(soap, "nyapc1:updateJobUrlReturn", -1, &(a->_nyapc1__updateJobUrlResponse::updateJobUrlReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateJobUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateJobUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrlResponse * SOAP_FMAC4 soap_in__nyapc1__updateJobUrlResponse(struct soap *soap, const char *tag, _nyapc1__updateJobUrlResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateJobUrlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateJobUrlResponse, sizeof(_nyapc1__updateJobUrlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateJobUrlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateJobUrlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_updateJobUrlReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updateJobUrlReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:updateJobUrlReturn", &(a->_nyapc1__updateJobUrlResponse::updateJobUrlReturn), "xsd:boolean"))
				{	soap_flag_updateJobUrlReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:updateJobUrlReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateJobUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateJobUrlResponse, 0, sizeof(_nyapc1__updateJobUrlResponse), 0, soap_copy__nyapc1__updateJobUrlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_updateJobUrlReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateJobUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateJobUrlResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateJobUrlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateJobUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateJobUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrlResponse * SOAP_FMAC4 soap_get__nyapc1__updateJobUrlResponse(struct soap *soap, _nyapc1__updateJobUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateJobUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateJobUrlResponse * SOAP_FMAC2 soap_instantiate__nyapc1__updateJobUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateJobUrlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateJobUrlResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateJobUrlResponse);
		if (size)
			*size = sizeof(_nyapc1__updateJobUrlResponse);
		((_nyapc1__updateJobUrlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateJobUrlResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateJobUrlResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateJobUrlResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateJobUrlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateJobUrlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateJobUrlResponse %p -> %p\n", q, p));
	*(_nyapc1__updateJobUrlResponse*)p = *(_nyapc1__updateJobUrlResponse*)q;
}

void _nyapc1__updateJobUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__updateJobUrl::id);
	soap_default_std__string(soap, &this->_nyapc1__updateJobUrl::url);
	/* transient soap skipped */
}

void _nyapc1__updateJobUrl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__updateJobUrl::url, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__updateJobUrl::url);
	/* transient soap skipped */
}

int _nyapc1__updateJobUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateJobUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateJobUrl(struct soap *soap, const char *tag, int id, const _nyapc1__updateJobUrl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateJobUrl), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__updateJobUrl::id), "xsd:int"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:url", -1, &(a->_nyapc1__updateJobUrl::url), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateJobUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateJobUrl(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrl * SOAP_FMAC4 soap_in__nyapc1__updateJobUrl(struct soap *soap, const char *tag, _nyapc1__updateJobUrl *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateJobUrl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateJobUrl, sizeof(_nyapc1__updateJobUrl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateJobUrl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateJobUrl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__updateJobUrl::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:url", &(a->_nyapc1__updateJobUrl::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateJobUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateJobUrl, 0, sizeof(_nyapc1__updateJobUrl), 0, soap_copy__nyapc1__updateJobUrl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0 || soap_flag_url1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateJobUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateJobUrl);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateJobUrl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateJobUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateJobUrl(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrl * SOAP_FMAC4 soap_get__nyapc1__updateJobUrl(struct soap *soap, _nyapc1__updateJobUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateJobUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateJobUrl * SOAP_FMAC2 soap_instantiate__nyapc1__updateJobUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateJobUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateJobUrl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateJobUrl);
		if (size)
			*size = sizeof(_nyapc1__updateJobUrl);
		((_nyapc1__updateJobUrl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateJobUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateJobUrl);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateJobUrl*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateJobUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateJobUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateJobUrl %p -> %p\n", q, p));
	*(_nyapc1__updateJobUrl*)p = *(_nyapc1__updateJobUrl*)q;
}

void _nyapc1__delJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__delJobResponse::delJobReturn);
	/* transient soap skipped */
}

void _nyapc1__delJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__delJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__delJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__delJobResponse(struct soap *soap, const char *tag, int id, const _nyapc1__delJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__delJobResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:delJobReturn");
	if (soap_out_bool(soap, "nyapc1:delJobReturn", -1, &(a->_nyapc1__delJobResponse::delJobReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__delJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__delJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__delJobResponse * SOAP_FMAC4 soap_in__nyapc1__delJobResponse(struct soap *soap, const char *tag, _nyapc1__delJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__delJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__delJobResponse, sizeof(_nyapc1__delJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__delJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__delJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_delJobReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delJobReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:delJobReturn", &(a->_nyapc1__delJobResponse::delJobReturn), "xsd:boolean"))
				{	soap_flag_delJobReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:delJobReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__delJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__delJobResponse, 0, sizeof(_nyapc1__delJobResponse), 0, soap_copy__nyapc1__delJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_delJobReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__delJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__delJobResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:delJobResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__delJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__delJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__delJobResponse * SOAP_FMAC4 soap_get__nyapc1__delJobResponse(struct soap *soap, _nyapc1__delJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__delJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__delJobResponse * SOAP_FMAC2 soap_instantiate__nyapc1__delJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__delJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__delJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__delJobResponse);
		if (size)
			*size = sizeof(_nyapc1__delJobResponse);
		((_nyapc1__delJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__delJobResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__delJobResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__delJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__delJobResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__delJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__delJobResponse %p -> %p\n", q, p));
	*(_nyapc1__delJobResponse*)p = *(_nyapc1__delJobResponse*)q;
}

void _nyapc1__delJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__delJob::id);
	/* transient soap skipped */
}

void _nyapc1__delJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__delJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__delJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__delJob(struct soap *soap, const char *tag, int id, const _nyapc1__delJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__delJob), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__delJob::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__delJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__delJob(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__delJob * SOAP_FMAC4 soap_in__nyapc1__delJob(struct soap *soap, const char *tag, _nyapc1__delJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__delJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__delJob, sizeof(_nyapc1__delJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__delJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__delJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__delJob::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__delJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__delJob, 0, sizeof(_nyapc1__delJob), 0, soap_copy__nyapc1__delJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__delJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__delJob);
	if (this->soap_out(soap, tag?tag:"nyapc1:delJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__delJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__delJob(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__delJob * SOAP_FMAC4 soap_get__nyapc1__delJob(struct soap *soap, _nyapc1__delJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__delJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__delJob * SOAP_FMAC2 soap_instantiate__nyapc1__delJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__delJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__delJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__delJob);
		if (size)
			*size = sizeof(_nyapc1__delJob);
		((_nyapc1__delJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__delJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__delJob);
		for (int i = 0; i < n; i++)
			((_nyapc1__delJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__delJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__delJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__delJob %p -> %p\n", q, p));
	*(_nyapc1__delJob*)p = *(_nyapc1__delJob*)q;
}

void _nyapc1__getTaskByJobIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getTaskByJobIdResponse::getTaskByJobIdReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getTaskByJobIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getTaskByJobIdResponse::getTaskByJobIdReturn);
	/* transient soap skipped */
}

int _nyapc1__getTaskByJobIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTaskByJobIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTaskByJobIdResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getTaskByJobIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTaskByJobIdResponse), type))
		return soap->error;
	if (a->getTaskByJobIdReturn)
		soap_element_result(soap, "nyapc1:getTaskByJobIdReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getTaskByJobIdReturn", -1, &(a->_nyapc1__getTaskByJobIdResponse::getTaskByJobIdReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTaskByJobIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTaskByJobIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobIdResponse * SOAP_FMAC4 soap_in__nyapc1__getTaskByJobIdResponse(struct soap *soap, const char *tag, _nyapc1__getTaskByJobIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTaskByJobIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTaskByJobIdResponse, sizeof(_nyapc1__getTaskByJobIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTaskByJobIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTaskByJobIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTaskByJobIdReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTaskByJobIdReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getTaskByJobIdReturn", &(a->_nyapc1__getTaskByJobIdResponse::getTaskByJobIdReturn), "nyapc1:Task"))
				{	soap_flag_getTaskByJobIdReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getTaskByJobIdReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTaskByJobIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTaskByJobIdResponse, 0, sizeof(_nyapc1__getTaskByJobIdResponse), 0, soap_copy__nyapc1__getTaskByJobIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getTaskByJobIdReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTaskByJobIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTaskByJobIdResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTaskByJobIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTaskByJobIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTaskByJobIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobIdResponse * SOAP_FMAC4 soap_get__nyapc1__getTaskByJobIdResponse(struct soap *soap, _nyapc1__getTaskByJobIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTaskByJobIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTaskByJobIdResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getTaskByJobIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTaskByJobIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTaskByJobIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTaskByJobIdResponse);
		if (size)
			*size = sizeof(_nyapc1__getTaskByJobIdResponse);
		((_nyapc1__getTaskByJobIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTaskByJobIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTaskByJobIdResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTaskByJobIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTaskByJobIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTaskByJobIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTaskByJobIdResponse %p -> %p\n", q, p));
	*(_nyapc1__getTaskByJobIdResponse*)p = *(_nyapc1__getTaskByJobIdResponse*)q;
}

void _nyapc1__getTaskByJobId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getTaskByJobId::cid);
	soap_default_int(soap, &this->_nyapc1__getTaskByJobId::jid);
	soap_default_std__string(soap, &this->_nyapc1__getTaskByJobId::type);
	soap_default_int(soap, &this->_nyapc1__getTaskByJobId::num);
	/* transient soap skipped */
}

void _nyapc1__getTaskByJobId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__getTaskByJobId::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__getTaskByJobId::type);
	/* transient soap skipped */
}

int _nyapc1__getTaskByJobId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTaskByJobId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTaskByJobId(struct soap *soap, const char *tag, int id, const _nyapc1__getTaskByJobId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTaskByJobId), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getTaskByJobId::cid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:jid", -1, &(a->_nyapc1__getTaskByJobId::jid), "xsd:int"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:type", -1, &(a->_nyapc1__getTaskByJobId::type), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getTaskByJobId::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTaskByJobId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTaskByJobId(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobId * SOAP_FMAC4 soap_in__nyapc1__getTaskByJobId(struct soap *soap, const char *tag, _nyapc1__getTaskByJobId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTaskByJobId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTaskByJobId, sizeof(_nyapc1__getTaskByJobId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTaskByJobId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTaskByJobId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_jid1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getTaskByJobId::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_jid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:jid", &(a->_nyapc1__getTaskByJobId::jid), "xsd:int"))
				{	soap_flag_jid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:type", &(a->_nyapc1__getTaskByJobId::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getTaskByJobId::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTaskByJobId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTaskByJobId, 0, sizeof(_nyapc1__getTaskByJobId), 0, soap_copy__nyapc1__getTaskByJobId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0 || soap_flag_jid1 > 0 || soap_flag_type1 > 0 || soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTaskByJobId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTaskByJobId);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTaskByJobId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTaskByJobId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTaskByJobId(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobId * SOAP_FMAC4 soap_get__nyapc1__getTaskByJobId(struct soap *soap, _nyapc1__getTaskByJobId *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTaskByJobId * SOAP_FMAC2 soap_instantiate__nyapc1__getTaskByJobId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTaskByJobId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTaskByJobId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTaskByJobId);
		if (size)
			*size = sizeof(_nyapc1__getTaskByJobId);
		((_nyapc1__getTaskByJobId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTaskByJobId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTaskByJobId);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTaskByJobId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTaskByJobId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTaskByJobId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTaskByJobId %p -> %p\n", q, p));
	*(_nyapc1__getTaskByJobId*)p = *(_nyapc1__getTaskByJobId*)q;
}

void _nyapc1__takeTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__takeTaskResponse::takeTaskReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__takeTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__takeTaskResponse::takeTaskReturn);
	/* transient soap skipped */
}

int _nyapc1__takeTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__takeTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__takeTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__takeTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__takeTaskResponse), type))
		return soap->error;
	if (a->takeTaskReturn)
		soap_element_result(soap, "nyapc1:takeTaskReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:takeTaskReturn", -1, &(a->_nyapc1__takeTaskResponse::takeTaskReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__takeTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__takeTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__takeTaskResponse * SOAP_FMAC4 soap_in__nyapc1__takeTaskResponse(struct soap *soap, const char *tag, _nyapc1__takeTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__takeTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__takeTaskResponse, sizeof(_nyapc1__takeTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__takeTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__takeTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_takeTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_takeTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:takeTaskReturn", &(a->_nyapc1__takeTaskResponse::takeTaskReturn), "nyapc1:Task"))
				{	soap_flag_takeTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:takeTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__takeTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__takeTaskResponse, 0, sizeof(_nyapc1__takeTaskResponse), 0, soap_copy__nyapc1__takeTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_takeTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__takeTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__takeTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:takeTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__takeTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__takeTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__takeTaskResponse * SOAP_FMAC4 soap_get__nyapc1__takeTaskResponse(struct soap *soap, _nyapc1__takeTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__takeTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__takeTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__takeTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__takeTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__takeTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__takeTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__takeTaskResponse);
		((_nyapc1__takeTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__takeTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__takeTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__takeTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__takeTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__takeTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__takeTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__takeTaskResponse*)p = *(_nyapc1__takeTaskResponse*)q;
}

void _nyapc1__takeTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__takeTask::cid);
	/* transient soap skipped */
}

void _nyapc1__takeTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__takeTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__takeTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__takeTask(struct soap *soap, const char *tag, int id, const _nyapc1__takeTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__takeTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__takeTask::cid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__takeTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__takeTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__takeTask * SOAP_FMAC4 soap_in__nyapc1__takeTask(struct soap *soap, const char *tag, _nyapc1__takeTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__takeTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__takeTask, sizeof(_nyapc1__takeTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__takeTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__takeTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__takeTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__takeTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__takeTask, 0, sizeof(_nyapc1__takeTask), 0, soap_copy__nyapc1__takeTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__takeTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__takeTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:takeTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__takeTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__takeTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__takeTask * SOAP_FMAC4 soap_get__nyapc1__takeTask(struct soap *soap, _nyapc1__takeTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__takeTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__takeTask * SOAP_FMAC2 soap_instantiate__nyapc1__takeTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__takeTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__takeTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__takeTask);
		if (size)
			*size = sizeof(_nyapc1__takeTask);
		((_nyapc1__takeTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__takeTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__takeTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__takeTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__takeTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__takeTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__takeTask %p -> %p\n", q, p));
	*(_nyapc1__takeTask*)p = *(_nyapc1__takeTask*)q;
}

void _nyapc1__getWrapTaskQueueResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getWrapTaskQueueResponse::getWrapTaskQueueReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getWrapTaskQueueResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getWrapTaskQueueResponse::getWrapTaskQueueReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapTaskQueueResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapTaskQueueResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapTaskQueueResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapTaskQueueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse), type))
		return soap->error;
	if (a->getWrapTaskQueueReturn)
		soap_element_result(soap, "nyapc1:getWrapTaskQueueReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getWrapTaskQueueReturn", -1, &(a->_nyapc1__getWrapTaskQueueResponse::getWrapTaskQueueReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapTaskQueueResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapTaskQueueResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueueResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapTaskQueueResponse(struct soap *soap, const char *tag, _nyapc1__getWrapTaskQueueResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapTaskQueueResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse, sizeof(_nyapc1__getWrapTaskQueueResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapTaskQueueResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapTaskQueueResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapTaskQueueReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapTaskQueueReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getWrapTaskQueueReturn", &(a->_nyapc1__getWrapTaskQueueResponse::getWrapTaskQueueReturn), "nyapc1:Task"))
				{	soap_flag_getWrapTaskQueueReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapTaskQueueReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapTaskQueueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse, 0, sizeof(_nyapc1__getWrapTaskQueueResponse), 0, soap_copy__nyapc1__getWrapTaskQueueResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapTaskQueueReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapTaskQueueResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapTaskQueueResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapTaskQueueResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapTaskQueueResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueueResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapTaskQueueResponse(struct soap *soap, _nyapc1__getWrapTaskQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapTaskQueueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapTaskQueueResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapTaskQueueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapTaskQueueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskQueueResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapTaskQueueResponse);
		((_nyapc1__getWrapTaskQueueResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskQueueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapTaskQueueResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapTaskQueueResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapTaskQueueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapTaskQueueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapTaskQueueResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapTaskQueueResponse*)p = *(_nyapc1__getWrapTaskQueueResponse*)q;
}

void _nyapc1__getWrapTaskQueue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapTaskQueue::num);
	/* transient soap skipped */
}

void _nyapc1__getWrapTaskQueue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapTaskQueue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapTaskQueue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapTaskQueue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapTaskQueue), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getWrapTaskQueue::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapTaskQueue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapTaskQueue(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueue * SOAP_FMAC4 soap_in__nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, _nyapc1__getWrapTaskQueue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapTaskQueue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapTaskQueue, sizeof(_nyapc1__getWrapTaskQueue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapTaskQueue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapTaskQueue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getWrapTaskQueue::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapTaskQueue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapTaskQueue, 0, sizeof(_nyapc1__getWrapTaskQueue), 0, soap_copy__nyapc1__getWrapTaskQueue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapTaskQueue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapTaskQueue);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapTaskQueue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapTaskQueue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapTaskQueue(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueue * SOAP_FMAC4 soap_get__nyapc1__getWrapTaskQueue(struct soap *soap, _nyapc1__getWrapTaskQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapTaskQueue * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapTaskQueue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapTaskQueue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapTaskQueue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskQueue);
		if (size)
			*size = sizeof(_nyapc1__getWrapTaskQueue);
		((_nyapc1__getWrapTaskQueue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskQueue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapTaskQueue);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapTaskQueue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapTaskQueue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapTaskQueue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapTaskQueue %p -> %p\n", q, p));
	*(_nyapc1__getWrapTaskQueue*)p = *(_nyapc1__getWrapTaskQueue*)q;
}

void _nyapc1__getTaskQueueResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getTaskQueueResponse::getTaskQueueReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getTaskQueueResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getTaskQueueResponse::getTaskQueueReturn);
	/* transient soap skipped */
}

int _nyapc1__getTaskQueueResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTaskQueueResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTaskQueueResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getTaskQueueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTaskQueueResponse), type))
		return soap->error;
	if (a->getTaskQueueReturn)
		soap_element_result(soap, "nyapc1:getTaskQueueReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getTaskQueueReturn", -1, &(a->_nyapc1__getTaskQueueResponse::getTaskQueueReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTaskQueueResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTaskQueueResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueueResponse * SOAP_FMAC4 soap_in__nyapc1__getTaskQueueResponse(struct soap *soap, const char *tag, _nyapc1__getTaskQueueResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTaskQueueResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTaskQueueResponse, sizeof(_nyapc1__getTaskQueueResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTaskQueueResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTaskQueueResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTaskQueueReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTaskQueueReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getTaskQueueReturn", &(a->_nyapc1__getTaskQueueResponse::getTaskQueueReturn), "nyapc1:Task"))
				{	soap_flag_getTaskQueueReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getTaskQueueReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTaskQueueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTaskQueueResponse, 0, sizeof(_nyapc1__getTaskQueueResponse), 0, soap_copy__nyapc1__getTaskQueueResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getTaskQueueReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTaskQueueResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTaskQueueResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTaskQueueResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTaskQueueResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTaskQueueResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueueResponse * SOAP_FMAC4 soap_get__nyapc1__getTaskQueueResponse(struct soap *soap, _nyapc1__getTaskQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTaskQueueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTaskQueueResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getTaskQueueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTaskQueueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTaskQueueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTaskQueueResponse);
		if (size)
			*size = sizeof(_nyapc1__getTaskQueueResponse);
		((_nyapc1__getTaskQueueResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTaskQueueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTaskQueueResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTaskQueueResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTaskQueueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTaskQueueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTaskQueueResponse %p -> %p\n", q, p));
	*(_nyapc1__getTaskQueueResponse*)p = *(_nyapc1__getTaskQueueResponse*)q;
}

void _nyapc1__getTaskQueue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getTaskQueue::num);
	/* transient soap skipped */
}

void _nyapc1__getTaskQueue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getTaskQueue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTaskQueue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTaskQueue(struct soap *soap, const char *tag, int id, const _nyapc1__getTaskQueue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTaskQueue), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getTaskQueue::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTaskQueue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTaskQueue(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueue * SOAP_FMAC4 soap_in__nyapc1__getTaskQueue(struct soap *soap, const char *tag, _nyapc1__getTaskQueue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTaskQueue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTaskQueue, sizeof(_nyapc1__getTaskQueue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTaskQueue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTaskQueue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getTaskQueue::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTaskQueue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTaskQueue, 0, sizeof(_nyapc1__getTaskQueue), 0, soap_copy__nyapc1__getTaskQueue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTaskQueue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTaskQueue);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTaskQueue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTaskQueue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTaskQueue(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueue * SOAP_FMAC4 soap_get__nyapc1__getTaskQueue(struct soap *soap, _nyapc1__getTaskQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTaskQueue * SOAP_FMAC2 soap_instantiate__nyapc1__getTaskQueue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTaskQueue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTaskQueue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTaskQueue);
		if (size)
			*size = sizeof(_nyapc1__getTaskQueue);
		((_nyapc1__getTaskQueue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTaskQueue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTaskQueue);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTaskQueue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTaskQueue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTaskQueue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTaskQueue %p -> %p\n", q, p));
	*(_nyapc1__getTaskQueue*)p = *(_nyapc1__getTaskQueue*)q;
}

void _nyapc1__updateWrapGenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__updateWrapGenResponse::updateWrapGenReturn);
	/* transient soap skipped */
}

void _nyapc1__updateWrapGenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateWrapGenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapGenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapGenResponse(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapGenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapGenResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:updateWrapGenReturn");
	if (soap_out_bool(soap, "nyapc1:updateWrapGenReturn", -1, &(a->_nyapc1__updateWrapGenResponse::updateWrapGenReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapGenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapGenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGenResponse * SOAP_FMAC4 soap_in__nyapc1__updateWrapGenResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapGenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapGenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapGenResponse, sizeof(_nyapc1__updateWrapGenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapGenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapGenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_updateWrapGenReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updateWrapGenReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:updateWrapGenReturn", &(a->_nyapc1__updateWrapGenResponse::updateWrapGenReturn), "xsd:boolean"))
				{	soap_flag_updateWrapGenReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:updateWrapGenReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapGenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapGenResponse, 0, sizeof(_nyapc1__updateWrapGenResponse), 0, soap_copy__nyapc1__updateWrapGenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_updateWrapGenReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapGenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapGenResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapGenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapGenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapGenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGenResponse * SOAP_FMAC4 soap_get__nyapc1__updateWrapGenResponse(struct soap *soap, _nyapc1__updateWrapGenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapGenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapGenResponse * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapGenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapGenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapGenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapGenResponse);
		if (size)
			*size = sizeof(_nyapc1__updateWrapGenResponse);
		((_nyapc1__updateWrapGenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapGenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapGenResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapGenResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapGenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapGenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapGenResponse %p -> %p\n", q, p));
	*(_nyapc1__updateWrapGenResponse*)p = *(_nyapc1__updateWrapGenResponse*)q;
}

void _nyapc1__updateWrapGen::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__updateWrapGen::wrapgen);
	soap_default_int(soap, &this->_nyapc1__updateWrapGen::id);
	/* transient soap skipped */
}

void _nyapc1__updateWrapGen::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__updateWrapGen::wrapgen, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__updateWrapGen::wrapgen);
	/* transient soap skipped */
}

int _nyapc1__updateWrapGen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapGen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapGen(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapGen *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapGen), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:wrapgen", -1, &(a->_nyapc1__updateWrapGen::wrapgen), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__updateWrapGen::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapGen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapGen(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGen * SOAP_FMAC4 soap_in__nyapc1__updateWrapGen(struct soap *soap, const char *tag, _nyapc1__updateWrapGen *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapGen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapGen, sizeof(_nyapc1__updateWrapGen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapGen)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapGen *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_wrapgen1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wrapgen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:wrapgen", &(a->_nyapc1__updateWrapGen::wrapgen), "xsd:string"))
				{	soap_flag_wrapgen1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__updateWrapGen::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapGen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapGen, 0, sizeof(_nyapc1__updateWrapGen), 0, soap_copy__nyapc1__updateWrapGen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_wrapgen1 > 0 || soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapGen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapGen);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapGen", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapGen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapGen(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGen * SOAP_FMAC4 soap_get__nyapc1__updateWrapGen(struct soap *soap, _nyapc1__updateWrapGen *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapGen * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapGen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapGen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapGen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapGen);
		if (size)
			*size = sizeof(_nyapc1__updateWrapGen);
		((_nyapc1__updateWrapGen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapGen[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapGen);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapGen*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapGen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapGen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapGen %p -> %p\n", q, p));
	*(_nyapc1__updateWrapGen*)p = *(_nyapc1__updateWrapGen*)q;
}

void _nyapc1__getWrapGenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__getWrapGenResponse::getWrapGenReturn);
	/* transient soap skipped */
}

void _nyapc1__getWrapGenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__getWrapGenResponse::getWrapGenReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__getWrapGenResponse::getWrapGenReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapGenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapGenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapGenResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapGenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapGenResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getWrapGenReturn");
	if (soap_out_std__string(soap, "nyapc1:getWrapGenReturn", -1, &(a->_nyapc1__getWrapGenResponse::getWrapGenReturn), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapGenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapGenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapGenResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapGenResponse(struct soap *soap, const char *tag, _nyapc1__getWrapGenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapGenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapGenResponse, sizeof(_nyapc1__getWrapGenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapGenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapGenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapGenReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapGenReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:getWrapGenReturn", &(a->_nyapc1__getWrapGenResponse::getWrapGenReturn), "xsd:string"))
				{	soap_flag_getWrapGenReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapGenReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapGenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapGenResponse, 0, sizeof(_nyapc1__getWrapGenResponse), 0, soap_copy__nyapc1__getWrapGenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapGenReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapGenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapGenResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapGenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapGenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapGenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapGenResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapGenResponse(struct soap *soap, _nyapc1__getWrapGenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapGenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapGenResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapGenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapGenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapGenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapGenResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapGenResponse);
		((_nyapc1__getWrapGenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapGenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapGenResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapGenResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapGenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapGenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapGenResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapGenResponse*)p = *(_nyapc1__getWrapGenResponse*)q;
}

void _nyapc1__getWrapGen::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapGen::id);
	/* transient soap skipped */
}

void _nyapc1__getWrapGen::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapGen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapGen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapGen(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapGen *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapGen), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__getWrapGen::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapGen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapGen(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapGen * SOAP_FMAC4 soap_in__nyapc1__getWrapGen(struct soap *soap, const char *tag, _nyapc1__getWrapGen *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapGen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapGen, sizeof(_nyapc1__getWrapGen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapGen)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapGen *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__getWrapGen::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapGen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapGen, 0, sizeof(_nyapc1__getWrapGen), 0, soap_copy__nyapc1__getWrapGen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapGen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapGen);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapGen", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapGen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapGen(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapGen * SOAP_FMAC4 soap_get__nyapc1__getWrapGen(struct soap *soap, _nyapc1__getWrapGen *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapGen * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapGen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapGen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapGen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapGen);
		if (size)
			*size = sizeof(_nyapc1__getWrapGen);
		((_nyapc1__getWrapGen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapGen[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapGen);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapGen*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapGen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapGen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapGen %p -> %p\n", q, p));
	*(_nyapc1__getWrapGen*)p = *(_nyapc1__getWrapGen*)q;
}

void _nyapc1__getJobsWrapStatInvalidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, &this->_nyapc1__getJobsWrapStatInvalidResponse::getJobsWrapStatInvalidReturn);
	/* transient soap skipped */
}

void _nyapc1__getJobsWrapStatInvalidResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, &this->_nyapc1__getJobsWrapStatInvalidResponse::getJobsWrapStatInvalidReturn);
	/* transient soap skipped */
}

int _nyapc1__getJobsWrapStatInvalidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobsWrapStatInvalidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getJobsWrapStatInvalidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getJobsWrapStatInvalidReturn");
	if (soap_out_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, "nyapc1:getJobsWrapStatInvalidReturn", -1, &(a->_nyapc1__getJobsWrapStatInvalidResponse::getJobsWrapStatInvalidReturn), "nyapc1:JobAtt"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobsWrapStatInvalidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobsWrapStatInvalidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalidResponse * SOAP_FMAC4 soap_in__nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, const char *tag, _nyapc1__getJobsWrapStatInvalidResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobsWrapStatInvalidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse, sizeof(_nyapc1__getJobsWrapStatInvalidResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobsWrapStatInvalidResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, "nyapc1:getJobsWrapStatInvalidReturn", &(a->_nyapc1__getJobsWrapStatInvalidResponse::getJobsWrapStatInvalidReturn), "nyapc1:JobAtt"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getJobsWrapStatInvalidReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobsWrapStatInvalidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse, 0, sizeof(_nyapc1__getJobsWrapStatInvalidResponse), 0, soap_copy__nyapc1__getJobsWrapStatInvalidResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((a->_nyapc1__getJobsWrapStatInvalidResponse::getJobsWrapStatInvalidReturn.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getJobsWrapStatInvalidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobsWrapStatInvalidResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobsWrapStatInvalidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobsWrapStatInvalidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalidResponse * SOAP_FMAC4 soap_get__nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, _nyapc1__getJobsWrapStatInvalidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobsWrapStatInvalidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobsWrapStatInvalidResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobsWrapStatInvalidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobsWrapStatInvalidResponse);
		if (size)
			*size = sizeof(_nyapc1__getJobsWrapStatInvalidResponse);
		((_nyapc1__getJobsWrapStatInvalidResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobsWrapStatInvalidResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobsWrapStatInvalidResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobsWrapStatInvalidResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobsWrapStatInvalidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobsWrapStatInvalidResponse %p -> %p\n", q, p));
	*(_nyapc1__getJobsWrapStatInvalidResponse*)p = *(_nyapc1__getJobsWrapStatInvalidResponse*)q;
}

void _nyapc1__getJobsWrapStatInvalid::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _nyapc1__getJobsWrapStatInvalid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getJobsWrapStatInvalid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobsWrapStatInvalid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, int id, const _nyapc1__getJobsWrapStatInvalid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobsWrapStatInvalid::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobsWrapStatInvalid(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalid * SOAP_FMAC4 soap_in__nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, _nyapc1__getJobsWrapStatInvalid *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobsWrapStatInvalid *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid, sizeof(_nyapc1__getJobsWrapStatInvalid), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobsWrapStatInvalid)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobsWrapStatInvalid *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobsWrapStatInvalid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid, 0, sizeof(_nyapc1__getJobsWrapStatInvalid), 0, soap_copy__nyapc1__getJobsWrapStatInvalid);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _nyapc1__getJobsWrapStatInvalid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobsWrapStatInvalid", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobsWrapStatInvalid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobsWrapStatInvalid(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalid * SOAP_FMAC4 soap_get__nyapc1__getJobsWrapStatInvalid(struct soap *soap, _nyapc1__getJobsWrapStatInvalid *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobsWrapStatInvalid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobsWrapStatInvalid * SOAP_FMAC2 soap_instantiate__nyapc1__getJobsWrapStatInvalid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobsWrapStatInvalid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobsWrapStatInvalid);
		if (size)
			*size = sizeof(_nyapc1__getJobsWrapStatInvalid);
		((_nyapc1__getJobsWrapStatInvalid*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobsWrapStatInvalid[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobsWrapStatInvalid);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobsWrapStatInvalid*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobsWrapStatInvalid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobsWrapStatInvalid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobsWrapStatInvalid %p -> %p\n", q, p));
	*(_nyapc1__getJobsWrapStatInvalid*)p = *(_nyapc1__getJobsWrapStatInvalid*)q;
}

void _nyapc1__getJobsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, &this->_nyapc1__getJobsResponse::getJobsReturn);
	/* transient soap skipped */
}

void _nyapc1__getJobsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, &this->_nyapc1__getJobsResponse::getJobsReturn);
	/* transient soap skipped */
}

int _nyapc1__getJobsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobsResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getJobsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getJobsReturn");
	if (soap_out_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, "nyapc1:getJobsReturn", -1, &(a->_nyapc1__getJobsResponse::getJobsReturn), "nyapc1:JobAtt"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobsResponse * SOAP_FMAC4 soap_in__nyapc1__getJobsResponse(struct soap *soap, const char *tag, _nyapc1__getJobsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobsResponse, sizeof(_nyapc1__getJobsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, "nyapc1:getJobsReturn", &(a->_nyapc1__getJobsResponse::getJobsReturn), "nyapc1:JobAtt"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getJobsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobsResponse, 0, sizeof(_nyapc1__getJobsResponse), 0, soap_copy__nyapc1__getJobsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((a->_nyapc1__getJobsResponse::getJobsReturn.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getJobsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobsResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobsResponse * SOAP_FMAC4 soap_get__nyapc1__getJobsResponse(struct soap *soap, _nyapc1__getJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobsResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getJobsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobsResponse);
		if (size)
			*size = sizeof(_nyapc1__getJobsResponse);
		((_nyapc1__getJobsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobsResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobsResponse %p -> %p\n", q, p));
	*(_nyapc1__getJobsResponse*)p = *(_nyapc1__getJobsResponse*)q;
}

void _nyapc1__getJobs::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _nyapc1__getJobs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getJobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobs(struct soap *soap, const char *tag, int id, const _nyapc1__getJobs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobs), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobs(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobs * SOAP_FMAC4 soap_in__nyapc1__getJobs(struct soap *soap, const char *tag, _nyapc1__getJobs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobs, sizeof(_nyapc1__getJobs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobs *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobs, 0, sizeof(_nyapc1__getJobs), 0, soap_copy__nyapc1__getJobs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _nyapc1__getJobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobs);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobs(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobs * SOAP_FMAC4 soap_get__nyapc1__getJobs(struct soap *soap, _nyapc1__getJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobs * SOAP_FMAC2 soap_instantiate__nyapc1__getJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobs);
		if (size)
			*size = sizeof(_nyapc1__getJobs);
		((_nyapc1__getJobs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobs);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobs*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobs %p -> %p\n", q, p));
	*(_nyapc1__getJobs*)p = *(_nyapc1__getJobs*)q;
}

void _nyapc1__getJobIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->_nyapc1__getJobIDResponse::getJobIDReturn);
	/* transient soap skipped */
}

void _nyapc1__getJobIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->_nyapc1__getJobIDResponse::getJobIDReturn);
	/* transient soap skipped */
}

int _nyapc1__getJobIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobIDResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getJobIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobIDResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getJobIDReturn");
	if (soap_out_std__vectorTemplateOfint(soap, "nyapc1:getJobIDReturn", -1, &(a->_nyapc1__getJobIDResponse::getJobIDReturn), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobIDResponse * SOAP_FMAC4 soap_in__nyapc1__getJobIDResponse(struct soap *soap, const char *tag, _nyapc1__getJobIDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobIDResponse, sizeof(_nyapc1__getJobIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "nyapc1:getJobIDReturn", &(a->_nyapc1__getJobIDResponse::getJobIDReturn), "xsd:int"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getJobIDReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobIDResponse, 0, sizeof(_nyapc1__getJobIDResponse), 0, soap_copy__nyapc1__getJobIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((a->_nyapc1__getJobIDResponse::getJobIDReturn.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getJobIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobIDResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobIDResponse * SOAP_FMAC4 soap_get__nyapc1__getJobIDResponse(struct soap *soap, _nyapc1__getJobIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobIDResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getJobIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobIDResponse);
		if (size)
			*size = sizeof(_nyapc1__getJobIDResponse);
		((_nyapc1__getJobIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobIDResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobIDResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobIDResponse %p -> %p\n", q, p));
	*(_nyapc1__getJobIDResponse*)p = *(_nyapc1__getJobIDResponse*)q;
}

void _nyapc1__getJobID::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _nyapc1__getJobID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getJobID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobID(struct soap *soap, const char *tag, int id, const _nyapc1__getJobID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobID), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobID(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobID * SOAP_FMAC4 soap_in__nyapc1__getJobID(struct soap *soap, const char *tag, _nyapc1__getJobID *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobID, sizeof(_nyapc1__getJobID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobID *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobID, 0, sizeof(_nyapc1__getJobID), 0, soap_copy__nyapc1__getJobID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _nyapc1__getJobID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobID);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobID(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobID * SOAP_FMAC4 soap_get__nyapc1__getJobID(struct soap *soap, _nyapc1__getJobID *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobID * SOAP_FMAC2 soap_instantiate__nyapc1__getJobID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobID);
		if (size)
			*size = sizeof(_nyapc1__getJobID);
		((_nyapc1__getJobID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobID);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobID*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobID %p -> %p\n", q, p));
	*(_nyapc1__getJobID*)p = *(_nyapc1__getJobID*)q;
}

void _nyapc1__putResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__putResultResponse::putResultReturn);
	/* transient soap skipped */
}

void _nyapc1__putResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__putResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__putResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__putResultResponse(struct soap *soap, const char *tag, int id, const _nyapc1__putResultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__putResultResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:putResultReturn");
	if (soap_out_bool(soap, "nyapc1:putResultReturn", -1, &(a->_nyapc1__putResultResponse::putResultReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__putResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__putResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__putResultResponse * SOAP_FMAC4 soap_in__nyapc1__putResultResponse(struct soap *soap, const char *tag, _nyapc1__putResultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__putResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__putResultResponse, sizeof(_nyapc1__putResultResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__putResultResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__putResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_putResultReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_putResultReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:putResultReturn", &(a->_nyapc1__putResultResponse::putResultReturn), "xsd:boolean"))
				{	soap_flag_putResultReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:putResultReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__putResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__putResultResponse, 0, sizeof(_nyapc1__putResultResponse), 0, soap_copy__nyapc1__putResultResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_putResultReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__putResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__putResultResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:putResultResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__putResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__putResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__putResultResponse * SOAP_FMAC4 soap_get__nyapc1__putResultResponse(struct soap *soap, _nyapc1__putResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__putResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__putResultResponse * SOAP_FMAC2 soap_instantiate__nyapc1__putResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__putResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__putResultResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__putResultResponse);
		if (size)
			*size = sizeof(_nyapc1__putResultResponse);
		((_nyapc1__putResultResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__putResultResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__putResultResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__putResultResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__putResultResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__putResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__putResultResponse %p -> %p\n", q, p));
	*(_nyapc1__putResultResponse*)p = *(_nyapc1__putResultResponse*)q;
}

void _nyapc1__putResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__putResult::res);
	soap_default_int(soap, &this->_nyapc1__putResult::cid);
	/* transient soap skipped */
}

void _nyapc1__putResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__putResult::res, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__putResult::res);
	/* transient soap skipped */
}

int _nyapc1__putResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__putResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__putResult(struct soap *soap, const char *tag, int id, const _nyapc1__putResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__putResult), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:res", -1, &(a->_nyapc1__putResult::res), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__putResult::cid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__putResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__putResult(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__putResult * SOAP_FMAC4 soap_in__nyapc1__putResult(struct soap *soap, const char *tag, _nyapc1__putResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__putResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__putResult, sizeof(_nyapc1__putResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__putResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__putResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_res1 = 1;
	size_t soap_flag_cid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_res1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:res", &(a->_nyapc1__putResult::res), "xsd:string"))
				{	soap_flag_res1--;
					continue;
				}
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__putResult::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__putResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__putResult, 0, sizeof(_nyapc1__putResult), 0, soap_copy__nyapc1__putResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_res1 > 0 || soap_flag_cid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__putResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__putResult);
	if (this->soap_out(soap, tag?tag:"nyapc1:putResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__putResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__putResult(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__putResult * SOAP_FMAC4 soap_get__nyapc1__putResult(struct soap *soap, _nyapc1__putResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__putResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__putResult * SOAP_FMAC2 soap_instantiate__nyapc1__putResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__putResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__putResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__putResult);
		if (size)
			*size = sizeof(_nyapc1__putResult);
		((_nyapc1__putResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__putResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__putResult);
		for (int i = 0; i < n; i++)
			((_nyapc1__putResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__putResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__putResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__putResult %p -> %p\n", q, p));
	*(_nyapc1__putResult*)p = *(_nyapc1__putResult*)q;
}

void _nyapc1__getStatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getStatResponse::getStatReturn);
	/* transient soap skipped */
}

void _nyapc1__getStatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getStatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getStatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getStatResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getStatResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getStatResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getStatReturn");
	if (soap_out_int(soap, "nyapc1:getStatReturn", -1, &(a->_nyapc1__getStatResponse::getStatReturn), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getStatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getStatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getStatResponse * SOAP_FMAC4 soap_in__nyapc1__getStatResponse(struct soap *soap, const char *tag, _nyapc1__getStatResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getStatResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getStatResponse, sizeof(_nyapc1__getStatResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getStatResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getStatResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getStatReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getStatReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:getStatReturn", &(a->_nyapc1__getStatResponse::getStatReturn), "xsd:int"))
				{	soap_flag_getStatReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getStatReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getStatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getStatResponse, 0, sizeof(_nyapc1__getStatResponse), 0, soap_copy__nyapc1__getStatResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getStatReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getStatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getStatResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getStatResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getStatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getStatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getStatResponse * SOAP_FMAC4 soap_get__nyapc1__getStatResponse(struct soap *soap, _nyapc1__getStatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getStatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getStatResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getStatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getStatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getStatResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getStatResponse);
		if (size)
			*size = sizeof(_nyapc1__getStatResponse);
		((_nyapc1__getStatResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getStatResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getStatResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getStatResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getStatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getStatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getStatResponse %p -> %p\n", q, p));
	*(_nyapc1__getStatResponse*)p = *(_nyapc1__getStatResponse*)q;
}

void _nyapc1__getStat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getStat::cid);
	/* transient soap skipped */
}

void _nyapc1__getStat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getStat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getStat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getStat(struct soap *soap, const char *tag, int id, const _nyapc1__getStat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getStat), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getStat::cid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getStat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getStat(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getStat * SOAP_FMAC4 soap_in__nyapc1__getStat(struct soap *soap, const char *tag, _nyapc1__getStat *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getStat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getStat, sizeof(_nyapc1__getStat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getStat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getStat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getStat::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getStat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getStat, 0, sizeof(_nyapc1__getStat), 0, soap_copy__nyapc1__getStat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getStat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getStat);
	if (this->soap_out(soap, tag?tag:"nyapc1:getStat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getStat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getStat(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getStat * SOAP_FMAC4 soap_get__nyapc1__getStat(struct soap *soap, _nyapc1__getStat *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getStat * SOAP_FMAC2 soap_instantiate__nyapc1__getStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getStat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getStat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getStat);
		if (size)
			*size = sizeof(_nyapc1__getStat);
		((_nyapc1__getStat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getStat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getStat);
		for (int i = 0; i < n; i++)
			((_nyapc1__getStat*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getStat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getStat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getStat %p -> %p\n", q, p));
	*(_nyapc1__getStat*)p = *(_nyapc1__getStat*)q;
}

void _nyapc1__updateWrapperCheckOkResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__updateWrapperCheckOkResponse::updateWrapperCheckOkReturn);
	/* transient soap skipped */
}

void _nyapc1__updateWrapperCheckOkResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateWrapperCheckOkResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapperCheckOkResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapperCheckOkResponse(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapperCheckOkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:updateWrapperCheckOkReturn");
	if (soap_out_bool(soap, "nyapc1:updateWrapperCheckOkReturn", -1, &(a->_nyapc1__updateWrapperCheckOkResponse::updateWrapperCheckOkReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapperCheckOkResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapperCheckOkResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOkResponse * SOAP_FMAC4 soap_in__nyapc1__updateWrapperCheckOkResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapperCheckOkResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapperCheckOkResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse, sizeof(_nyapc1__updateWrapperCheckOkResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapperCheckOkResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_updateWrapperCheckOkReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updateWrapperCheckOkReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:updateWrapperCheckOkReturn", &(a->_nyapc1__updateWrapperCheckOkResponse::updateWrapperCheckOkReturn), "xsd:boolean"))
				{	soap_flag_updateWrapperCheckOkReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:updateWrapperCheckOkReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapperCheckOkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse, 0, sizeof(_nyapc1__updateWrapperCheckOkResponse), 0, soap_copy__nyapc1__updateWrapperCheckOkResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_updateWrapperCheckOkReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapperCheckOkResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapperCheckOkResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapperCheckOkResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapperCheckOkResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOkResponse * SOAP_FMAC4 soap_get__nyapc1__updateWrapperCheckOkResponse(struct soap *soap, _nyapc1__updateWrapperCheckOkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapperCheckOkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapperCheckOkResponse * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapperCheckOkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapperCheckOkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperCheckOkResponse);
		if (size)
			*size = sizeof(_nyapc1__updateWrapperCheckOkResponse);
		((_nyapc1__updateWrapperCheckOkResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperCheckOkResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapperCheckOkResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapperCheckOkResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapperCheckOkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapperCheckOkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapperCheckOkResponse %p -> %p\n", q, p));
	*(_nyapc1__updateWrapperCheckOkResponse*)p = *(_nyapc1__updateWrapperCheckOkResponse*)q;
}

void _nyapc1__updateWrapperCheckOk::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__updateWrapperCheckOk::wrap);
	soap_default_int(soap, &this->_nyapc1__updateWrapperCheckOk::wrapId);
	/* transient soap skipped */
}

void _nyapc1__updateWrapperCheckOk::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__updateWrapperCheckOk::wrap, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__updateWrapperCheckOk::wrap);
	/* transient soap skipped */
}

int _nyapc1__updateWrapperCheckOk::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapperCheckOk(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapperCheckOk *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapperCheckOk), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:wrap", -1, &(a->_nyapc1__updateWrapperCheckOk::wrap), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:wrapId", -1, &(a->_nyapc1__updateWrapperCheckOk::wrapId), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapperCheckOk::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapperCheckOk(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOk * SOAP_FMAC4 soap_in__nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, _nyapc1__updateWrapperCheckOk *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapperCheckOk *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapperCheckOk, sizeof(_nyapc1__updateWrapperCheckOk), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapperCheckOk)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapperCheckOk *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_wrap1 = 1;
	size_t soap_flag_wrapId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wrap1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:wrap", &(a->_nyapc1__updateWrapperCheckOk::wrap), "xsd:string"))
				{	soap_flag_wrap1--;
					continue;
				}
			if (soap_flag_wrapId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:wrapId", &(a->_nyapc1__updateWrapperCheckOk::wrapId), "xsd:int"))
				{	soap_flag_wrapId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapperCheckOk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapperCheckOk, 0, sizeof(_nyapc1__updateWrapperCheckOk), 0, soap_copy__nyapc1__updateWrapperCheckOk);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_wrap1 > 0 || soap_flag_wrapId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapperCheckOk::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapperCheckOk);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapperCheckOk", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapperCheckOk::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapperCheckOk(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOk * SOAP_FMAC4 soap_get__nyapc1__updateWrapperCheckOk(struct soap *soap, _nyapc1__updateWrapperCheckOk *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapperCheckOk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapperCheckOk * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapperCheckOk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapperCheckOk(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapperCheckOk, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperCheckOk);
		if (size)
			*size = sizeof(_nyapc1__updateWrapperCheckOk);
		((_nyapc1__updateWrapperCheckOk*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperCheckOk[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapperCheckOk);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapperCheckOk*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapperCheckOk*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapperCheckOk(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapperCheckOk %p -> %p\n", q, p));
	*(_nyapc1__updateWrapperCheckOk*)p = *(_nyapc1__updateWrapperCheckOk*)q;
}

void _nyapc1__updateWrapperResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__updateWrapperResponse::updateWrapperReturn);
	/* transient soap skipped */
}

void _nyapc1__updateWrapperResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateWrapperResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapperResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapperResponse(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapperResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapperResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:updateWrapperReturn");
	if (soap_out_bool(soap, "nyapc1:updateWrapperReturn", -1, &(a->_nyapc1__updateWrapperResponse::updateWrapperReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapperResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapperResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperResponse * SOAP_FMAC4 soap_in__nyapc1__updateWrapperResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapperResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapperResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapperResponse, sizeof(_nyapc1__updateWrapperResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapperResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapperResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_updateWrapperReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updateWrapperReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:updateWrapperReturn", &(a->_nyapc1__updateWrapperResponse::updateWrapperReturn), "xsd:boolean"))
				{	soap_flag_updateWrapperReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:updateWrapperReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapperResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapperResponse, 0, sizeof(_nyapc1__updateWrapperResponse), 0, soap_copy__nyapc1__updateWrapperResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_updateWrapperReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapperResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapperResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapperResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapperResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapperResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperResponse * SOAP_FMAC4 soap_get__nyapc1__updateWrapperResponse(struct soap *soap, _nyapc1__updateWrapperResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapperResponse * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapperResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapperResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapperResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperResponse);
		if (size)
			*size = sizeof(_nyapc1__updateWrapperResponse);
		((_nyapc1__updateWrapperResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapperResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapperResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapperResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapperResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapperResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapperResponse %p -> %p\n", q, p));
	*(_nyapc1__updateWrapperResponse*)p = *(_nyapc1__updateWrapperResponse*)q;
}

void _nyapc1__updateWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__updateWrapper::wrap);
	soap_default_int(soap, &this->_nyapc1__updateWrapper::id);
	soap_default_int(soap, &this->_nyapc1__updateWrapper::taskid);
	/* transient soap skipped */
}

void _nyapc1__updateWrapper::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__updateWrapper::wrap, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__updateWrapper::wrap);
	/* transient soap skipped */
}

int _nyapc1__updateWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateWrapper(struct soap *soap, const char *tag, int id, const _nyapc1__updateWrapper *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateWrapper), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:wrap", -1, &(a->_nyapc1__updateWrapper::wrap), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__updateWrapper::id), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:taskid", -1, &(a->_nyapc1__updateWrapper::taskid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateWrapper(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateWrapper * SOAP_FMAC4 soap_in__nyapc1__updateWrapper(struct soap *soap, const char *tag, _nyapc1__updateWrapper *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateWrapper, sizeof(_nyapc1__updateWrapper), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateWrapper)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateWrapper *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_wrap1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_taskid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wrap1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:wrap", &(a->_nyapc1__updateWrapper::wrap), "xsd:string"))
				{	soap_flag_wrap1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__updateWrapper::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_taskid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:taskid", &(a->_nyapc1__updateWrapper::taskid), "xsd:int"))
				{	soap_flag_taskid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateWrapper, 0, sizeof(_nyapc1__updateWrapper), 0, soap_copy__nyapc1__updateWrapper);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_wrap1 > 0 || soap_flag_id1 > 0 || soap_flag_taskid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateWrapper);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateWrapper", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateWrapper(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateWrapper * SOAP_FMAC4 soap_get__nyapc1__updateWrapper(struct soap *soap, _nyapc1__updateWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateWrapper * SOAP_FMAC2 soap_instantiate__nyapc1__updateWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateWrapper);
		if (size)
			*size = sizeof(_nyapc1__updateWrapper);
		((_nyapc1__updateWrapper*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateWrapper);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateWrapper*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateWrapper %p -> %p\n", q, p));
	*(_nyapc1__updateWrapper*)p = *(_nyapc1__updateWrapper*)q;
}

void _nyapc1__getWrapInvalidTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getWrapInvalidTaskResponse::getWrapInvalidTaskReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getWrapInvalidTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getWrapInvalidTaskResponse::getWrapInvalidTaskReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapInvalidTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapInvalidTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapInvalidTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapInvalidTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse), type))
		return soap->error;
	if (a->getWrapInvalidTaskReturn)
		soap_element_result(soap, "nyapc1:getWrapInvalidTaskReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getWrapInvalidTaskReturn", -1, &(a->_nyapc1__getWrapInvalidTaskResponse::getWrapInvalidTaskReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapInvalidTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapInvalidTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapInvalidTaskResponse(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapInvalidTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse, sizeof(_nyapc1__getWrapInvalidTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapInvalidTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapInvalidTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapInvalidTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getWrapInvalidTaskReturn", &(a->_nyapc1__getWrapInvalidTaskResponse::getWrapInvalidTaskReturn), "nyapc1:Task"))
				{	soap_flag_getWrapInvalidTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapInvalidTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapInvalidTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse, 0, sizeof(_nyapc1__getWrapInvalidTaskResponse), 0, soap_copy__nyapc1__getWrapInvalidTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapInvalidTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapInvalidTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapInvalidTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapInvalidTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapInvalidTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapInvalidTaskResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapInvalidTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapInvalidTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapInvalidTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapInvalidTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapInvalidTaskResponse);
		((_nyapc1__getWrapInvalidTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapInvalidTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapInvalidTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapInvalidTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapInvalidTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapInvalidTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapInvalidTaskResponse*)p = *(_nyapc1__getWrapInvalidTaskResponse*)q;
}

void _nyapc1__getWrapInvalidTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapInvalidTask::cid);
	soap_default_int(soap, &this->_nyapc1__getWrapInvalidTask::num);
	/* transient soap skipped */
}

void _nyapc1__getWrapInvalidTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapInvalidTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapInvalidTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapInvalidTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapInvalidTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getWrapInvalidTask::cid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getWrapInvalidTask::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapInvalidTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapInvalidTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTask * SOAP_FMAC4 soap_in__nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapInvalidTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapInvalidTask, sizeof(_nyapc1__getWrapInvalidTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapInvalidTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapInvalidTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getWrapInvalidTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getWrapInvalidTask::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapInvalidTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapInvalidTask, 0, sizeof(_nyapc1__getWrapInvalidTask), 0, soap_copy__nyapc1__getWrapInvalidTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0 || soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapInvalidTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapInvalidTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapInvalidTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapInvalidTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapInvalidTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTask * SOAP_FMAC4 soap_get__nyapc1__getWrapInvalidTask(struct soap *soap, _nyapc1__getWrapInvalidTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapInvalidTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapInvalidTask * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapInvalidTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapInvalidTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapInvalidTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTask);
		if (size)
			*size = sizeof(_nyapc1__getWrapInvalidTask);
		((_nyapc1__getWrapInvalidTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapInvalidTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapInvalidTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapInvalidTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapInvalidTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapInvalidTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapInvalidTask %p -> %p\n", q, p));
	*(_nyapc1__getWrapInvalidTask*)p = *(_nyapc1__getWrapInvalidTask*)q;
}

void _nyapc1__takeWrapTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__takeWrapTaskResponse::takeWrapTaskReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__takeWrapTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__takeWrapTaskResponse::takeWrapTaskReturn);
	/* transient soap skipped */
}

int _nyapc1__takeWrapTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__takeWrapTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__takeWrapTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__takeWrapTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__takeWrapTaskResponse), type))
		return soap->error;
	if (a->takeWrapTaskReturn)
		soap_element_result(soap, "nyapc1:takeWrapTaskReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:takeWrapTaskReturn", -1, &(a->_nyapc1__takeWrapTaskResponse::takeWrapTaskReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__takeWrapTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__takeWrapTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTaskResponse * SOAP_FMAC4 soap_in__nyapc1__takeWrapTaskResponse(struct soap *soap, const char *tag, _nyapc1__takeWrapTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__takeWrapTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__takeWrapTaskResponse, sizeof(_nyapc1__takeWrapTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__takeWrapTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__takeWrapTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_takeWrapTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_takeWrapTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:takeWrapTaskReturn", &(a->_nyapc1__takeWrapTaskResponse::takeWrapTaskReturn), "nyapc1:Task"))
				{	soap_flag_takeWrapTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:takeWrapTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__takeWrapTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__takeWrapTaskResponse, 0, sizeof(_nyapc1__takeWrapTaskResponse), 0, soap_copy__nyapc1__takeWrapTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_takeWrapTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__takeWrapTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__takeWrapTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:takeWrapTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__takeWrapTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__takeWrapTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTaskResponse * SOAP_FMAC4 soap_get__nyapc1__takeWrapTaskResponse(struct soap *soap, _nyapc1__takeWrapTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__takeWrapTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__takeWrapTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__takeWrapTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__takeWrapTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__takeWrapTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__takeWrapTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__takeWrapTaskResponse);
		((_nyapc1__takeWrapTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__takeWrapTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__takeWrapTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__takeWrapTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__takeWrapTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__takeWrapTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__takeWrapTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__takeWrapTaskResponse*)p = *(_nyapc1__takeWrapTaskResponse*)q;
}

void _nyapc1__takeWrapTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__takeWrapTask::cid);
	/* transient soap skipped */
}

void _nyapc1__takeWrapTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__takeWrapTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__takeWrapTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__takeWrapTask(struct soap *soap, const char *tag, int id, const _nyapc1__takeWrapTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__takeWrapTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__takeWrapTask::cid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__takeWrapTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__takeWrapTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTask * SOAP_FMAC4 soap_in__nyapc1__takeWrapTask(struct soap *soap, const char *tag, _nyapc1__takeWrapTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__takeWrapTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__takeWrapTask, sizeof(_nyapc1__takeWrapTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__takeWrapTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__takeWrapTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__takeWrapTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__takeWrapTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__takeWrapTask, 0, sizeof(_nyapc1__takeWrapTask), 0, soap_copy__nyapc1__takeWrapTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__takeWrapTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__takeWrapTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:takeWrapTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__takeWrapTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__takeWrapTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTask * SOAP_FMAC4 soap_get__nyapc1__takeWrapTask(struct soap *soap, _nyapc1__takeWrapTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__takeWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__takeWrapTask * SOAP_FMAC2 soap_instantiate__nyapc1__takeWrapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__takeWrapTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__takeWrapTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__takeWrapTask);
		if (size)
			*size = sizeof(_nyapc1__takeWrapTask);
		((_nyapc1__takeWrapTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__takeWrapTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__takeWrapTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__takeWrapTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__takeWrapTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__takeWrapTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__takeWrapTask %p -> %p\n", q, p));
	*(_nyapc1__takeWrapTask*)p = *(_nyapc1__takeWrapTask*)q;
}

void _nyapc1__getWrapTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getWrapTaskResponse::getWrapTaskReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getWrapTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getWrapTaskResponse::getWrapTaskReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapTaskResponse), type))
		return soap->error;
	if (a->getWrapTaskReturn)
		soap_element_result(soap, "nyapc1:getWrapTaskReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getWrapTaskReturn", -1, &(a->_nyapc1__getWrapTaskResponse::getWrapTaskReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapTaskResponse(struct soap *soap, const char *tag, _nyapc1__getWrapTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapTaskResponse, sizeof(_nyapc1__getWrapTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getWrapTaskReturn", &(a->_nyapc1__getWrapTaskResponse::getWrapTaskReturn), "nyapc1:Task"))
				{	soap_flag_getWrapTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapTaskResponse, 0, sizeof(_nyapc1__getWrapTaskResponse), 0, soap_copy__nyapc1__getWrapTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapTaskResponse(struct soap *soap, _nyapc1__getWrapTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapTaskResponse);
		((_nyapc1__getWrapTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapTaskResponse*)p = *(_nyapc1__getWrapTaskResponse*)q;
}

void _nyapc1__getWrapTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapTask::cid);
	soap_default_int(soap, &this->_nyapc1__getWrapTask::num);
	/* transient soap skipped */
}

void _nyapc1__getWrapTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapTask(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getWrapTask::cid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getWrapTask::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapTask * SOAP_FMAC4 soap_in__nyapc1__getWrapTask(struct soap *soap, const char *tag, _nyapc1__getWrapTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapTask, sizeof(_nyapc1__getWrapTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getWrapTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getWrapTask::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapTask, 0, sizeof(_nyapc1__getWrapTask), 0, soap_copy__nyapc1__getWrapTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0 || soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapTask * SOAP_FMAC4 soap_get__nyapc1__getWrapTask(struct soap *soap, _nyapc1__getWrapTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapTask * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapTask);
		if (size)
			*size = sizeof(_nyapc1__getWrapTask);
		((_nyapc1__getWrapTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapTask %p -> %p\n", q, p));
	*(_nyapc1__getWrapTask*)p = *(_nyapc1__getWrapTask*)q;
}

void _nyapc1__getTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getTaskResponse::getTaskReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__Task(soap, &this->_nyapc1__getTaskResponse::getTaskReturn);
	/* transient soap skipped */
}

int _nyapc1__getTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTaskResponse), type))
		return soap->error;
	if (a->getTaskReturn)
		soap_element_result(soap, "nyapc1:getTaskReturn");
	if (soap_out_PointerTonyapc1__Task(soap, "nyapc1:getTaskReturn", -1, &(a->_nyapc1__getTaskResponse::getTaskReturn), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTaskResponse * SOAP_FMAC4 soap_in__nyapc1__getTaskResponse(struct soap *soap, const char *tag, _nyapc1__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTaskResponse, sizeof(_nyapc1__getTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__Task(soap, "nyapc1:getTaskReturn", &(a->_nyapc1__getTaskResponse::getTaskReturn), "nyapc1:Task"))
				{	soap_flag_getTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTaskResponse, 0, sizeof(_nyapc1__getTaskResponse), 0, soap_copy__nyapc1__getTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTaskResponse * SOAP_FMAC4 soap_get__nyapc1__getTaskResponse(struct soap *soap, _nyapc1__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__getTaskResponse);
		((_nyapc1__getTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__getTaskResponse*)p = *(_nyapc1__getTaskResponse*)q;
}

void _nyapc1__getTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getTask::cid);
	soap_default_int(soap, &this->_nyapc1__getTask::num);
	/* transient soap skipped */
}

void _nyapc1__getTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getTask(struct soap *soap, const char *tag, int id, const _nyapc1__getTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__getTask::cid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:num", -1, &(a->_nyapc1__getTask::num), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getTask * SOAP_FMAC4 soap_in__nyapc1__getTask(struct soap *soap, const char *tag, _nyapc1__getTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getTask, sizeof(_nyapc1__getTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_num1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__getTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			if (soap_flag_num1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:num", &(a->_nyapc1__getTask::num), "xsd:int"))
				{	soap_flag_num1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getTask, 0, sizeof(_nyapc1__getTask), 0, soap_copy__nyapc1__getTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0 || soap_flag_num1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:getTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getTask * SOAP_FMAC4 soap_get__nyapc1__getTask(struct soap *soap, _nyapc1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getTask * SOAP_FMAC2 soap_instantiate__nyapc1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getTask);
		if (size)
			*size = sizeof(_nyapc1__getTask);
		((_nyapc1__getTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__getTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getTask %p -> %p\n", q, p));
	*(_nyapc1__getTask*)p = *(_nyapc1__getTask*)q;
}

void _nyapc1__addWrapperResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__addWrapperResponse::addWrapperReturn);
	/* transient soap skipped */
}

void _nyapc1__addWrapperResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__addWrapperResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__addWrapperResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__addWrapperResponse(struct soap *soap, const char *tag, int id, const _nyapc1__addWrapperResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__addWrapperResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:addWrapperReturn");
	if (soap_out_bool(soap, "nyapc1:addWrapperReturn", -1, &(a->_nyapc1__addWrapperResponse::addWrapperReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__addWrapperResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__addWrapperResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__addWrapperResponse * SOAP_FMAC4 soap_in__nyapc1__addWrapperResponse(struct soap *soap, const char *tag, _nyapc1__addWrapperResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__addWrapperResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__addWrapperResponse, sizeof(_nyapc1__addWrapperResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__addWrapperResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__addWrapperResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addWrapperReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addWrapperReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:addWrapperReturn", &(a->_nyapc1__addWrapperResponse::addWrapperReturn), "xsd:boolean"))
				{	soap_flag_addWrapperReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:addWrapperReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__addWrapperResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__addWrapperResponse, 0, sizeof(_nyapc1__addWrapperResponse), 0, soap_copy__nyapc1__addWrapperResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_addWrapperReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__addWrapperResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__addWrapperResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:addWrapperResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__addWrapperResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__addWrapperResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__addWrapperResponse * SOAP_FMAC4 soap_get__nyapc1__addWrapperResponse(struct soap *soap, _nyapc1__addWrapperResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__addWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__addWrapperResponse * SOAP_FMAC2 soap_instantiate__nyapc1__addWrapperResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__addWrapperResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__addWrapperResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__addWrapperResponse);
		if (size)
			*size = sizeof(_nyapc1__addWrapperResponse);
		((_nyapc1__addWrapperResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__addWrapperResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__addWrapperResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__addWrapperResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__addWrapperResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__addWrapperResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__addWrapperResponse %p -> %p\n", q, p));
	*(_nyapc1__addWrapperResponse*)p = *(_nyapc1__addWrapperResponse*)q;
}

void _nyapc1__addWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__addWrapper::jobId);
	soap_default_std__string(soap, &this->_nyapc1__addWrapper::type);
	soap_default_std__string(soap, &this->_nyapc1__addWrapper::Wrapper);
	soap_default_std__string(soap, &this->_nyapc1__addWrapper::vargen);
	soap_default_std__string(soap, &this->_nyapc1__addWrapper::comment);
	/* transient soap skipped */
}

void _nyapc1__addWrapper::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__addWrapper::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addWrapper::type);
	soap_embedded(soap, &this->_nyapc1__addWrapper::Wrapper, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addWrapper::Wrapper);
	soap_embedded(soap, &this->_nyapc1__addWrapper::vargen, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addWrapper::vargen);
	soap_embedded(soap, &this->_nyapc1__addWrapper::comment, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addWrapper::comment);
	/* transient soap skipped */
}

int _nyapc1__addWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__addWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__addWrapper(struct soap *soap, const char *tag, int id, const _nyapc1__addWrapper *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__addWrapper), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:jobId", -1, &(a->_nyapc1__addWrapper::jobId), "xsd:int"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:type", -1, &(a->_nyapc1__addWrapper::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:Wrapper", -1, &(a->_nyapc1__addWrapper::Wrapper), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:vargen", -1, &(a->_nyapc1__addWrapper::vargen), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:comment", -1, &(a->_nyapc1__addWrapper::comment), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__addWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__addWrapper(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__addWrapper * SOAP_FMAC4 soap_in__nyapc1__addWrapper(struct soap *soap, const char *tag, _nyapc1__addWrapper *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__addWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__addWrapper, sizeof(_nyapc1__addWrapper), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__addWrapper)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__addWrapper *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_Wrapper1 = 1;
	size_t soap_flag_vargen1 = 1;
	size_t soap_flag_comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:jobId", &(a->_nyapc1__addWrapper::jobId), "xsd:int"))
				{	soap_flag_jobId1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:type", &(a->_nyapc1__addWrapper::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_Wrapper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:Wrapper", &(a->_nyapc1__addWrapper::Wrapper), "xsd:string"))
				{	soap_flag_Wrapper1--;
					continue;
				}
			if (soap_flag_vargen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:vargen", &(a->_nyapc1__addWrapper::vargen), "xsd:string"))
				{	soap_flag_vargen1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:comment", &(a->_nyapc1__addWrapper::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__addWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__addWrapper, 0, sizeof(_nyapc1__addWrapper), 0, soap_copy__nyapc1__addWrapper);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_jobId1 > 0 || soap_flag_type1 > 0 || soap_flag_Wrapper1 > 0 || soap_flag_vargen1 > 0 || soap_flag_comment1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__addWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__addWrapper);
	if (this->soap_out(soap, tag?tag:"nyapc1:addWrapper", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__addWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__addWrapper(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__addWrapper * SOAP_FMAC4 soap_get__nyapc1__addWrapper(struct soap *soap, _nyapc1__addWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__addWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__addWrapper * SOAP_FMAC2 soap_instantiate__nyapc1__addWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__addWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__addWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__addWrapper);
		if (size)
			*size = sizeof(_nyapc1__addWrapper);
		((_nyapc1__addWrapper*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__addWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__addWrapper);
		for (int i = 0; i < n; i++)
			((_nyapc1__addWrapper*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__addWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__addWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__addWrapper %p -> %p\n", q, p));
	*(_nyapc1__addWrapper*)p = *(_nyapc1__addWrapper*)q;
}

void _nyapc1__getWrapperResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__getWrapperResponse::getWrapperReturn);
	/* transient soap skipped */
}

void _nyapc1__getWrapperResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__getWrapperResponse::getWrapperReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__getWrapperResponse::getWrapperReturn);
	/* transient soap skipped */
}

int _nyapc1__getWrapperResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapperResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapperResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapperResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapperResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getWrapperReturn");
	if (soap_out_std__string(soap, "nyapc1:getWrapperReturn", -1, &(a->_nyapc1__getWrapperResponse::getWrapperReturn), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapperResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapperResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapperResponse * SOAP_FMAC4 soap_in__nyapc1__getWrapperResponse(struct soap *soap, const char *tag, _nyapc1__getWrapperResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapperResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapperResponse, sizeof(_nyapc1__getWrapperResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapperResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapperResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getWrapperReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getWrapperReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:getWrapperReturn", &(a->_nyapc1__getWrapperResponse::getWrapperReturn), "xsd:string"))
				{	soap_flag_getWrapperReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getWrapperReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapperResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapperResponse, 0, sizeof(_nyapc1__getWrapperResponse), 0, soap_copy__nyapc1__getWrapperResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getWrapperReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapperResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapperResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapperResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapperResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapperResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapperResponse * SOAP_FMAC4 soap_get__nyapc1__getWrapperResponse(struct soap *soap, _nyapc1__getWrapperResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapperResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapperResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapperResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapperResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapperResponse);
		if (size)
			*size = sizeof(_nyapc1__getWrapperResponse);
		((_nyapc1__getWrapperResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapperResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapperResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapperResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapperResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapperResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapperResponse %p -> %p\n", q, p));
	*(_nyapc1__getWrapperResponse*)p = *(_nyapc1__getWrapperResponse*)q;
}

void _nyapc1__getWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getWrapper::id);
	/* transient soap skipped */
}

void _nyapc1__getWrapper::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getWrapper(struct soap *soap, const char *tag, int id, const _nyapc1__getWrapper *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getWrapper), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__getWrapper::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getWrapper(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getWrapper * SOAP_FMAC4 soap_in__nyapc1__getWrapper(struct soap *soap, const char *tag, _nyapc1__getWrapper *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getWrapper, sizeof(_nyapc1__getWrapper), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getWrapper)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getWrapper *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__getWrapper::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getWrapper, 0, sizeof(_nyapc1__getWrapper), 0, soap_copy__nyapc1__getWrapper);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getWrapper);
	if (this->soap_out(soap, tag?tag:"nyapc1:getWrapper", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getWrapper(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getWrapper * SOAP_FMAC4 soap_get__nyapc1__getWrapper(struct soap *soap, _nyapc1__getWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getWrapper * SOAP_FMAC2 soap_instantiate__nyapc1__getWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getWrapper);
		if (size)
			*size = sizeof(_nyapc1__getWrapper);
		((_nyapc1__getWrapper*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getWrapper);
		for (int i = 0; i < n; i++)
			((_nyapc1__getWrapper*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getWrapper %p -> %p\n", q, p));
	*(_nyapc1__getWrapper*)p = *(_nyapc1__getWrapper*)q;
}

void _nyapc1__updateJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__updateJobResponse::updateJobReturn);
	/* transient soap skipped */
}

void _nyapc1__updateJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateJobResponse(struct soap *soap, const char *tag, int id, const _nyapc1__updateJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateJobResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:updateJobReturn");
	if (soap_out_bool(soap, "nyapc1:updateJobReturn", -1, &(a->_nyapc1__updateJobResponse::updateJobReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateJobResponse * SOAP_FMAC4 soap_in__nyapc1__updateJobResponse(struct soap *soap, const char *tag, _nyapc1__updateJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateJobResponse, sizeof(_nyapc1__updateJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_updateJobReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updateJobReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:updateJobReturn", &(a->_nyapc1__updateJobResponse::updateJobReturn), "xsd:boolean"))
				{	soap_flag_updateJobReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:updateJobReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateJobResponse, 0, sizeof(_nyapc1__updateJobResponse), 0, soap_copy__nyapc1__updateJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_updateJobReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateJobResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateJobResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateJobResponse * SOAP_FMAC4 soap_get__nyapc1__updateJobResponse(struct soap *soap, _nyapc1__updateJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateJobResponse * SOAP_FMAC2 soap_instantiate__nyapc1__updateJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateJobResponse);
		if (size)
			*size = sizeof(_nyapc1__updateJobResponse);
		((_nyapc1__updateJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateJobResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateJobResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateJobResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateJobResponse %p -> %p\n", q, p));
	*(_nyapc1__updateJobResponse*)p = *(_nyapc1__updateJobResponse*)q;
}

void _nyapc1__updateJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__updateJob::id);
	/* transient soap skipped */
}

void _nyapc1__updateJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__updateJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__updateJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__updateJob(struct soap *soap, const char *tag, int id, const _nyapc1__updateJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__updateJob), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__updateJob::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__updateJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__updateJob(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__updateJob * SOAP_FMAC4 soap_in__nyapc1__updateJob(struct soap *soap, const char *tag, _nyapc1__updateJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__updateJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__updateJob, sizeof(_nyapc1__updateJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__updateJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__updateJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__updateJob::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__updateJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__updateJob, 0, sizeof(_nyapc1__updateJob), 0, soap_copy__nyapc1__updateJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__updateJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__updateJob);
	if (this->soap_out(soap, tag?tag:"nyapc1:updateJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__updateJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__updateJob(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__updateJob * SOAP_FMAC4 soap_get__nyapc1__updateJob(struct soap *soap, _nyapc1__updateJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__updateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__updateJob * SOAP_FMAC2 soap_instantiate__nyapc1__updateJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__updateJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__updateJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__updateJob);
		if (size)
			*size = sizeof(_nyapc1__updateJob);
		((_nyapc1__updateJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__updateJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__updateJob);
		for (int i = 0; i < n; i++)
			((_nyapc1__updateJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__updateJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__updateJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__updateJob %p -> %p\n", q, p));
	*(_nyapc1__updateJob*)p = *(_nyapc1__updateJob*)q;
}

void _nyapc1__hasTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_nyapc1__hasTaskResponse::hasTaskReturn);
	/* transient soap skipped */
}

void _nyapc1__hasTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__hasTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__hasTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__hasTaskResponse(struct soap *soap, const char *tag, int id, const _nyapc1__hasTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__hasTaskResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:hasTaskReturn");
	if (soap_out_bool(soap, "nyapc1:hasTaskReturn", -1, &(a->_nyapc1__hasTaskResponse::hasTaskReturn), "xsd:boolean"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__hasTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__hasTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__hasTaskResponse * SOAP_FMAC4 soap_in__nyapc1__hasTaskResponse(struct soap *soap, const char *tag, _nyapc1__hasTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__hasTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__hasTaskResponse, sizeof(_nyapc1__hasTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__hasTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__hasTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_hasTaskReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hasTaskReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "nyapc1:hasTaskReturn", &(a->_nyapc1__hasTaskResponse::hasTaskReturn), "xsd:boolean"))
				{	soap_flag_hasTaskReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:hasTaskReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__hasTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__hasTaskResponse, 0, sizeof(_nyapc1__hasTaskResponse), 0, soap_copy__nyapc1__hasTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_hasTaskReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__hasTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__hasTaskResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:hasTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__hasTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__hasTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__hasTaskResponse * SOAP_FMAC4 soap_get__nyapc1__hasTaskResponse(struct soap *soap, _nyapc1__hasTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__hasTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__hasTaskResponse * SOAP_FMAC2 soap_instantiate__nyapc1__hasTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__hasTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__hasTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__hasTaskResponse);
		if (size)
			*size = sizeof(_nyapc1__hasTaskResponse);
		((_nyapc1__hasTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__hasTaskResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__hasTaskResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__hasTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__hasTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__hasTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__hasTaskResponse %p -> %p\n", q, p));
	*(_nyapc1__hasTaskResponse*)p = *(_nyapc1__hasTaskResponse*)q;
}

void _nyapc1__hasTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__hasTask::cid);
	/* transient soap skipped */
}

void _nyapc1__hasTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__hasTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__hasTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__hasTask(struct soap *soap, const char *tag, int id, const _nyapc1__hasTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__hasTask), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:cid", -1, &(a->_nyapc1__hasTask::cid), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__hasTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__hasTask(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__hasTask * SOAP_FMAC4 soap_in__nyapc1__hasTask(struct soap *soap, const char *tag, _nyapc1__hasTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__hasTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__hasTask, sizeof(_nyapc1__hasTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__hasTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__hasTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:cid", &(a->_nyapc1__hasTask::cid), "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__hasTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__hasTask, 0, sizeof(_nyapc1__hasTask), 0, soap_copy__nyapc1__hasTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_cid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__hasTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__hasTask);
	if (this->soap_out(soap, tag?tag:"nyapc1:hasTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__hasTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__hasTask(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__hasTask * SOAP_FMAC4 soap_get__nyapc1__hasTask(struct soap *soap, _nyapc1__hasTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__hasTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__hasTask * SOAP_FMAC2 soap_instantiate__nyapc1__hasTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__hasTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__hasTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__hasTask);
		if (size)
			*size = sizeof(_nyapc1__hasTask);
		((_nyapc1__hasTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__hasTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__hasTask);
		for (int i = 0; i < n; i++)
			((_nyapc1__hasTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__hasTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__hasTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__hasTask %p -> %p\n", q, p));
	*(_nyapc1__hasTask*)p = *(_nyapc1__hasTask*)q;
}

void _nyapc1__addJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__addJobResponse::addJobReturn);
	/* transient soap skipped */
}

void _nyapc1__addJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__addJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__addJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__addJobResponse(struct soap *soap, const char *tag, int id, const _nyapc1__addJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__addJobResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:addJobReturn");
	if (soap_out_int(soap, "nyapc1:addJobReturn", -1, &(a->_nyapc1__addJobResponse::addJobReturn), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__addJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__addJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__addJobResponse * SOAP_FMAC4 soap_in__nyapc1__addJobResponse(struct soap *soap, const char *tag, _nyapc1__addJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__addJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__addJobResponse, sizeof(_nyapc1__addJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__addJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__addJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addJobReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addJobReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:addJobReturn", &(a->_nyapc1__addJobResponse::addJobReturn), "xsd:int"))
				{	soap_flag_addJobReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:addJobReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__addJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__addJobResponse, 0, sizeof(_nyapc1__addJobResponse), 0, soap_copy__nyapc1__addJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_addJobReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__addJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__addJobResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:addJobResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__addJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__addJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__addJobResponse * SOAP_FMAC4 soap_get__nyapc1__addJobResponse(struct soap *soap, _nyapc1__addJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__addJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__addJobResponse * SOAP_FMAC2 soap_instantiate__nyapc1__addJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__addJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__addJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__addJobResponse);
		if (size)
			*size = sizeof(_nyapc1__addJobResponse);
		((_nyapc1__addJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__addJobResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__addJobResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__addJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__addJobResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__addJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__addJobResponse %p -> %p\n", q, p));
	*(_nyapc1__addJobResponse*)p = *(_nyapc1__addJobResponse*)q;
}

void _nyapc1__addJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__addJob::name);
	soap_default_std__string(soap, &this->_nyapc1__addJob::url);
	soap_default_std__string(soap, &this->_nyapc1__addJob::type);
	soap_default_std__string(soap, &this->_nyapc1__addJob::comment);
	/* transient soap skipped */
}

void _nyapc1__addJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__addJob::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addJob::name);
	soap_embedded(soap, &this->_nyapc1__addJob::url, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addJob::url);
	soap_embedded(soap, &this->_nyapc1__addJob::type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addJob::type);
	soap_embedded(soap, &this->_nyapc1__addJob::comment, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addJob::comment);
	/* transient soap skipped */
}

int _nyapc1__addJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__addJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__addJob(struct soap *soap, const char *tag, int id, const _nyapc1__addJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__addJob), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:name", -1, &(a->_nyapc1__addJob::name), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:url", -1, &(a->_nyapc1__addJob::url), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:type", -1, &(a->_nyapc1__addJob::type), "xsd:string"))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:comment", -1, &(a->_nyapc1__addJob::comment), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__addJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__addJob(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__addJob * SOAP_FMAC4 soap_in__nyapc1__addJob(struct soap *soap, const char *tag, _nyapc1__addJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__addJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__addJob, sizeof(_nyapc1__addJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__addJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__addJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_url1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:name", &(a->_nyapc1__addJob::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:url", &(a->_nyapc1__addJob::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:type", &(a->_nyapc1__addJob::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:comment", &(a->_nyapc1__addJob::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__addJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__addJob, 0, sizeof(_nyapc1__addJob), 0, soap_copy__nyapc1__addJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_name1 > 0 || soap_flag_url1 > 0 || soap_flag_type1 > 0 || soap_flag_comment1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__addJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__addJob);
	if (this->soap_out(soap, tag?tag:"nyapc1:addJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__addJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__addJob(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__addJob * SOAP_FMAC4 soap_get__nyapc1__addJob(struct soap *soap, _nyapc1__addJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__addJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__addJob * SOAP_FMAC2 soap_instantiate__nyapc1__addJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__addJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__addJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__addJob);
		if (size)
			*size = sizeof(_nyapc1__addJob);
		((_nyapc1__addJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__addJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__addJob);
		for (int i = 0; i < n; i++)
			((_nyapc1__addJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__addJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__addJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__addJob %p -> %p\n", q, p));
	*(_nyapc1__addJob*)p = *(_nyapc1__addJob*)q;
}

void _nyapc1__getJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_nyapc1__getJobResponse::getJobReturn = NULL;
	/* transient soap skipped */
}

void _nyapc1__getJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTonyapc1__JobAtt(soap, &this->_nyapc1__getJobResponse::getJobReturn);
	/* transient soap skipped */
}

int _nyapc1__getJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJobResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJobResponse), type))
		return soap->error;
	if (a->getJobReturn)
		soap_element_result(soap, "nyapc1:getJobReturn");
	if (soap_out_PointerTonyapc1__JobAtt(soap, "nyapc1:getJobReturn", -1, &(a->_nyapc1__getJobResponse::getJobReturn), "nyapc1:JobAtt"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJobResponse * SOAP_FMAC4 soap_in__nyapc1__getJobResponse(struct soap *soap, const char *tag, _nyapc1__getJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJobResponse, sizeof(_nyapc1__getJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getJobReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getJobReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonyapc1__JobAtt(soap, "nyapc1:getJobReturn", &(a->_nyapc1__getJobResponse::getJobReturn), "nyapc1:JobAtt"))
				{	soap_flag_getJobReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getJobReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJobResponse, 0, sizeof(_nyapc1__getJobResponse), 0, soap_copy__nyapc1__getJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getJobReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJobResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJobResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJobResponse * SOAP_FMAC4 soap_get__nyapc1__getJobResponse(struct soap *soap, _nyapc1__getJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJobResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJobResponse);
		if (size)
			*size = sizeof(_nyapc1__getJobResponse);
		((_nyapc1__getJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJobResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJobResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJobResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJobResponse %p -> %p\n", q, p));
	*(_nyapc1__getJobResponse*)p = *(_nyapc1__getJobResponse*)q;
}

void _nyapc1__getJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getJob::id);
	/* transient soap skipped */
}

void _nyapc1__getJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getJob(struct soap *soap, const char *tag, int id, const _nyapc1__getJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getJob), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__getJob::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getJob(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getJob * SOAP_FMAC4 soap_in__nyapc1__getJob(struct soap *soap, const char *tag, _nyapc1__getJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getJob, sizeof(_nyapc1__getJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__getJob::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getJob, 0, sizeof(_nyapc1__getJob), 0, soap_copy__nyapc1__getJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getJob);
	if (this->soap_out(soap, tag?tag:"nyapc1:getJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getJob(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getJob * SOAP_FMAC4 soap_get__nyapc1__getJob(struct soap *soap, _nyapc1__getJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getJob * SOAP_FMAC2 soap_instantiate__nyapc1__getJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getJob);
		if (size)
			*size = sizeof(_nyapc1__getJob);
		((_nyapc1__getJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getJob);
		for (int i = 0; i < n; i++)
			((_nyapc1__getJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getJob %p -> %p\n", q, p));
	*(_nyapc1__getJob*)p = *(_nyapc1__getJob*)q;
}

void _nyapc1__getVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getVersionResponse::getVersionReturn);
	/* transient soap skipped */
}

void _nyapc1__getVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getVersionResponse(struct soap *soap, const char *tag, int id, const _nyapc1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getVersionResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:getVersionReturn");
	if (soap_out_int(soap, "nyapc1:getVersionReturn", -1, &(a->_nyapc1__getVersionResponse::getVersionReturn), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getVersionResponse * SOAP_FMAC4 soap_in__nyapc1__getVersionResponse(struct soap *soap, const char *tag, _nyapc1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getVersionResponse, sizeof(_nyapc1__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getVersionReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:getVersionReturn", &(a->_nyapc1__getVersionResponse::getVersionReturn), "xsd:int"))
				{	soap_flag_getVersionReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:getVersionReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getVersionResponse, 0, sizeof(_nyapc1__getVersionResponse), 0, soap_copy__nyapc1__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_getVersionReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getVersionResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:getVersionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getVersionResponse * SOAP_FMAC4 soap_get__nyapc1__getVersionResponse(struct soap *soap, _nyapc1__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getVersionResponse * SOAP_FMAC2 soap_instantiate__nyapc1__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getVersionResponse);
		if (size)
			*size = sizeof(_nyapc1__getVersionResponse);
		((_nyapc1__getVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getVersionResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__getVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getVersionResponse %p -> %p\n", q, p));
	*(_nyapc1__getVersionResponse*)p = *(_nyapc1__getVersionResponse*)q;
}

void _nyapc1__getVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_nyapc1__getVersion::id);
	/* transient soap skipped */
}

void _nyapc1__getVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _nyapc1__getVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__getVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__getVersion(struct soap *soap, const char *tag, int id, const _nyapc1__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__getVersion), type))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->_nyapc1__getVersion::id), "xsd:int"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__getVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__getVersion(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__getVersion * SOAP_FMAC4 soap_in__nyapc1__getVersion(struct soap *soap, const char *tag, _nyapc1__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__getVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__getVersion, sizeof(_nyapc1__getVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__getVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__getVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->_nyapc1__getVersion::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__getVersion, 0, sizeof(_nyapc1__getVersion), 0, soap_copy__nyapc1__getVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__getVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__getVersion);
	if (this->soap_out(soap, tag?tag:"nyapc1:getVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__getVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__getVersion(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__getVersion * SOAP_FMAC4 soap_get__nyapc1__getVersion(struct soap *soap, _nyapc1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__getVersion * SOAP_FMAC2 soap_instantiate__nyapc1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__getVersion);
		if (size)
			*size = sizeof(_nyapc1__getVersion);
		((_nyapc1__getVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__getVersion);
		for (int i = 0; i < n; i++)
			((_nyapc1__getVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__getVersion %p -> %p\n", q, p));
	*(_nyapc1__getVersion*)p = *(_nyapc1__getVersion*)q;
}

void _nyapc1__addResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__addResponse::addReturn);
	/* transient soap skipped */
}

void _nyapc1__addResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__addResponse::addReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__addResponse::addReturn);
	/* transient soap skipped */
}

int _nyapc1__addResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__addResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__addResponse(struct soap *soap, const char *tag, int id, const _nyapc1__addResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__addResponse), type))
		return soap->error;
	soap_element_result(soap, "nyapc1:addReturn");
	if (soap_out_std__string(soap, "nyapc1:addReturn", -1, &(a->_nyapc1__addResponse::addReturn), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__addResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__addResponse(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__addResponse * SOAP_FMAC4 soap_in__nyapc1__addResponse(struct soap *soap, const char *tag, _nyapc1__addResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__addResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__addResponse, sizeof(_nyapc1__addResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__addResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__addResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:addReturn", &(a->_nyapc1__addResponse::addReturn), "xsd:string"))
				{	soap_flag_addReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "nyapc1:addReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__addResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__addResponse, 0, sizeof(_nyapc1__addResponse), 0, soap_copy__nyapc1__addResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_addReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__addResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__addResponse);
	if (this->soap_out(soap, tag?tag:"nyapc1:addResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__addResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__addResponse(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__addResponse * SOAP_FMAC4 soap_get__nyapc1__addResponse(struct soap *soap, _nyapc1__addResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__addResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__addResponse * SOAP_FMAC2 soap_instantiate__nyapc1__addResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__addResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__addResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__addResponse);
		if (size)
			*size = sizeof(_nyapc1__addResponse);
		((_nyapc1__addResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__addResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__addResponse);
		for (int i = 0; i < n; i++)
			((_nyapc1__addResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__addResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__addResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__addResponse %p -> %p\n", q, p));
	*(_nyapc1__addResponse*)p = *(_nyapc1__addResponse*)q;
}

void _nyapc1__add::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_nyapc1__add::s);
	/* transient soap skipped */
}

void _nyapc1__add::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_nyapc1__add::s, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_nyapc1__add::s);
	/* transient soap skipped */
}

int _nyapc1__add::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__nyapc1__add(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__nyapc1__add(struct soap *soap, const char *tag, int id, const _nyapc1__add *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__nyapc1__add), type))
		return soap->error;
	if (soap_out_std__string(soap, "nyapc1:s", -1, &(a->_nyapc1__add::s), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_nyapc1__add::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__nyapc1__add(soap, tag, this, type);
}

SOAP_FMAC3 _nyapc1__add * SOAP_FMAC4 soap_in__nyapc1__add(struct soap *soap, const char *tag, _nyapc1__add *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_nyapc1__add *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__nyapc1__add, sizeof(_nyapc1__add), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__nyapc1__add)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_nyapc1__add *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_s1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nyapc1:s", &(a->_nyapc1__add::s), "xsd:string"))
				{	soap_flag_s1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_nyapc1__add *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__nyapc1__add, 0, sizeof(_nyapc1__add), 0, soap_copy__nyapc1__add);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_s1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _nyapc1__add::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__nyapc1__add);
	if (this->soap_out(soap, tag?tag:"nyapc1:add", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_nyapc1__add::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__nyapc1__add(soap, this, tag, type);
}

SOAP_FMAC3 _nyapc1__add * SOAP_FMAC4 soap_get__nyapc1__add(struct soap *soap, _nyapc1__add *p, const char *tag, const char *type)
{
	if ((p = soap_in__nyapc1__add(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _nyapc1__add * SOAP_FMAC2 soap_instantiate__nyapc1__add(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__nyapc1__add(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__nyapc1__add, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (_nyapc1__add);
		if (size)
			*size = sizeof(_nyapc1__add);
		((_nyapc1__add*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (_nyapc1__add[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_nyapc1__add);
		for (int i = 0; i < n; i++)
			((_nyapc1__add*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_nyapc1__add*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__nyapc1__add(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _nyapc1__add %p -> %p\n", q, p));
	*(_nyapc1__add*)p = *(_nyapc1__add*)q;
}

void nyapc1__Task::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->nyapc1__Task::ids = NULL;
	soap_default_int(soap, &this->nyapc1__Task::job_USCOREid);
	soap_default_int(soap, &this->nyapc1__Task::taskId);
	this->nyapc1__Task::type = NULL;
	this->nyapc1__Task::urls = NULL;
	soap_default_int(soap, &this->nyapc1__Task::wrap_USCOREid);
	soap_default_int(soap, &this->nyapc1__Task::wrap_USCOREversion);
	/* transient soap skipped */
}

void nyapc1__Task::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__Task::ids);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__Task::type);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__Task::urls);
	/* transient soap skipped */
}

int nyapc1__Task::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_nyapc1__Task(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_nyapc1__Task(struct soap *soap, const char *tag, int id, const nyapc1__Task *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_nyapc1__Task), "nyapc1:Task"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "nyapc1:ids", -1, &(a->nyapc1__Task::ids), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:job_id", -1, &(a->nyapc1__Task::job_USCOREid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:taskId", -1, &(a->nyapc1__Task::taskId), "xsd:int"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:type", -1, &(a->nyapc1__Task::type), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:urls", -1, &(a->nyapc1__Task::urls), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:wrap_id", -1, &(a->nyapc1__Task::wrap_USCOREid), "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:wrap_version", -1, &(a->nyapc1__Task::wrap_USCOREversion), "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *nyapc1__Task::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_nyapc1__Task(soap, tag, this, type);
}

SOAP_FMAC3 nyapc1__Task * SOAP_FMAC4 soap_in_nyapc1__Task(struct soap *soap, const char *tag, nyapc1__Task *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (nyapc1__Task *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_nyapc1__Task, sizeof(nyapc1__Task), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_nyapc1__Task)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (nyapc1__Task *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ids1 = 1;
	size_t soap_flag_job_USCOREid1 = 1;
	size_t soap_flag_taskId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_urls1 = 1;
	size_t soap_flag_wrap_USCOREid1 = 1;
	size_t soap_flag_wrap_USCOREversion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ids1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:ids", &(a->nyapc1__Task::ids), "xsd:string"))
				{	soap_flag_ids1--;
					continue;
				}
			if (soap_flag_job_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:job_id", &(a->nyapc1__Task::job_USCOREid), "xsd:int"))
				{	soap_flag_job_USCOREid1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:taskId", &(a->nyapc1__Task::taskId), "xsd:int"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:type", &(a->nyapc1__Task::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_urls1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:urls", &(a->nyapc1__Task::urls), "xsd:string"))
				{	soap_flag_urls1--;
					continue;
				}
			if (soap_flag_wrap_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:wrap_id", &(a->nyapc1__Task::wrap_USCOREid), "xsd:int"))
				{	soap_flag_wrap_USCOREid1--;
					continue;
				}
			if (soap_flag_wrap_USCOREversion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:wrap_version", &(a->nyapc1__Task::wrap_USCOREversion), "xsd:int"))
				{	soap_flag_wrap_USCOREversion1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (nyapc1__Task *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_nyapc1__Task, 0, sizeof(nyapc1__Task), 0, soap_copy_nyapc1__Task);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_job_USCOREid1 > 0 || soap_flag_taskId1 > 0 || soap_flag_wrap_USCOREid1 > 0 || soap_flag_wrap_USCOREversion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int nyapc1__Task::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_nyapc1__Task);
	if (this->soap_out(soap, tag?tag:"nyapc1:Task", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *nyapc1__Task::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_nyapc1__Task(soap, this, tag, type);
}

SOAP_FMAC3 nyapc1__Task * SOAP_FMAC4 soap_get_nyapc1__Task(struct soap *soap, nyapc1__Task *p, const char *tag, const char *type)
{
	if ((p = soap_in_nyapc1__Task(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 nyapc1__Task * SOAP_FMAC2 soap_instantiate_nyapc1__Task(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_nyapc1__Task(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_nyapc1__Task, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (nyapc1__Task);
		if (size)
			*size = sizeof(nyapc1__Task);
		((nyapc1__Task*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (nyapc1__Task[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(nyapc1__Task);
		for (int i = 0; i < n; i++)
			((nyapc1__Task*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (nyapc1__Task*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_nyapc1__Task(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying nyapc1__Task %p -> %p\n", q, p));
	*(nyapc1__Task*)p = *(nyapc1__Task*)q;
}

void nyapc1__JobAtt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->nyapc1__JobAtt::comment = NULL;
	this->nyapc1__JobAtt::createTime = NULL;
	soap_default_int(soap, &this->nyapc1__JobAtt::id);
	this->nyapc1__JobAtt::jobStat = NULL;
	this->nyapc1__JobAtt::name = NULL;
	this->nyapc1__JobAtt::seed = NULL;
	this->nyapc1__JobAtt::seedType = NULL;
	this->nyapc1__JobAtt::updateTime = NULL;
	/* transient soap skipped */
}

void nyapc1__JobAtt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::comment);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::createTime);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::jobStat);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::name);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::seed);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::seedType);
	soap_serialize_PointerTostd__string(soap, &this->nyapc1__JobAtt::updateTime);
	/* transient soap skipped */
}

int nyapc1__JobAtt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_nyapc1__JobAtt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_nyapc1__JobAtt(struct soap *soap, const char *tag, int id, const nyapc1__JobAtt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_nyapc1__JobAtt), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:comment", -1, &(a->nyapc1__JobAtt::comment), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:createTime", -1, &(a->nyapc1__JobAtt::createTime), "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "nyapc1:id", -1, &(a->nyapc1__JobAtt::id), "xsd:int"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:jobStat", -1, &(a->nyapc1__JobAtt::jobStat), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:name", -1, &(a->nyapc1__JobAtt::name), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:seed", -1, &(a->nyapc1__JobAtt::seed), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:seedType", -1, &(a->nyapc1__JobAtt::seedType), "xsd:string"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nyapc1:updateTime", -1, &(a->nyapc1__JobAtt::updateTime), "xsd:string"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *nyapc1__JobAtt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_nyapc1__JobAtt(soap, tag, this, type);
}

SOAP_FMAC3 nyapc1__JobAtt * SOAP_FMAC4 soap_in_nyapc1__JobAtt(struct soap *soap, const char *tag, nyapc1__JobAtt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (nyapc1__JobAtt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_nyapc1__JobAtt, sizeof(nyapc1__JobAtt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_nyapc1__JobAtt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (nyapc1__JobAtt *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_comment1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_jobStat1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_seed1 = 1;
	size_t soap_flag_seedType1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:comment", &(a->nyapc1__JobAtt::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap_flag_createTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:createTime", &(a->nyapc1__JobAtt::createTime), "xsd:string"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nyapc1:id", &(a->nyapc1__JobAtt::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_jobStat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:jobStat", &(a->nyapc1__JobAtt::jobStat), "xsd:string"))
				{	soap_flag_jobStat1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:name", &(a->nyapc1__JobAtt::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_seed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:seed", &(a->nyapc1__JobAtt::seed), "xsd:string"))
				{	soap_flag_seed1--;
					continue;
				}
			if (soap_flag_seedType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:seedType", &(a->nyapc1__JobAtt::seedType), "xsd:string"))
				{	soap_flag_seedType1--;
					continue;
				}
			if (soap_flag_updateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nyapc1:updateTime", &(a->nyapc1__JobAtt::updateTime), "xsd:string"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (nyapc1__JobAtt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_nyapc1__JobAtt, 0, sizeof(nyapc1__JobAtt), 0, soap_copy_nyapc1__JobAtt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int nyapc1__JobAtt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_nyapc1__JobAtt);
	if (this->soap_out(soap, tag?tag:"nyapc1:JobAtt", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *nyapc1__JobAtt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_nyapc1__JobAtt(soap, this, tag, type);
}

SOAP_FMAC3 nyapc1__JobAtt * SOAP_FMAC4 soap_get_nyapc1__JobAtt(struct soap *soap, nyapc1__JobAtt *p, const char *tag, const char *type)
{
	if ((p = soap_in_nyapc1__JobAtt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 nyapc1__JobAtt * SOAP_FMAC2 soap_instantiate_nyapc1__JobAtt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_nyapc1__JobAtt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_nyapc1__JobAtt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (nyapc1__JobAtt);
		if (size)
			*size = sizeof(nyapc1__JobAtt);
		((nyapc1__JobAtt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new (nyapc1__JobAtt[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(nyapc1__JobAtt);
		for (int i = 0; i < n; i++)
			((nyapc1__JobAtt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (nyapc1__JobAtt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_nyapc1__JobAtt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying nyapc1__JobAtt %p -> %p\n", q, p));
	*(nyapc1__JobAtt*)p = *(nyapc1__JobAtt*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWraptype(struct soap *soap, struct __nyapc1__getWraptype *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWraptype = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWraptype(struct soap *soap, const struct __nyapc1__getWraptype *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWraptype(soap, &a->nyapc1__getWraptype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWraptype(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWraptype *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWraptype(soap, "nyapc1:getWraptype", -1, &a->nyapc1__getWraptype, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWraptype * SOAP_FMAC4 soap_in___nyapc1__getWraptype(struct soap *soap, const char *tag, struct __nyapc1__getWraptype *a, const char *type)
{
	size_t soap_flag_nyapc1__getWraptype = 1;
	short soap_flag;
	a = (struct __nyapc1__getWraptype *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWraptype, sizeof(struct __nyapc1__getWraptype), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWraptype(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWraptype && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWraptype(soap, "nyapc1:getWraptype", &a->nyapc1__getWraptype, ""))
				{	soap_flag_nyapc1__getWraptype--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWraptype(struct soap *soap, const struct __nyapc1__getWraptype *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWraptype(soap, tag?tag:"-nyapc1:getWraptype", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWraptype * SOAP_FMAC4 soap_get___nyapc1__getWraptype(struct soap *soap, struct __nyapc1__getWraptype *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWraptype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWraptype * SOAP_FMAC2 soap_instantiate___nyapc1__getWraptype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWraptype(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWraptype, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWraptype);
		if (size)
			*size = sizeof(struct __nyapc1__getWraptype);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWraptype[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWraptype);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWraptype*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWraptype(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWraptype %p -> %p\n", q, p));
	*(struct __nyapc1__getWraptype*)p = *(struct __nyapc1__getWraptype*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapId(struct soap *soap, struct __nyapc1__getWrapId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapId(struct soap *soap, const struct __nyapc1__getWrapId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapId(soap, &a->nyapc1__getWrapId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapId(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapId *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapId(soap, "nyapc1:getWrapId", -1, &a->nyapc1__getWrapId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapId * SOAP_FMAC4 soap_in___nyapc1__getWrapId(struct soap *soap, const char *tag, struct __nyapc1__getWrapId *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapId = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapId *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapId, sizeof(struct __nyapc1__getWrapId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapId(soap, "nyapc1:getWrapId", &a->nyapc1__getWrapId, ""))
				{	soap_flag_nyapc1__getWrapId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapId(struct soap *soap, const struct __nyapc1__getWrapId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapId(soap, tag?tag:"-nyapc1:getWrapId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapId * SOAP_FMAC4 soap_get___nyapc1__getWrapId(struct soap *soap, struct __nyapc1__getWrapId *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapId * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapId);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapId);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapId %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapId*)p = *(struct __nyapc1__getWrapId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, struct __nyapc1__getWrapInvalidTaskByJobId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapInvalidTaskByJobId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const struct __nyapc1__getWrapInvalidTaskByJobId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, &a->nyapc1__getWrapInvalidTaskByJobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapInvalidTaskByJobId *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, "nyapc1:getWrapInvalidTaskByJobId", -1, &a->nyapc1__getWrapInvalidTaskByJobId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC4 soap_in___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, struct __nyapc1__getWrapInvalidTaskByJobId *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapInvalidTaskByJobId = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapInvalidTaskByJobId *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId, sizeof(struct __nyapc1__getWrapInvalidTaskByJobId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapInvalidTaskByJobId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapInvalidTaskByJobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, "nyapc1:getWrapInvalidTaskByJobId", &a->nyapc1__getWrapInvalidTaskByJobId, ""))
				{	soap_flag_nyapc1__getWrapInvalidTaskByJobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const struct __nyapc1__getWrapInvalidTaskByJobId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapInvalidTaskByJobId(soap, tag?tag:"-nyapc1:getWrapInvalidTaskByJobId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC4 soap_get___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, struct __nyapc1__getWrapInvalidTaskByJobId *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapInvalidTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapInvalidTaskByJobId * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapInvalidTaskByJobId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapInvalidTaskByJobId);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapInvalidTaskByJobId);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapInvalidTaskByJobId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapInvalidTaskByJobId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapInvalidTaskByJobId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapInvalidTaskByJobId %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapInvalidTaskByJobId*)p = *(struct __nyapc1__getWrapInvalidTaskByJobId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__updateJobUrl(struct soap *soap, struct __nyapc1__updateJobUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__updateJobUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__updateJobUrl(struct soap *soap, const struct __nyapc1__updateJobUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__updateJobUrl(soap, &a->nyapc1__updateJobUrl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__updateJobUrl(struct soap *soap, const char *tag, int id, const struct __nyapc1__updateJobUrl *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__updateJobUrl(soap, "nyapc1:updateJobUrl", -1, &a->nyapc1__updateJobUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateJobUrl * SOAP_FMAC4 soap_in___nyapc1__updateJobUrl(struct soap *soap, const char *tag, struct __nyapc1__updateJobUrl *a, const char *type)
{
	size_t soap_flag_nyapc1__updateJobUrl = 1;
	short soap_flag;
	a = (struct __nyapc1__updateJobUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__updateJobUrl, sizeof(struct __nyapc1__updateJobUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__updateJobUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__updateJobUrl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__updateJobUrl(soap, "nyapc1:updateJobUrl", &a->nyapc1__updateJobUrl, ""))
				{	soap_flag_nyapc1__updateJobUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__updateJobUrl(struct soap *soap, const struct __nyapc1__updateJobUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__updateJobUrl(soap, tag?tag:"-nyapc1:updateJobUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateJobUrl * SOAP_FMAC4 soap_get___nyapc1__updateJobUrl(struct soap *soap, struct __nyapc1__updateJobUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__updateJobUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__updateJobUrl * SOAP_FMAC2 soap_instantiate___nyapc1__updateJobUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__updateJobUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__updateJobUrl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__updateJobUrl);
		if (size)
			*size = sizeof(struct __nyapc1__updateJobUrl);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__updateJobUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__updateJobUrl);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__updateJobUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__updateJobUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__updateJobUrl %p -> %p\n", q, p));
	*(struct __nyapc1__updateJobUrl*)p = *(struct __nyapc1__updateJobUrl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__delJob(struct soap *soap, struct __nyapc1__delJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__delJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__delJob(struct soap *soap, const struct __nyapc1__delJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__delJob(soap, &a->nyapc1__delJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__delJob(struct soap *soap, const char *tag, int id, const struct __nyapc1__delJob *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__delJob(soap, "nyapc1:delJob", -1, &a->nyapc1__delJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__delJob * SOAP_FMAC4 soap_in___nyapc1__delJob(struct soap *soap, const char *tag, struct __nyapc1__delJob *a, const char *type)
{
	size_t soap_flag_nyapc1__delJob = 1;
	short soap_flag;
	a = (struct __nyapc1__delJob *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__delJob, sizeof(struct __nyapc1__delJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__delJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__delJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__delJob(soap, "nyapc1:delJob", &a->nyapc1__delJob, ""))
				{	soap_flag_nyapc1__delJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__delJob(struct soap *soap, const struct __nyapc1__delJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__delJob(soap, tag?tag:"-nyapc1:delJob", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__delJob * SOAP_FMAC4 soap_get___nyapc1__delJob(struct soap *soap, struct __nyapc1__delJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__delJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__delJob * SOAP_FMAC2 soap_instantiate___nyapc1__delJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__delJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__delJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__delJob);
		if (size)
			*size = sizeof(struct __nyapc1__delJob);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__delJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__delJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__delJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__delJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__delJob %p -> %p\n", q, p));
	*(struct __nyapc1__delJob*)p = *(struct __nyapc1__delJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getTaskByJobId(struct soap *soap, struct __nyapc1__getTaskByJobId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getTaskByJobId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getTaskByJobId(struct soap *soap, const struct __nyapc1__getTaskByJobId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getTaskByJobId(soap, &a->nyapc1__getTaskByJobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getTaskByJobId(struct soap *soap, const char *tag, int id, const struct __nyapc1__getTaskByJobId *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getTaskByJobId(soap, "nyapc1:getTaskByJobId", -1, &a->nyapc1__getTaskByJobId, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTaskByJobId * SOAP_FMAC4 soap_in___nyapc1__getTaskByJobId(struct soap *soap, const char *tag, struct __nyapc1__getTaskByJobId *a, const char *type)
{
	size_t soap_flag_nyapc1__getTaskByJobId = 1;
	short soap_flag;
	a = (struct __nyapc1__getTaskByJobId *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getTaskByJobId, sizeof(struct __nyapc1__getTaskByJobId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getTaskByJobId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getTaskByJobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getTaskByJobId(soap, "nyapc1:getTaskByJobId", &a->nyapc1__getTaskByJobId, ""))
				{	soap_flag_nyapc1__getTaskByJobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getTaskByJobId(struct soap *soap, const struct __nyapc1__getTaskByJobId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getTaskByJobId(soap, tag?tag:"-nyapc1:getTaskByJobId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTaskByJobId * SOAP_FMAC4 soap_get___nyapc1__getTaskByJobId(struct soap *soap, struct __nyapc1__getTaskByJobId *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getTaskByJobId * SOAP_FMAC2 soap_instantiate___nyapc1__getTaskByJobId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getTaskByJobId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getTaskByJobId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getTaskByJobId);
		if (size)
			*size = sizeof(struct __nyapc1__getTaskByJobId);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getTaskByJobId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getTaskByJobId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getTaskByJobId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getTaskByJobId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getTaskByJobId %p -> %p\n", q, p));
	*(struct __nyapc1__getTaskByJobId*)p = *(struct __nyapc1__getTaskByJobId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__takeTask(struct soap *soap, struct __nyapc1__takeTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__takeTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__takeTask(struct soap *soap, const struct __nyapc1__takeTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__takeTask(soap, &a->nyapc1__takeTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__takeTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__takeTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__takeTask(soap, "nyapc1:takeTask", -1, &a->nyapc1__takeTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__takeTask * SOAP_FMAC4 soap_in___nyapc1__takeTask(struct soap *soap, const char *tag, struct __nyapc1__takeTask *a, const char *type)
{
	size_t soap_flag_nyapc1__takeTask = 1;
	short soap_flag;
	a = (struct __nyapc1__takeTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__takeTask, sizeof(struct __nyapc1__takeTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__takeTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__takeTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__takeTask(soap, "nyapc1:takeTask", &a->nyapc1__takeTask, ""))
				{	soap_flag_nyapc1__takeTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__takeTask(struct soap *soap, const struct __nyapc1__takeTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__takeTask(soap, tag?tag:"-nyapc1:takeTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__takeTask * SOAP_FMAC4 soap_get___nyapc1__takeTask(struct soap *soap, struct __nyapc1__takeTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__takeTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__takeTask * SOAP_FMAC2 soap_instantiate___nyapc1__takeTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__takeTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__takeTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__takeTask);
		if (size)
			*size = sizeof(struct __nyapc1__takeTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__takeTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__takeTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__takeTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__takeTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__takeTask %p -> %p\n", q, p));
	*(struct __nyapc1__takeTask*)p = *(struct __nyapc1__takeTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapTaskQueue(struct soap *soap, struct __nyapc1__getWrapTaskQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapTaskQueue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapTaskQueue(struct soap *soap, const struct __nyapc1__getWrapTaskQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapTaskQueue(soap, &a->nyapc1__getWrapTaskQueue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapTaskQueue *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapTaskQueue(soap, "nyapc1:getWrapTaskQueue", -1, &a->nyapc1__getWrapTaskQueue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapTaskQueue * SOAP_FMAC4 soap_in___nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, struct __nyapc1__getWrapTaskQueue *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapTaskQueue = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapTaskQueue *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapTaskQueue, sizeof(struct __nyapc1__getWrapTaskQueue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapTaskQueue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapTaskQueue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapTaskQueue(soap, "nyapc1:getWrapTaskQueue", &a->nyapc1__getWrapTaskQueue, ""))
				{	soap_flag_nyapc1__getWrapTaskQueue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapTaskQueue(struct soap *soap, const struct __nyapc1__getWrapTaskQueue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapTaskQueue(soap, tag?tag:"-nyapc1:getWrapTaskQueue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapTaskQueue * SOAP_FMAC4 soap_get___nyapc1__getWrapTaskQueue(struct soap *soap, struct __nyapc1__getWrapTaskQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapTaskQueue * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapTaskQueue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapTaskQueue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapTaskQueue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapTaskQueue);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapTaskQueue);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapTaskQueue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapTaskQueue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapTaskQueue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapTaskQueue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapTaskQueue %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapTaskQueue*)p = *(struct __nyapc1__getWrapTaskQueue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getTaskQueue(struct soap *soap, struct __nyapc1__getTaskQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getTaskQueue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getTaskQueue(struct soap *soap, const struct __nyapc1__getTaskQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getTaskQueue(soap, &a->nyapc1__getTaskQueue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getTaskQueue(struct soap *soap, const char *tag, int id, const struct __nyapc1__getTaskQueue *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getTaskQueue(soap, "nyapc1:getTaskQueue", -1, &a->nyapc1__getTaskQueue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTaskQueue * SOAP_FMAC4 soap_in___nyapc1__getTaskQueue(struct soap *soap, const char *tag, struct __nyapc1__getTaskQueue *a, const char *type)
{
	size_t soap_flag_nyapc1__getTaskQueue = 1;
	short soap_flag;
	a = (struct __nyapc1__getTaskQueue *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getTaskQueue, sizeof(struct __nyapc1__getTaskQueue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getTaskQueue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getTaskQueue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getTaskQueue(soap, "nyapc1:getTaskQueue", &a->nyapc1__getTaskQueue, ""))
				{	soap_flag_nyapc1__getTaskQueue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getTaskQueue(struct soap *soap, const struct __nyapc1__getTaskQueue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getTaskQueue(soap, tag?tag:"-nyapc1:getTaskQueue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTaskQueue * SOAP_FMAC4 soap_get___nyapc1__getTaskQueue(struct soap *soap, struct __nyapc1__getTaskQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getTaskQueue * SOAP_FMAC2 soap_instantiate___nyapc1__getTaskQueue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getTaskQueue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getTaskQueue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getTaskQueue);
		if (size)
			*size = sizeof(struct __nyapc1__getTaskQueue);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getTaskQueue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getTaskQueue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getTaskQueue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getTaskQueue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getTaskQueue %p -> %p\n", q, p));
	*(struct __nyapc1__getTaskQueue*)p = *(struct __nyapc1__getTaskQueue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__updateWrapGen(struct soap *soap, struct __nyapc1__updateWrapGen *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__updateWrapGen = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__updateWrapGen(struct soap *soap, const struct __nyapc1__updateWrapGen *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__updateWrapGen(soap, &a->nyapc1__updateWrapGen);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__updateWrapGen(struct soap *soap, const char *tag, int id, const struct __nyapc1__updateWrapGen *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__updateWrapGen(soap, "nyapc1:updateWrapGen", -1, &a->nyapc1__updateWrapGen, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapGen * SOAP_FMAC4 soap_in___nyapc1__updateWrapGen(struct soap *soap, const char *tag, struct __nyapc1__updateWrapGen *a, const char *type)
{
	size_t soap_flag_nyapc1__updateWrapGen = 1;
	short soap_flag;
	a = (struct __nyapc1__updateWrapGen *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__updateWrapGen, sizeof(struct __nyapc1__updateWrapGen), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__updateWrapGen(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__updateWrapGen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__updateWrapGen(soap, "nyapc1:updateWrapGen", &a->nyapc1__updateWrapGen, ""))
				{	soap_flag_nyapc1__updateWrapGen--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__updateWrapGen(struct soap *soap, const struct __nyapc1__updateWrapGen *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__updateWrapGen(soap, tag?tag:"-nyapc1:updateWrapGen", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapGen * SOAP_FMAC4 soap_get___nyapc1__updateWrapGen(struct soap *soap, struct __nyapc1__updateWrapGen *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__updateWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__updateWrapGen * SOAP_FMAC2 soap_instantiate___nyapc1__updateWrapGen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__updateWrapGen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__updateWrapGen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapGen);
		if (size)
			*size = sizeof(struct __nyapc1__updateWrapGen);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapGen[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__updateWrapGen);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__updateWrapGen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__updateWrapGen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__updateWrapGen %p -> %p\n", q, p));
	*(struct __nyapc1__updateWrapGen*)p = *(struct __nyapc1__updateWrapGen*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapGen(struct soap *soap, struct __nyapc1__getWrapGen *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapGen = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapGen(struct soap *soap, const struct __nyapc1__getWrapGen *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapGen(soap, &a->nyapc1__getWrapGen);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapGen(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapGen *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapGen(soap, "nyapc1:getWrapGen", -1, &a->nyapc1__getWrapGen, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapGen * SOAP_FMAC4 soap_in___nyapc1__getWrapGen(struct soap *soap, const char *tag, struct __nyapc1__getWrapGen *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapGen = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapGen *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapGen, sizeof(struct __nyapc1__getWrapGen), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapGen(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapGen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapGen(soap, "nyapc1:getWrapGen", &a->nyapc1__getWrapGen, ""))
				{	soap_flag_nyapc1__getWrapGen--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapGen(struct soap *soap, const struct __nyapc1__getWrapGen *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapGen(soap, tag?tag:"-nyapc1:getWrapGen", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapGen * SOAP_FMAC4 soap_get___nyapc1__getWrapGen(struct soap *soap, struct __nyapc1__getWrapGen *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapGen * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapGen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapGen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapGen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapGen);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapGen);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapGen[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapGen);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapGen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapGen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapGen %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapGen*)p = *(struct __nyapc1__getWrapGen*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getJobsWrapStatInvalid(struct soap *soap, struct __nyapc1__getJobsWrapStatInvalid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getJobsWrapStatInvalid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getJobsWrapStatInvalid(struct soap *soap, const struct __nyapc1__getJobsWrapStatInvalid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, &a->nyapc1__getJobsWrapStatInvalid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, int id, const struct __nyapc1__getJobsWrapStatInvalid *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, "nyapc1:getJobsWrapStatInvalid", -1, &a->nyapc1__getJobsWrapStatInvalid, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobsWrapStatInvalid * SOAP_FMAC4 soap_in___nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, struct __nyapc1__getJobsWrapStatInvalid *a, const char *type)
{
	size_t soap_flag_nyapc1__getJobsWrapStatInvalid = 1;
	short soap_flag;
	a = (struct __nyapc1__getJobsWrapStatInvalid *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getJobsWrapStatInvalid, sizeof(struct __nyapc1__getJobsWrapStatInvalid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getJobsWrapStatInvalid(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getJobsWrapStatInvalid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, "nyapc1:getJobsWrapStatInvalid", &a->nyapc1__getJobsWrapStatInvalid, ""))
				{	soap_flag_nyapc1__getJobsWrapStatInvalid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getJobsWrapStatInvalid(struct soap *soap, const struct __nyapc1__getJobsWrapStatInvalid *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getJobsWrapStatInvalid(soap, tag?tag:"-nyapc1:getJobsWrapStatInvalid", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobsWrapStatInvalid * SOAP_FMAC4 soap_get___nyapc1__getJobsWrapStatInvalid(struct soap *soap, struct __nyapc1__getJobsWrapStatInvalid *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getJobsWrapStatInvalid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getJobsWrapStatInvalid * SOAP_FMAC2 soap_instantiate___nyapc1__getJobsWrapStatInvalid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getJobsWrapStatInvalid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getJobsWrapStatInvalid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getJobsWrapStatInvalid);
		if (size)
			*size = sizeof(struct __nyapc1__getJobsWrapStatInvalid);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getJobsWrapStatInvalid[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getJobsWrapStatInvalid);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getJobsWrapStatInvalid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getJobsWrapStatInvalid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getJobsWrapStatInvalid %p -> %p\n", q, p));
	*(struct __nyapc1__getJobsWrapStatInvalid*)p = *(struct __nyapc1__getJobsWrapStatInvalid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getJobs(struct soap *soap, struct __nyapc1__getJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getJobs(struct soap *soap, const struct __nyapc1__getJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getJobs(soap, &a->nyapc1__getJobs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getJobs(struct soap *soap, const char *tag, int id, const struct __nyapc1__getJobs *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getJobs(soap, "nyapc1:getJobs", -1, &a->nyapc1__getJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobs * SOAP_FMAC4 soap_in___nyapc1__getJobs(struct soap *soap, const char *tag, struct __nyapc1__getJobs *a, const char *type)
{
	size_t soap_flag_nyapc1__getJobs = 1;
	short soap_flag;
	a = (struct __nyapc1__getJobs *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getJobs, sizeof(struct __nyapc1__getJobs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getJobs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getJobs(soap, "nyapc1:getJobs", &a->nyapc1__getJobs, ""))
				{	soap_flag_nyapc1__getJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getJobs(struct soap *soap, const struct __nyapc1__getJobs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getJobs(soap, tag?tag:"-nyapc1:getJobs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobs * SOAP_FMAC4 soap_get___nyapc1__getJobs(struct soap *soap, struct __nyapc1__getJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getJobs * SOAP_FMAC2 soap_instantiate___nyapc1__getJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getJobs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getJobs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getJobs);
		if (size)
			*size = sizeof(struct __nyapc1__getJobs);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getJobs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getJobs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getJobs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getJobs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getJobs %p -> %p\n", q, p));
	*(struct __nyapc1__getJobs*)p = *(struct __nyapc1__getJobs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getJobID(struct soap *soap, struct __nyapc1__getJobID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getJobID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getJobID(struct soap *soap, const struct __nyapc1__getJobID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getJobID(soap, &a->nyapc1__getJobID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getJobID(struct soap *soap, const char *tag, int id, const struct __nyapc1__getJobID *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getJobID(soap, "nyapc1:getJobID", -1, &a->nyapc1__getJobID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobID * SOAP_FMAC4 soap_in___nyapc1__getJobID(struct soap *soap, const char *tag, struct __nyapc1__getJobID *a, const char *type)
{
	size_t soap_flag_nyapc1__getJobID = 1;
	short soap_flag;
	a = (struct __nyapc1__getJobID *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getJobID, sizeof(struct __nyapc1__getJobID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getJobID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getJobID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getJobID(soap, "nyapc1:getJobID", &a->nyapc1__getJobID, ""))
				{	soap_flag_nyapc1__getJobID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getJobID(struct soap *soap, const struct __nyapc1__getJobID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getJobID(soap, tag?tag:"-nyapc1:getJobID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJobID * SOAP_FMAC4 soap_get___nyapc1__getJobID(struct soap *soap, struct __nyapc1__getJobID *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getJobID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getJobID * SOAP_FMAC2 soap_instantiate___nyapc1__getJobID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getJobID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getJobID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getJobID);
		if (size)
			*size = sizeof(struct __nyapc1__getJobID);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getJobID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getJobID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getJobID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getJobID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getJobID %p -> %p\n", q, p));
	*(struct __nyapc1__getJobID*)p = *(struct __nyapc1__getJobID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__putResult(struct soap *soap, struct __nyapc1__putResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__putResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__putResult(struct soap *soap, const struct __nyapc1__putResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__putResult(soap, &a->nyapc1__putResult);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__putResult(struct soap *soap, const char *tag, int id, const struct __nyapc1__putResult *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__putResult(soap, "nyapc1:putResult", -1, &a->nyapc1__putResult, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__putResult * SOAP_FMAC4 soap_in___nyapc1__putResult(struct soap *soap, const char *tag, struct __nyapc1__putResult *a, const char *type)
{
	size_t soap_flag_nyapc1__putResult = 1;
	short soap_flag;
	a = (struct __nyapc1__putResult *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__putResult, sizeof(struct __nyapc1__putResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__putResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__putResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__putResult(soap, "nyapc1:putResult", &a->nyapc1__putResult, ""))
				{	soap_flag_nyapc1__putResult--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__putResult(struct soap *soap, const struct __nyapc1__putResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__putResult(soap, tag?tag:"-nyapc1:putResult", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__putResult * SOAP_FMAC4 soap_get___nyapc1__putResult(struct soap *soap, struct __nyapc1__putResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__putResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__putResult * SOAP_FMAC2 soap_instantiate___nyapc1__putResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__putResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__putResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__putResult);
		if (size)
			*size = sizeof(struct __nyapc1__putResult);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__putResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__putResult);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__putResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__putResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__putResult %p -> %p\n", q, p));
	*(struct __nyapc1__putResult*)p = *(struct __nyapc1__putResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getStat(struct soap *soap, struct __nyapc1__getStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getStat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getStat(struct soap *soap, const struct __nyapc1__getStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getStat(soap, &a->nyapc1__getStat);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getStat(struct soap *soap, const char *tag, int id, const struct __nyapc1__getStat *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getStat(soap, "nyapc1:getStat", -1, &a->nyapc1__getStat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getStat * SOAP_FMAC4 soap_in___nyapc1__getStat(struct soap *soap, const char *tag, struct __nyapc1__getStat *a, const char *type)
{
	size_t soap_flag_nyapc1__getStat = 1;
	short soap_flag;
	a = (struct __nyapc1__getStat *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getStat, sizeof(struct __nyapc1__getStat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getStat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getStat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getStat(soap, "nyapc1:getStat", &a->nyapc1__getStat, ""))
				{	soap_flag_nyapc1__getStat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getStat(struct soap *soap, const struct __nyapc1__getStat *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getStat(soap, tag?tag:"-nyapc1:getStat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getStat * SOAP_FMAC4 soap_get___nyapc1__getStat(struct soap *soap, struct __nyapc1__getStat *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getStat * SOAP_FMAC2 soap_instantiate___nyapc1__getStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getStat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getStat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getStat);
		if (size)
			*size = sizeof(struct __nyapc1__getStat);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getStat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getStat);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getStat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getStat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getStat %p -> %p\n", q, p));
	*(struct __nyapc1__getStat*)p = *(struct __nyapc1__getStat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__updateWrapperCheckOk(struct soap *soap, struct __nyapc1__updateWrapperCheckOk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__updateWrapperCheckOk = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__updateWrapperCheckOk(struct soap *soap, const struct __nyapc1__updateWrapperCheckOk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__updateWrapperCheckOk(soap, &a->nyapc1__updateWrapperCheckOk);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, int id, const struct __nyapc1__updateWrapperCheckOk *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__updateWrapperCheckOk(soap, "nyapc1:updateWrapperCheckOk", -1, &a->nyapc1__updateWrapperCheckOk, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapperCheckOk * SOAP_FMAC4 soap_in___nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, struct __nyapc1__updateWrapperCheckOk *a, const char *type)
{
	size_t soap_flag_nyapc1__updateWrapperCheckOk = 1;
	short soap_flag;
	a = (struct __nyapc1__updateWrapperCheckOk *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__updateWrapperCheckOk, sizeof(struct __nyapc1__updateWrapperCheckOk), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__updateWrapperCheckOk(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__updateWrapperCheckOk && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__updateWrapperCheckOk(soap, "nyapc1:updateWrapperCheckOk", &a->nyapc1__updateWrapperCheckOk, ""))
				{	soap_flag_nyapc1__updateWrapperCheckOk--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__updateWrapperCheckOk(struct soap *soap, const struct __nyapc1__updateWrapperCheckOk *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__updateWrapperCheckOk(soap, tag?tag:"-nyapc1:updateWrapperCheckOk", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapperCheckOk * SOAP_FMAC4 soap_get___nyapc1__updateWrapperCheckOk(struct soap *soap, struct __nyapc1__updateWrapperCheckOk *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__updateWrapperCheckOk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__updateWrapperCheckOk * SOAP_FMAC2 soap_instantiate___nyapc1__updateWrapperCheckOk(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__updateWrapperCheckOk(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__updateWrapperCheckOk, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapperCheckOk);
		if (size)
			*size = sizeof(struct __nyapc1__updateWrapperCheckOk);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapperCheckOk[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__updateWrapperCheckOk);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__updateWrapperCheckOk*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__updateWrapperCheckOk(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__updateWrapperCheckOk %p -> %p\n", q, p));
	*(struct __nyapc1__updateWrapperCheckOk*)p = *(struct __nyapc1__updateWrapperCheckOk*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__updateWrapper(struct soap *soap, struct __nyapc1__updateWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__updateWrapper = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__updateWrapper(struct soap *soap, const struct __nyapc1__updateWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__updateWrapper(soap, &a->nyapc1__updateWrapper);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__updateWrapper(struct soap *soap, const char *tag, int id, const struct __nyapc1__updateWrapper *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__updateWrapper(soap, "nyapc1:updateWrapper", -1, &a->nyapc1__updateWrapper, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapper * SOAP_FMAC4 soap_in___nyapc1__updateWrapper(struct soap *soap, const char *tag, struct __nyapc1__updateWrapper *a, const char *type)
{
	size_t soap_flag_nyapc1__updateWrapper = 1;
	short soap_flag;
	a = (struct __nyapc1__updateWrapper *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__updateWrapper, sizeof(struct __nyapc1__updateWrapper), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__updateWrapper(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__updateWrapper && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__updateWrapper(soap, "nyapc1:updateWrapper", &a->nyapc1__updateWrapper, ""))
				{	soap_flag_nyapc1__updateWrapper--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__updateWrapper(struct soap *soap, const struct __nyapc1__updateWrapper *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__updateWrapper(soap, tag?tag:"-nyapc1:updateWrapper", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateWrapper * SOAP_FMAC4 soap_get___nyapc1__updateWrapper(struct soap *soap, struct __nyapc1__updateWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__updateWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__updateWrapper * SOAP_FMAC2 soap_instantiate___nyapc1__updateWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__updateWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__updateWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapper);
		if (size)
			*size = sizeof(struct __nyapc1__updateWrapper);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__updateWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__updateWrapper);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__updateWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__updateWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__updateWrapper %p -> %p\n", q, p));
	*(struct __nyapc1__updateWrapper*)p = *(struct __nyapc1__updateWrapper*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapInvalidTask(struct soap *soap, struct __nyapc1__getWrapInvalidTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapInvalidTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapInvalidTask(struct soap *soap, const struct __nyapc1__getWrapInvalidTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapInvalidTask(soap, &a->nyapc1__getWrapInvalidTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapInvalidTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTask(soap, "nyapc1:getWrapInvalidTask", -1, &a->nyapc1__getWrapInvalidTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapInvalidTask * SOAP_FMAC4 soap_in___nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, struct __nyapc1__getWrapInvalidTask *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapInvalidTask = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapInvalidTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapInvalidTask, sizeof(struct __nyapc1__getWrapInvalidTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapInvalidTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapInvalidTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapInvalidTask(soap, "nyapc1:getWrapInvalidTask", &a->nyapc1__getWrapInvalidTask, ""))
				{	soap_flag_nyapc1__getWrapInvalidTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapInvalidTask(struct soap *soap, const struct __nyapc1__getWrapInvalidTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapInvalidTask(soap, tag?tag:"-nyapc1:getWrapInvalidTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapInvalidTask * SOAP_FMAC4 soap_get___nyapc1__getWrapInvalidTask(struct soap *soap, struct __nyapc1__getWrapInvalidTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapInvalidTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapInvalidTask * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapInvalidTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapInvalidTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapInvalidTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapInvalidTask);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapInvalidTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapInvalidTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapInvalidTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapInvalidTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapInvalidTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapInvalidTask %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapInvalidTask*)p = *(struct __nyapc1__getWrapInvalidTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__takeWrapTask(struct soap *soap, struct __nyapc1__takeWrapTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__takeWrapTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__takeWrapTask(struct soap *soap, const struct __nyapc1__takeWrapTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__takeWrapTask(soap, &a->nyapc1__takeWrapTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__takeWrapTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__takeWrapTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__takeWrapTask(soap, "nyapc1:takeWrapTask", -1, &a->nyapc1__takeWrapTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__takeWrapTask * SOAP_FMAC4 soap_in___nyapc1__takeWrapTask(struct soap *soap, const char *tag, struct __nyapc1__takeWrapTask *a, const char *type)
{
	size_t soap_flag_nyapc1__takeWrapTask = 1;
	short soap_flag;
	a = (struct __nyapc1__takeWrapTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__takeWrapTask, sizeof(struct __nyapc1__takeWrapTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__takeWrapTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__takeWrapTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__takeWrapTask(soap, "nyapc1:takeWrapTask", &a->nyapc1__takeWrapTask, ""))
				{	soap_flag_nyapc1__takeWrapTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__takeWrapTask(struct soap *soap, const struct __nyapc1__takeWrapTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__takeWrapTask(soap, tag?tag:"-nyapc1:takeWrapTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__takeWrapTask * SOAP_FMAC4 soap_get___nyapc1__takeWrapTask(struct soap *soap, struct __nyapc1__takeWrapTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__takeWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__takeWrapTask * SOAP_FMAC2 soap_instantiate___nyapc1__takeWrapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__takeWrapTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__takeWrapTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__takeWrapTask);
		if (size)
			*size = sizeof(struct __nyapc1__takeWrapTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__takeWrapTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__takeWrapTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__takeWrapTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__takeWrapTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__takeWrapTask %p -> %p\n", q, p));
	*(struct __nyapc1__takeWrapTask*)p = *(struct __nyapc1__takeWrapTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapTask(struct soap *soap, struct __nyapc1__getWrapTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapTask(struct soap *soap, const struct __nyapc1__getWrapTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapTask(soap, &a->nyapc1__getWrapTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapTask(soap, "nyapc1:getWrapTask", -1, &a->nyapc1__getWrapTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapTask * SOAP_FMAC4 soap_in___nyapc1__getWrapTask(struct soap *soap, const char *tag, struct __nyapc1__getWrapTask *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapTask = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapTask, sizeof(struct __nyapc1__getWrapTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapTask(soap, "nyapc1:getWrapTask", &a->nyapc1__getWrapTask, ""))
				{	soap_flag_nyapc1__getWrapTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapTask(struct soap *soap, const struct __nyapc1__getWrapTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapTask(soap, tag?tag:"-nyapc1:getWrapTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapTask * SOAP_FMAC4 soap_get___nyapc1__getWrapTask(struct soap *soap, struct __nyapc1__getWrapTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapTask * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapTask);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapTask %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapTask*)p = *(struct __nyapc1__getWrapTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getTask(struct soap *soap, struct __nyapc1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getTask(struct soap *soap, const struct __nyapc1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getTask(soap, &a->nyapc1__getTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__getTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getTask(soap, "nyapc1:getTask", -1, &a->nyapc1__getTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTask * SOAP_FMAC4 soap_in___nyapc1__getTask(struct soap *soap, const char *tag, struct __nyapc1__getTask *a, const char *type)
{
	size_t soap_flag_nyapc1__getTask = 1;
	short soap_flag;
	a = (struct __nyapc1__getTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getTask, sizeof(struct __nyapc1__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getTask(soap, "nyapc1:getTask", &a->nyapc1__getTask, ""))
				{	soap_flag_nyapc1__getTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getTask(struct soap *soap, const struct __nyapc1__getTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getTask(soap, tag?tag:"-nyapc1:getTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getTask * SOAP_FMAC4 soap_get___nyapc1__getTask(struct soap *soap, struct __nyapc1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getTask * SOAP_FMAC2 soap_instantiate___nyapc1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getTask);
		if (size)
			*size = sizeof(struct __nyapc1__getTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getTask %p -> %p\n", q, p));
	*(struct __nyapc1__getTask*)p = *(struct __nyapc1__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__addWrapper(struct soap *soap, struct __nyapc1__addWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__addWrapper = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__addWrapper(struct soap *soap, const struct __nyapc1__addWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__addWrapper(soap, &a->nyapc1__addWrapper);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__addWrapper(struct soap *soap, const char *tag, int id, const struct __nyapc1__addWrapper *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__addWrapper(soap, "nyapc1:addWrapper", -1, &a->nyapc1__addWrapper, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__addWrapper * SOAP_FMAC4 soap_in___nyapc1__addWrapper(struct soap *soap, const char *tag, struct __nyapc1__addWrapper *a, const char *type)
{
	size_t soap_flag_nyapc1__addWrapper = 1;
	short soap_flag;
	a = (struct __nyapc1__addWrapper *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__addWrapper, sizeof(struct __nyapc1__addWrapper), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__addWrapper(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__addWrapper && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__addWrapper(soap, "nyapc1:addWrapper", &a->nyapc1__addWrapper, ""))
				{	soap_flag_nyapc1__addWrapper--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__addWrapper(struct soap *soap, const struct __nyapc1__addWrapper *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__addWrapper(soap, tag?tag:"-nyapc1:addWrapper", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__addWrapper * SOAP_FMAC4 soap_get___nyapc1__addWrapper(struct soap *soap, struct __nyapc1__addWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__addWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__addWrapper * SOAP_FMAC2 soap_instantiate___nyapc1__addWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__addWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__addWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__addWrapper);
		if (size)
			*size = sizeof(struct __nyapc1__addWrapper);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__addWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__addWrapper);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__addWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__addWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__addWrapper %p -> %p\n", q, p));
	*(struct __nyapc1__addWrapper*)p = *(struct __nyapc1__addWrapper*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getWrapper(struct soap *soap, struct __nyapc1__getWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getWrapper = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getWrapper(struct soap *soap, const struct __nyapc1__getWrapper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getWrapper(soap, &a->nyapc1__getWrapper);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getWrapper(struct soap *soap, const char *tag, int id, const struct __nyapc1__getWrapper *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getWrapper(soap, "nyapc1:getWrapper", -1, &a->nyapc1__getWrapper, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapper * SOAP_FMAC4 soap_in___nyapc1__getWrapper(struct soap *soap, const char *tag, struct __nyapc1__getWrapper *a, const char *type)
{
	size_t soap_flag_nyapc1__getWrapper = 1;
	short soap_flag;
	a = (struct __nyapc1__getWrapper *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getWrapper, sizeof(struct __nyapc1__getWrapper), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getWrapper(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getWrapper && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getWrapper(soap, "nyapc1:getWrapper", &a->nyapc1__getWrapper, ""))
				{	soap_flag_nyapc1__getWrapper--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getWrapper(struct soap *soap, const struct __nyapc1__getWrapper *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getWrapper(soap, tag?tag:"-nyapc1:getWrapper", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getWrapper * SOAP_FMAC4 soap_get___nyapc1__getWrapper(struct soap *soap, struct __nyapc1__getWrapper *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getWrapper * SOAP_FMAC2 soap_instantiate___nyapc1__getWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getWrapper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapper);
		if (size)
			*size = sizeof(struct __nyapc1__getWrapper);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getWrapper[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getWrapper);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getWrapper %p -> %p\n", q, p));
	*(struct __nyapc1__getWrapper*)p = *(struct __nyapc1__getWrapper*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__updateJob(struct soap *soap, struct __nyapc1__updateJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__updateJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__updateJob(struct soap *soap, const struct __nyapc1__updateJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__updateJob(soap, &a->nyapc1__updateJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__updateJob(struct soap *soap, const char *tag, int id, const struct __nyapc1__updateJob *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__updateJob(soap, "nyapc1:updateJob", -1, &a->nyapc1__updateJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateJob * SOAP_FMAC4 soap_in___nyapc1__updateJob(struct soap *soap, const char *tag, struct __nyapc1__updateJob *a, const char *type)
{
	size_t soap_flag_nyapc1__updateJob = 1;
	short soap_flag;
	a = (struct __nyapc1__updateJob *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__updateJob, sizeof(struct __nyapc1__updateJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__updateJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__updateJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__updateJob(soap, "nyapc1:updateJob", &a->nyapc1__updateJob, ""))
				{	soap_flag_nyapc1__updateJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__updateJob(struct soap *soap, const struct __nyapc1__updateJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__updateJob(soap, tag?tag:"-nyapc1:updateJob", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__updateJob * SOAP_FMAC4 soap_get___nyapc1__updateJob(struct soap *soap, struct __nyapc1__updateJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__updateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__updateJob * SOAP_FMAC2 soap_instantiate___nyapc1__updateJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__updateJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__updateJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__updateJob);
		if (size)
			*size = sizeof(struct __nyapc1__updateJob);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__updateJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__updateJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__updateJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__updateJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__updateJob %p -> %p\n", q, p));
	*(struct __nyapc1__updateJob*)p = *(struct __nyapc1__updateJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__hasTask(struct soap *soap, struct __nyapc1__hasTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__hasTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__hasTask(struct soap *soap, const struct __nyapc1__hasTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__hasTask(soap, &a->nyapc1__hasTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__hasTask(struct soap *soap, const char *tag, int id, const struct __nyapc1__hasTask *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__hasTask(soap, "nyapc1:hasTask", -1, &a->nyapc1__hasTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__hasTask * SOAP_FMAC4 soap_in___nyapc1__hasTask(struct soap *soap, const char *tag, struct __nyapc1__hasTask *a, const char *type)
{
	size_t soap_flag_nyapc1__hasTask = 1;
	short soap_flag;
	a = (struct __nyapc1__hasTask *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__hasTask, sizeof(struct __nyapc1__hasTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__hasTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__hasTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__hasTask(soap, "nyapc1:hasTask", &a->nyapc1__hasTask, ""))
				{	soap_flag_nyapc1__hasTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__hasTask(struct soap *soap, const struct __nyapc1__hasTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__hasTask(soap, tag?tag:"-nyapc1:hasTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__hasTask * SOAP_FMAC4 soap_get___nyapc1__hasTask(struct soap *soap, struct __nyapc1__hasTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__hasTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__hasTask * SOAP_FMAC2 soap_instantiate___nyapc1__hasTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__hasTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__hasTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__hasTask);
		if (size)
			*size = sizeof(struct __nyapc1__hasTask);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__hasTask[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__hasTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__hasTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__hasTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__hasTask %p -> %p\n", q, p));
	*(struct __nyapc1__hasTask*)p = *(struct __nyapc1__hasTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__addJob(struct soap *soap, struct __nyapc1__addJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__addJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__addJob(struct soap *soap, const struct __nyapc1__addJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__addJob(soap, &a->nyapc1__addJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__addJob(struct soap *soap, const char *tag, int id, const struct __nyapc1__addJob *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__addJob(soap, "nyapc1:addJob", -1, &a->nyapc1__addJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__addJob * SOAP_FMAC4 soap_in___nyapc1__addJob(struct soap *soap, const char *tag, struct __nyapc1__addJob *a, const char *type)
{
	size_t soap_flag_nyapc1__addJob = 1;
	short soap_flag;
	a = (struct __nyapc1__addJob *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__addJob, sizeof(struct __nyapc1__addJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__addJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__addJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__addJob(soap, "nyapc1:addJob", &a->nyapc1__addJob, ""))
				{	soap_flag_nyapc1__addJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__addJob(struct soap *soap, const struct __nyapc1__addJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__addJob(soap, tag?tag:"-nyapc1:addJob", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__addJob * SOAP_FMAC4 soap_get___nyapc1__addJob(struct soap *soap, struct __nyapc1__addJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__addJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__addJob * SOAP_FMAC2 soap_instantiate___nyapc1__addJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__addJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__addJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__addJob);
		if (size)
			*size = sizeof(struct __nyapc1__addJob);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__addJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__addJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__addJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__addJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__addJob %p -> %p\n", q, p));
	*(struct __nyapc1__addJob*)p = *(struct __nyapc1__addJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getJob(struct soap *soap, struct __nyapc1__getJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getJob(struct soap *soap, const struct __nyapc1__getJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getJob(soap, &a->nyapc1__getJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getJob(struct soap *soap, const char *tag, int id, const struct __nyapc1__getJob *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getJob(soap, "nyapc1:getJob", -1, &a->nyapc1__getJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJob * SOAP_FMAC4 soap_in___nyapc1__getJob(struct soap *soap, const char *tag, struct __nyapc1__getJob *a, const char *type)
{
	size_t soap_flag_nyapc1__getJob = 1;
	short soap_flag;
	a = (struct __nyapc1__getJob *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getJob, sizeof(struct __nyapc1__getJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getJob(soap, "nyapc1:getJob", &a->nyapc1__getJob, ""))
				{	soap_flag_nyapc1__getJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getJob(struct soap *soap, const struct __nyapc1__getJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getJob(soap, tag?tag:"-nyapc1:getJob", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getJob * SOAP_FMAC4 soap_get___nyapc1__getJob(struct soap *soap, struct __nyapc1__getJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getJob * SOAP_FMAC2 soap_instantiate___nyapc1__getJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getJob);
		if (size)
			*size = sizeof(struct __nyapc1__getJob);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getJob %p -> %p\n", q, p));
	*(struct __nyapc1__getJob*)p = *(struct __nyapc1__getJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__getVersion(struct soap *soap, struct __nyapc1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__getVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__getVersion(struct soap *soap, const struct __nyapc1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__getVersion(soap, &a->nyapc1__getVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__getVersion(struct soap *soap, const char *tag, int id, const struct __nyapc1__getVersion *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__getVersion(soap, "nyapc1:getVersion", -1, &a->nyapc1__getVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getVersion * SOAP_FMAC4 soap_in___nyapc1__getVersion(struct soap *soap, const char *tag, struct __nyapc1__getVersion *a, const char *type)
{
	size_t soap_flag_nyapc1__getVersion = 1;
	short soap_flag;
	a = (struct __nyapc1__getVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__getVersion, sizeof(struct __nyapc1__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__getVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__getVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__getVersion(soap, "nyapc1:getVersion", &a->nyapc1__getVersion, ""))
				{	soap_flag_nyapc1__getVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__getVersion(struct soap *soap, const struct __nyapc1__getVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__getVersion(soap, tag?tag:"-nyapc1:getVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__getVersion * SOAP_FMAC4 soap_get___nyapc1__getVersion(struct soap *soap, struct __nyapc1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__getVersion * SOAP_FMAC2 soap_instantiate___nyapc1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__getVersion);
		if (size)
			*size = sizeof(struct __nyapc1__getVersion);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__getVersion %p -> %p\n", q, p));
	*(struct __nyapc1__getVersion*)p = *(struct __nyapc1__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___nyapc1__add(struct soap *soap, struct __nyapc1__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->nyapc1__add = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nyapc1__add(struct soap *soap, const struct __nyapc1__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_nyapc1__add(soap, &a->nyapc1__add);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___nyapc1__add(struct soap *soap, const char *tag, int id, const struct __nyapc1__add *a, const char *type)
{
	if (soap_out_PointerTo_nyapc1__add(soap, "nyapc1:add", -1, &a->nyapc1__add, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__add * SOAP_FMAC4 soap_in___nyapc1__add(struct soap *soap, const char *tag, struct __nyapc1__add *a, const char *type)
{
	size_t soap_flag_nyapc1__add = 1;
	short soap_flag;
	a = (struct __nyapc1__add *)soap_id_enter(soap, "", a, SOAP_TYPE___nyapc1__add, sizeof(struct __nyapc1__add), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___nyapc1__add(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nyapc1__add && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_nyapc1__add(soap, "nyapc1:add", &a->nyapc1__add, ""))
				{	soap_flag_nyapc1__add--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___nyapc1__add(struct soap *soap, const struct __nyapc1__add *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___nyapc1__add(soap, tag?tag:"-nyapc1:add", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __nyapc1__add * SOAP_FMAC4 soap_get___nyapc1__add(struct soap *soap, struct __nyapc1__add *p, const char *tag, const char *type)
{
	if ((p = soap_in___nyapc1__add(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __nyapc1__add * SOAP_FMAC2 soap_instantiate___nyapc1__add(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___nyapc1__add(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___nyapc1__add, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct __nyapc1__add);
		if (size)
			*size = sizeof(struct __nyapc1__add);
	}
	else
	{	cp->ptr = (void*)new (struct __nyapc1__add[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __nyapc1__add);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __nyapc1__add*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___nyapc1__add(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __nyapc1__add %p -> %p\n", q, p));
	*(struct __nyapc1__add*)p = *(struct __nyapc1__add*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWraptypeResponse(struct soap *soap, _nyapc1__getWraptypeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWraptypeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWraptypeResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWraptypeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWraptypeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWraptypeResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWraptypeResponse(struct soap *soap, const char *tag, _nyapc1__getWraptypeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWraptypeResponse **)soap_malloc(soap, sizeof(_nyapc1__getWraptypeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWraptypeResponse *)soap_instantiate__nyapc1__getWraptypeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWraptypeResponse ** p = (_nyapc1__getWraptypeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWraptypeResponse, sizeof(_nyapc1__getWraptypeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWraptypeResponse(struct soap *soap, _nyapc1__getWraptypeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWraptypeResponse);
	if (soap_out_PointerTo_nyapc1__getWraptypeResponse(soap, tag?tag:"nyapc1:getWraptypeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWraptypeResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWraptypeResponse(struct soap *soap, _nyapc1__getWraptypeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWraptypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWraptype(struct soap *soap, _nyapc1__getWraptype *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWraptype))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWraptype(struct soap *soap, const char *tag, int id, _nyapc1__getWraptype *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWraptype);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWraptype ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWraptype(struct soap *soap, const char *tag, _nyapc1__getWraptype **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWraptype **)soap_malloc(soap, sizeof(_nyapc1__getWraptype *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWraptype *)soap_instantiate__nyapc1__getWraptype(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWraptype ** p = (_nyapc1__getWraptype **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWraptype, sizeof(_nyapc1__getWraptype), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWraptype(struct soap *soap, _nyapc1__getWraptype *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWraptype);
	if (soap_out_PointerTo_nyapc1__getWraptype(soap, tag?tag:"nyapc1:getWraptype", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWraptype ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWraptype(struct soap *soap, _nyapc1__getWraptype **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWraptype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapIdResponse(struct soap *soap, _nyapc1__getWrapIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapIdResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapIdResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapIdResponse(struct soap *soap, const char *tag, _nyapc1__getWrapIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapIdResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapIdResponse *)soap_instantiate__nyapc1__getWrapIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapIdResponse ** p = (_nyapc1__getWrapIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapIdResponse, sizeof(_nyapc1__getWrapIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapIdResponse(struct soap *soap, _nyapc1__getWrapIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapIdResponse);
	if (soap_out_PointerTo_nyapc1__getWrapIdResponse(soap, tag?tag:"nyapc1:getWrapIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapIdResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapIdResponse(struct soap *soap, _nyapc1__getWrapIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapId(struct soap *soap, _nyapc1__getWrapId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapId(struct soap *soap, const char *tag, int id, _nyapc1__getWrapId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapId ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapId(struct soap *soap, const char *tag, _nyapc1__getWrapId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapId **)soap_malloc(soap, sizeof(_nyapc1__getWrapId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapId *)soap_instantiate__nyapc1__getWrapId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapId ** p = (_nyapc1__getWrapId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapId, sizeof(_nyapc1__getWrapId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapId(struct soap *soap, _nyapc1__getWrapId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapId);
	if (soap_out_PointerTo_nyapc1__getWrapId(soap, tag?tag:"nyapc1:getWrapId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapId ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapId(struct soap *soap, _nyapc1__getWrapId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapInvalidTaskByJobIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobIdResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskByJobIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapInvalidTaskByJobIdResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapInvalidTaskByJobIdResponse *)soap_instantiate__nyapc1__getWrapInvalidTaskByJobIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapInvalidTaskByJobIdResponse ** p = (_nyapc1__getWrapInvalidTaskByJobIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse, sizeof(_nyapc1__getWrapInvalidTaskByJobIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse);
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag?tag:"nyapc1:getWrapInvalidTaskByJobIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobIdResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, int id, _nyapc1__getWrapInvalidTaskByJobId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobId ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskByJobId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapInvalidTaskByJobId **)soap_malloc(soap, sizeof(_nyapc1__getWrapInvalidTaskByJobId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapInvalidTaskByJobId *)soap_instantiate__nyapc1__getWrapInvalidTaskByJobId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapInvalidTaskByJobId ** p = (_nyapc1__getWrapInvalidTaskByJobId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId, sizeof(_nyapc1__getWrapInvalidTaskByJobId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskByJobId);
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, tag?tag:"nyapc1:getWrapInvalidTaskByJobId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskByJobId ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapInvalidTaskByJobId(struct soap *soap, _nyapc1__getWrapInvalidTaskByJobId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapInvalidTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateJobUrlResponse(struct soap *soap, _nyapc1__updateJobUrlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateJobUrlResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateJobUrlResponse(struct soap *soap, const char *tag, int id, _nyapc1__updateJobUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateJobUrlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrlResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateJobUrlResponse(struct soap *soap, const char *tag, _nyapc1__updateJobUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateJobUrlResponse **)soap_malloc(soap, sizeof(_nyapc1__updateJobUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateJobUrlResponse *)soap_instantiate__nyapc1__updateJobUrlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateJobUrlResponse ** p = (_nyapc1__updateJobUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateJobUrlResponse, sizeof(_nyapc1__updateJobUrlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateJobUrlResponse(struct soap *soap, _nyapc1__updateJobUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateJobUrlResponse);
	if (soap_out_PointerTo_nyapc1__updateJobUrlResponse(soap, tag?tag:"nyapc1:updateJobUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateJobUrlResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateJobUrlResponse(struct soap *soap, _nyapc1__updateJobUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateJobUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateJobUrl(struct soap *soap, _nyapc1__updateJobUrl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateJobUrl))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateJobUrl(struct soap *soap, const char *tag, int id, _nyapc1__updateJobUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateJobUrl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateJobUrl ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateJobUrl(struct soap *soap, const char *tag, _nyapc1__updateJobUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateJobUrl **)soap_malloc(soap, sizeof(_nyapc1__updateJobUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateJobUrl *)soap_instantiate__nyapc1__updateJobUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateJobUrl ** p = (_nyapc1__updateJobUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateJobUrl, sizeof(_nyapc1__updateJobUrl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateJobUrl(struct soap *soap, _nyapc1__updateJobUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateJobUrl);
	if (soap_out_PointerTo_nyapc1__updateJobUrl(soap, tag?tag:"nyapc1:updateJobUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateJobUrl ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateJobUrl(struct soap *soap, _nyapc1__updateJobUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateJobUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__delJobResponse(struct soap *soap, _nyapc1__delJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__delJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__delJobResponse(struct soap *soap, const char *tag, int id, _nyapc1__delJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__delJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__delJobResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__delJobResponse(struct soap *soap, const char *tag, _nyapc1__delJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__delJobResponse **)soap_malloc(soap, sizeof(_nyapc1__delJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__delJobResponse *)soap_instantiate__nyapc1__delJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__delJobResponse ** p = (_nyapc1__delJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__delJobResponse, sizeof(_nyapc1__delJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__delJobResponse(struct soap *soap, _nyapc1__delJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__delJobResponse);
	if (soap_out_PointerTo_nyapc1__delJobResponse(soap, tag?tag:"nyapc1:delJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__delJobResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__delJobResponse(struct soap *soap, _nyapc1__delJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__delJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__delJob(struct soap *soap, _nyapc1__delJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__delJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__delJob(struct soap *soap, const char *tag, int id, _nyapc1__delJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__delJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__delJob ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__delJob(struct soap *soap, const char *tag, _nyapc1__delJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__delJob **)soap_malloc(soap, sizeof(_nyapc1__delJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__delJob *)soap_instantiate__nyapc1__delJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__delJob ** p = (_nyapc1__delJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__delJob, sizeof(_nyapc1__delJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__delJob(struct soap *soap, _nyapc1__delJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__delJob);
	if (soap_out_PointerTo_nyapc1__delJob(soap, tag?tag:"nyapc1:delJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__delJob ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__delJob(struct soap *soap, _nyapc1__delJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__delJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTaskByJobIdResponse(struct soap *soap, _nyapc1__getTaskByJobIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTaskByJobIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTaskByJobIdResponse(struct soap *soap, const char *tag, int id, _nyapc1__getTaskByJobIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTaskByJobIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobIdResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTaskByJobIdResponse(struct soap *soap, const char *tag, _nyapc1__getTaskByJobIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTaskByJobIdResponse **)soap_malloc(soap, sizeof(_nyapc1__getTaskByJobIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTaskByJobIdResponse *)soap_instantiate__nyapc1__getTaskByJobIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTaskByJobIdResponse ** p = (_nyapc1__getTaskByJobIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTaskByJobIdResponse, sizeof(_nyapc1__getTaskByJobIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTaskByJobIdResponse(struct soap *soap, _nyapc1__getTaskByJobIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTaskByJobIdResponse);
	if (soap_out_PointerTo_nyapc1__getTaskByJobIdResponse(soap, tag?tag:"nyapc1:getTaskByJobIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTaskByJobIdResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTaskByJobIdResponse(struct soap *soap, _nyapc1__getTaskByJobIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTaskByJobIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTaskByJobId(struct soap *soap, _nyapc1__getTaskByJobId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTaskByJobId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTaskByJobId(struct soap *soap, const char *tag, int id, _nyapc1__getTaskByJobId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTaskByJobId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTaskByJobId ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTaskByJobId(struct soap *soap, const char *tag, _nyapc1__getTaskByJobId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTaskByJobId **)soap_malloc(soap, sizeof(_nyapc1__getTaskByJobId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTaskByJobId *)soap_instantiate__nyapc1__getTaskByJobId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTaskByJobId ** p = (_nyapc1__getTaskByJobId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTaskByJobId, sizeof(_nyapc1__getTaskByJobId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTaskByJobId(struct soap *soap, _nyapc1__getTaskByJobId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTaskByJobId);
	if (soap_out_PointerTo_nyapc1__getTaskByJobId(soap, tag?tag:"nyapc1:getTaskByJobId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTaskByJobId ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTaskByJobId(struct soap *soap, _nyapc1__getTaskByJobId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTaskByJobId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__takeTaskResponse(struct soap *soap, _nyapc1__takeTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__takeTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__takeTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__takeTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__takeTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__takeTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__takeTaskResponse(struct soap *soap, const char *tag, _nyapc1__takeTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__takeTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__takeTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__takeTaskResponse *)soap_instantiate__nyapc1__takeTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__takeTaskResponse ** p = (_nyapc1__takeTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__takeTaskResponse, sizeof(_nyapc1__takeTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__takeTaskResponse(struct soap *soap, _nyapc1__takeTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__takeTaskResponse);
	if (soap_out_PointerTo_nyapc1__takeTaskResponse(soap, tag?tag:"nyapc1:takeTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__takeTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__takeTaskResponse(struct soap *soap, _nyapc1__takeTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__takeTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__takeTask(struct soap *soap, _nyapc1__takeTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__takeTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__takeTask(struct soap *soap, const char *tag, int id, _nyapc1__takeTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__takeTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__takeTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__takeTask(struct soap *soap, const char *tag, _nyapc1__takeTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__takeTask **)soap_malloc(soap, sizeof(_nyapc1__takeTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__takeTask *)soap_instantiate__nyapc1__takeTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__takeTask ** p = (_nyapc1__takeTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__takeTask, sizeof(_nyapc1__takeTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__takeTask(struct soap *soap, _nyapc1__takeTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__takeTask);
	if (soap_out_PointerTo_nyapc1__takeTask(soap, tag?tag:"nyapc1:takeTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__takeTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__takeTask(struct soap *soap, _nyapc1__takeTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__takeTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapTaskQueueResponse(struct soap *soap, _nyapc1__getWrapTaskQueueResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapTaskQueueResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapTaskQueueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueueResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapTaskQueueResponse(struct soap *soap, const char *tag, _nyapc1__getWrapTaskQueueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapTaskQueueResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapTaskQueueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapTaskQueueResponse *)soap_instantiate__nyapc1__getWrapTaskQueueResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapTaskQueueResponse ** p = (_nyapc1__getWrapTaskQueueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapTaskQueueResponse, sizeof(_nyapc1__getWrapTaskQueueResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapTaskQueueResponse(struct soap *soap, _nyapc1__getWrapTaskQueueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueueResponse);
	if (soap_out_PointerTo_nyapc1__getWrapTaskQueueResponse(soap, tag?tag:"nyapc1:getWrapTaskQueueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueueResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapTaskQueueResponse(struct soap *soap, _nyapc1__getWrapTaskQueueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapTaskQueueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapTaskQueue(struct soap *soap, _nyapc1__getWrapTaskQueue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapTaskQueue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, int id, _nyapc1__getWrapTaskQueue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapTaskQueue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueue ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapTaskQueue(struct soap *soap, const char *tag, _nyapc1__getWrapTaskQueue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapTaskQueue **)soap_malloc(soap, sizeof(_nyapc1__getWrapTaskQueue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapTaskQueue *)soap_instantiate__nyapc1__getWrapTaskQueue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapTaskQueue ** p = (_nyapc1__getWrapTaskQueue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapTaskQueue, sizeof(_nyapc1__getWrapTaskQueue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapTaskQueue(struct soap *soap, _nyapc1__getWrapTaskQueue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapTaskQueue);
	if (soap_out_PointerTo_nyapc1__getWrapTaskQueue(soap, tag?tag:"nyapc1:getWrapTaskQueue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapTaskQueue ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapTaskQueue(struct soap *soap, _nyapc1__getWrapTaskQueue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTaskQueueResponse(struct soap *soap, _nyapc1__getTaskQueueResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTaskQueueResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTaskQueueResponse(struct soap *soap, const char *tag, int id, _nyapc1__getTaskQueueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTaskQueueResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueueResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTaskQueueResponse(struct soap *soap, const char *tag, _nyapc1__getTaskQueueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTaskQueueResponse **)soap_malloc(soap, sizeof(_nyapc1__getTaskQueueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTaskQueueResponse *)soap_instantiate__nyapc1__getTaskQueueResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTaskQueueResponse ** p = (_nyapc1__getTaskQueueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTaskQueueResponse, sizeof(_nyapc1__getTaskQueueResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTaskQueueResponse(struct soap *soap, _nyapc1__getTaskQueueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTaskQueueResponse);
	if (soap_out_PointerTo_nyapc1__getTaskQueueResponse(soap, tag?tag:"nyapc1:getTaskQueueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTaskQueueResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTaskQueueResponse(struct soap *soap, _nyapc1__getTaskQueueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTaskQueueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTaskQueue(struct soap *soap, _nyapc1__getTaskQueue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTaskQueue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTaskQueue(struct soap *soap, const char *tag, int id, _nyapc1__getTaskQueue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTaskQueue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTaskQueue ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTaskQueue(struct soap *soap, const char *tag, _nyapc1__getTaskQueue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTaskQueue **)soap_malloc(soap, sizeof(_nyapc1__getTaskQueue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTaskQueue *)soap_instantiate__nyapc1__getTaskQueue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTaskQueue ** p = (_nyapc1__getTaskQueue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTaskQueue, sizeof(_nyapc1__getTaskQueue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTaskQueue(struct soap *soap, _nyapc1__getTaskQueue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTaskQueue);
	if (soap_out_PointerTo_nyapc1__getTaskQueue(soap, tag?tag:"nyapc1:getTaskQueue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTaskQueue ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTaskQueue(struct soap *soap, _nyapc1__getTaskQueue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTaskQueue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapGenResponse(struct soap *soap, _nyapc1__updateWrapGenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapGenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapGenResponse(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapGenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapGenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGenResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapGenResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapGenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapGenResponse **)soap_malloc(soap, sizeof(_nyapc1__updateWrapGenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapGenResponse *)soap_instantiate__nyapc1__updateWrapGenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapGenResponse ** p = (_nyapc1__updateWrapGenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapGenResponse, sizeof(_nyapc1__updateWrapGenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapGenResponse(struct soap *soap, _nyapc1__updateWrapGenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapGenResponse);
	if (soap_out_PointerTo_nyapc1__updateWrapGenResponse(soap, tag?tag:"nyapc1:updateWrapGenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapGenResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapGenResponse(struct soap *soap, _nyapc1__updateWrapGenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapGenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapGen(struct soap *soap, _nyapc1__updateWrapGen *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapGen))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapGen(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapGen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapGen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapGen ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapGen(struct soap *soap, const char *tag, _nyapc1__updateWrapGen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapGen **)soap_malloc(soap, sizeof(_nyapc1__updateWrapGen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapGen *)soap_instantiate__nyapc1__updateWrapGen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapGen ** p = (_nyapc1__updateWrapGen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapGen, sizeof(_nyapc1__updateWrapGen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapGen(struct soap *soap, _nyapc1__updateWrapGen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapGen);
	if (soap_out_PointerTo_nyapc1__updateWrapGen(soap, tag?tag:"nyapc1:updateWrapGen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapGen ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapGen(struct soap *soap, _nyapc1__updateWrapGen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapGenResponse(struct soap *soap, _nyapc1__getWrapGenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapGenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapGenResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapGenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapGenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapGenResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapGenResponse(struct soap *soap, const char *tag, _nyapc1__getWrapGenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapGenResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapGenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapGenResponse *)soap_instantiate__nyapc1__getWrapGenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapGenResponse ** p = (_nyapc1__getWrapGenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapGenResponse, sizeof(_nyapc1__getWrapGenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapGenResponse(struct soap *soap, _nyapc1__getWrapGenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapGenResponse);
	if (soap_out_PointerTo_nyapc1__getWrapGenResponse(soap, tag?tag:"nyapc1:getWrapGenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapGenResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapGenResponse(struct soap *soap, _nyapc1__getWrapGenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapGenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapGen(struct soap *soap, _nyapc1__getWrapGen *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapGen))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapGen(struct soap *soap, const char *tag, int id, _nyapc1__getWrapGen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapGen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapGen ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapGen(struct soap *soap, const char *tag, _nyapc1__getWrapGen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapGen **)soap_malloc(soap, sizeof(_nyapc1__getWrapGen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapGen *)soap_instantiate__nyapc1__getWrapGen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapGen ** p = (_nyapc1__getWrapGen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapGen, sizeof(_nyapc1__getWrapGen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapGen(struct soap *soap, _nyapc1__getWrapGen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapGen);
	if (soap_out_PointerTo_nyapc1__getWrapGen(soap, tag?tag:"nyapc1:getWrapGen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapGen ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapGen(struct soap *soap, _nyapc1__getWrapGen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapGen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, _nyapc1__getJobsWrapStatInvalidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, const char *tag, int id, _nyapc1__getJobsWrapStatInvalidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalidResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, const char *tag, _nyapc1__getJobsWrapStatInvalidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobsWrapStatInvalidResponse **)soap_malloc(soap, sizeof(_nyapc1__getJobsWrapStatInvalidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobsWrapStatInvalidResponse *)soap_instantiate__nyapc1__getJobsWrapStatInvalidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobsWrapStatInvalidResponse ** p = (_nyapc1__getJobsWrapStatInvalidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse, sizeof(_nyapc1__getJobsWrapStatInvalidResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, _nyapc1__getJobsWrapStatInvalidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalidResponse);
	if (soap_out_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(soap, tag?tag:"nyapc1:getJobsWrapStatInvalidResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalidResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(struct soap *soap, _nyapc1__getJobsWrapStatInvalidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobsWrapStatInvalidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobsWrapStatInvalid(struct soap *soap, _nyapc1__getJobsWrapStatInvalid *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, int id, _nyapc1__getJobsWrapStatInvalid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalid ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobsWrapStatInvalid(struct soap *soap, const char *tag, _nyapc1__getJobsWrapStatInvalid **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobsWrapStatInvalid **)soap_malloc(soap, sizeof(_nyapc1__getJobsWrapStatInvalid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobsWrapStatInvalid *)soap_instantiate__nyapc1__getJobsWrapStatInvalid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobsWrapStatInvalid ** p = (_nyapc1__getJobsWrapStatInvalid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobsWrapStatInvalid, sizeof(_nyapc1__getJobsWrapStatInvalid), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobsWrapStatInvalid(struct soap *soap, _nyapc1__getJobsWrapStatInvalid *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobsWrapStatInvalid);
	if (soap_out_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, tag?tag:"nyapc1:getJobsWrapStatInvalid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobsWrapStatInvalid ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobsWrapStatInvalid(struct soap *soap, _nyapc1__getJobsWrapStatInvalid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobsWrapStatInvalid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobsResponse(struct soap *soap, _nyapc1__getJobsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobsResponse(struct soap *soap, const char *tag, int id, _nyapc1__getJobsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobsResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobsResponse(struct soap *soap, const char *tag, _nyapc1__getJobsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobsResponse **)soap_malloc(soap, sizeof(_nyapc1__getJobsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobsResponse *)soap_instantiate__nyapc1__getJobsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobsResponse ** p = (_nyapc1__getJobsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobsResponse, sizeof(_nyapc1__getJobsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobsResponse(struct soap *soap, _nyapc1__getJobsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobsResponse);
	if (soap_out_PointerTo_nyapc1__getJobsResponse(soap, tag?tag:"nyapc1:getJobsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobsResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobsResponse(struct soap *soap, _nyapc1__getJobsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobs(struct soap *soap, _nyapc1__getJobs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobs(struct soap *soap, const char *tag, int id, _nyapc1__getJobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobs ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobs(struct soap *soap, const char *tag, _nyapc1__getJobs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobs **)soap_malloc(soap, sizeof(_nyapc1__getJobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobs *)soap_instantiate__nyapc1__getJobs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobs ** p = (_nyapc1__getJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobs, sizeof(_nyapc1__getJobs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobs(struct soap *soap, _nyapc1__getJobs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobs);
	if (soap_out_PointerTo_nyapc1__getJobs(soap, tag?tag:"nyapc1:getJobs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobs ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobs(struct soap *soap, _nyapc1__getJobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobIDResponse(struct soap *soap, _nyapc1__getJobIDResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobIDResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobIDResponse(struct soap *soap, const char *tag, int id, _nyapc1__getJobIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobIDResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobIDResponse(struct soap *soap, const char *tag, _nyapc1__getJobIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobIDResponse **)soap_malloc(soap, sizeof(_nyapc1__getJobIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobIDResponse *)soap_instantiate__nyapc1__getJobIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobIDResponse ** p = (_nyapc1__getJobIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobIDResponse, sizeof(_nyapc1__getJobIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobIDResponse(struct soap *soap, _nyapc1__getJobIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobIDResponse);
	if (soap_out_PointerTo_nyapc1__getJobIDResponse(soap, tag?tag:"nyapc1:getJobIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobIDResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobIDResponse(struct soap *soap, _nyapc1__getJobIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobID(struct soap *soap, _nyapc1__getJobID *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobID))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobID(struct soap *soap, const char *tag, int id, _nyapc1__getJobID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobID ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobID(struct soap *soap, const char *tag, _nyapc1__getJobID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobID **)soap_malloc(soap, sizeof(_nyapc1__getJobID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobID *)soap_instantiate__nyapc1__getJobID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobID ** p = (_nyapc1__getJobID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobID, sizeof(_nyapc1__getJobID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobID(struct soap *soap, _nyapc1__getJobID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobID);
	if (soap_out_PointerTo_nyapc1__getJobID(soap, tag?tag:"nyapc1:getJobID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobID ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobID(struct soap *soap, _nyapc1__getJobID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__putResultResponse(struct soap *soap, _nyapc1__putResultResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__putResultResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__putResultResponse(struct soap *soap, const char *tag, int id, _nyapc1__putResultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__putResultResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__putResultResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__putResultResponse(struct soap *soap, const char *tag, _nyapc1__putResultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__putResultResponse **)soap_malloc(soap, sizeof(_nyapc1__putResultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__putResultResponse *)soap_instantiate__nyapc1__putResultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__putResultResponse ** p = (_nyapc1__putResultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__putResultResponse, sizeof(_nyapc1__putResultResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__putResultResponse(struct soap *soap, _nyapc1__putResultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__putResultResponse);
	if (soap_out_PointerTo_nyapc1__putResultResponse(soap, tag?tag:"nyapc1:putResultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__putResultResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__putResultResponse(struct soap *soap, _nyapc1__putResultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__putResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__putResult(struct soap *soap, _nyapc1__putResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__putResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__putResult(struct soap *soap, const char *tag, int id, _nyapc1__putResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__putResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__putResult ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__putResult(struct soap *soap, const char *tag, _nyapc1__putResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__putResult **)soap_malloc(soap, sizeof(_nyapc1__putResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__putResult *)soap_instantiate__nyapc1__putResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__putResult ** p = (_nyapc1__putResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__putResult, sizeof(_nyapc1__putResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__putResult(struct soap *soap, _nyapc1__putResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__putResult);
	if (soap_out_PointerTo_nyapc1__putResult(soap, tag?tag:"nyapc1:putResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__putResult ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__putResult(struct soap *soap, _nyapc1__putResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__putResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getStatResponse(struct soap *soap, _nyapc1__getStatResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getStatResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getStatResponse(struct soap *soap, const char *tag, int id, _nyapc1__getStatResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getStatResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getStatResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getStatResponse(struct soap *soap, const char *tag, _nyapc1__getStatResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getStatResponse **)soap_malloc(soap, sizeof(_nyapc1__getStatResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getStatResponse *)soap_instantiate__nyapc1__getStatResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getStatResponse ** p = (_nyapc1__getStatResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getStatResponse, sizeof(_nyapc1__getStatResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getStatResponse(struct soap *soap, _nyapc1__getStatResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getStatResponse);
	if (soap_out_PointerTo_nyapc1__getStatResponse(soap, tag?tag:"nyapc1:getStatResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getStatResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getStatResponse(struct soap *soap, _nyapc1__getStatResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getStatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getStat(struct soap *soap, _nyapc1__getStat *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getStat))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getStat(struct soap *soap, const char *tag, int id, _nyapc1__getStat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getStat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getStat ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getStat(struct soap *soap, const char *tag, _nyapc1__getStat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getStat **)soap_malloc(soap, sizeof(_nyapc1__getStat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getStat *)soap_instantiate__nyapc1__getStat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getStat ** p = (_nyapc1__getStat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getStat, sizeof(_nyapc1__getStat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getStat(struct soap *soap, _nyapc1__getStat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getStat);
	if (soap_out_PointerTo_nyapc1__getStat(soap, tag?tag:"nyapc1:getStat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getStat ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getStat(struct soap *soap, _nyapc1__getStat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapperCheckOkResponse(struct soap *soap, _nyapc1__updateWrapperCheckOkResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapperCheckOkResponse(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapperCheckOkResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOkResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapperCheckOkResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapperCheckOkResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapperCheckOkResponse **)soap_malloc(soap, sizeof(_nyapc1__updateWrapperCheckOkResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapperCheckOkResponse *)soap_instantiate__nyapc1__updateWrapperCheckOkResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapperCheckOkResponse ** p = (_nyapc1__updateWrapperCheckOkResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse, sizeof(_nyapc1__updateWrapperCheckOkResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapperCheckOkResponse(struct soap *soap, _nyapc1__updateWrapperCheckOkResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOkResponse);
	if (soap_out_PointerTo_nyapc1__updateWrapperCheckOkResponse(soap, tag?tag:"nyapc1:updateWrapperCheckOkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOkResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapperCheckOkResponse(struct soap *soap, _nyapc1__updateWrapperCheckOkResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapperCheckOkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapperCheckOk(struct soap *soap, _nyapc1__updateWrapperCheckOk *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapperCheckOk))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapperCheckOk *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapperCheckOk);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOk ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapperCheckOk(struct soap *soap, const char *tag, _nyapc1__updateWrapperCheckOk **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapperCheckOk **)soap_malloc(soap, sizeof(_nyapc1__updateWrapperCheckOk *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapperCheckOk *)soap_instantiate__nyapc1__updateWrapperCheckOk(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapperCheckOk ** p = (_nyapc1__updateWrapperCheckOk **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapperCheckOk, sizeof(_nyapc1__updateWrapperCheckOk), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapperCheckOk(struct soap *soap, _nyapc1__updateWrapperCheckOk *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapperCheckOk);
	if (soap_out_PointerTo_nyapc1__updateWrapperCheckOk(soap, tag?tag:"nyapc1:updateWrapperCheckOk", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapperCheckOk ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapperCheckOk(struct soap *soap, _nyapc1__updateWrapperCheckOk **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapperCheckOk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapperResponse(struct soap *soap, _nyapc1__updateWrapperResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapperResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapperResponse(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapperResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapperResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapperResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapperResponse(struct soap *soap, const char *tag, _nyapc1__updateWrapperResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapperResponse **)soap_malloc(soap, sizeof(_nyapc1__updateWrapperResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapperResponse *)soap_instantiate__nyapc1__updateWrapperResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapperResponse ** p = (_nyapc1__updateWrapperResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapperResponse, sizeof(_nyapc1__updateWrapperResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapperResponse(struct soap *soap, _nyapc1__updateWrapperResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapperResponse);
	if (soap_out_PointerTo_nyapc1__updateWrapperResponse(soap, tag?tag:"nyapc1:updateWrapperResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapperResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapperResponse(struct soap *soap, _nyapc1__updateWrapperResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateWrapper(struct soap *soap, _nyapc1__updateWrapper *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateWrapper(struct soap *soap, const char *tag, int id, _nyapc1__updateWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateWrapper);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateWrapper ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateWrapper(struct soap *soap, const char *tag, _nyapc1__updateWrapper **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateWrapper **)soap_malloc(soap, sizeof(_nyapc1__updateWrapper *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateWrapper *)soap_instantiate__nyapc1__updateWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateWrapper ** p = (_nyapc1__updateWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateWrapper, sizeof(_nyapc1__updateWrapper), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateWrapper(struct soap *soap, _nyapc1__updateWrapper *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateWrapper);
	if (soap_out_PointerTo_nyapc1__updateWrapper(soap, tag?tag:"nyapc1:updateWrapper", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateWrapper ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateWrapper(struct soap *soap, _nyapc1__updateWrapper **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapInvalidTaskResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapInvalidTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapInvalidTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapInvalidTaskResponse(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapInvalidTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapInvalidTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapInvalidTaskResponse *)soap_instantiate__nyapc1__getWrapInvalidTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapInvalidTaskResponse ** p = (_nyapc1__getWrapInvalidTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse, sizeof(_nyapc1__getWrapInvalidTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapInvalidTaskResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTaskResponse);
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTaskResponse(soap, tag?tag:"nyapc1:getWrapInvalidTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapInvalidTaskResponse(struct soap *soap, _nyapc1__getWrapInvalidTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapInvalidTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapInvalidTask(struct soap *soap, _nyapc1__getWrapInvalidTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapInvalidTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, int id, _nyapc1__getWrapInvalidTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapInvalidTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapInvalidTask(struct soap *soap, const char *tag, _nyapc1__getWrapInvalidTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapInvalidTask **)soap_malloc(soap, sizeof(_nyapc1__getWrapInvalidTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapInvalidTask *)soap_instantiate__nyapc1__getWrapInvalidTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapInvalidTask ** p = (_nyapc1__getWrapInvalidTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapInvalidTask, sizeof(_nyapc1__getWrapInvalidTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapInvalidTask(struct soap *soap, _nyapc1__getWrapInvalidTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapInvalidTask);
	if (soap_out_PointerTo_nyapc1__getWrapInvalidTask(soap, tag?tag:"nyapc1:getWrapInvalidTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapInvalidTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapInvalidTask(struct soap *soap, _nyapc1__getWrapInvalidTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapInvalidTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__takeWrapTaskResponse(struct soap *soap, _nyapc1__takeWrapTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__takeWrapTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__takeWrapTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__takeWrapTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__takeWrapTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__takeWrapTaskResponse(struct soap *soap, const char *tag, _nyapc1__takeWrapTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__takeWrapTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__takeWrapTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__takeWrapTaskResponse *)soap_instantiate__nyapc1__takeWrapTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__takeWrapTaskResponse ** p = (_nyapc1__takeWrapTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__takeWrapTaskResponse, sizeof(_nyapc1__takeWrapTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__takeWrapTaskResponse(struct soap *soap, _nyapc1__takeWrapTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__takeWrapTaskResponse);
	if (soap_out_PointerTo_nyapc1__takeWrapTaskResponse(soap, tag?tag:"nyapc1:takeWrapTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__takeWrapTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__takeWrapTaskResponse(struct soap *soap, _nyapc1__takeWrapTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__takeWrapTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__takeWrapTask(struct soap *soap, _nyapc1__takeWrapTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__takeWrapTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__takeWrapTask(struct soap *soap, const char *tag, int id, _nyapc1__takeWrapTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__takeWrapTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__takeWrapTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__takeWrapTask(struct soap *soap, const char *tag, _nyapc1__takeWrapTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__takeWrapTask **)soap_malloc(soap, sizeof(_nyapc1__takeWrapTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__takeWrapTask *)soap_instantiate__nyapc1__takeWrapTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__takeWrapTask ** p = (_nyapc1__takeWrapTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__takeWrapTask, sizeof(_nyapc1__takeWrapTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__takeWrapTask(struct soap *soap, _nyapc1__takeWrapTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__takeWrapTask);
	if (soap_out_PointerTo_nyapc1__takeWrapTask(soap, tag?tag:"nyapc1:takeWrapTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__takeWrapTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__takeWrapTask(struct soap *soap, _nyapc1__takeWrapTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__takeWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapTaskResponse(struct soap *soap, _nyapc1__getWrapTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapTaskResponse(struct soap *soap, const char *tag, _nyapc1__getWrapTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapTaskResponse *)soap_instantiate__nyapc1__getWrapTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapTaskResponse ** p = (_nyapc1__getWrapTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapTaskResponse, sizeof(_nyapc1__getWrapTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapTaskResponse(struct soap *soap, _nyapc1__getWrapTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapTaskResponse);
	if (soap_out_PointerTo_nyapc1__getWrapTaskResponse(soap, tag?tag:"nyapc1:getWrapTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapTaskResponse(struct soap *soap, _nyapc1__getWrapTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapTask(struct soap *soap, _nyapc1__getWrapTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapTask(struct soap *soap, const char *tag, int id, _nyapc1__getWrapTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapTask(struct soap *soap, const char *tag, _nyapc1__getWrapTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapTask **)soap_malloc(soap, sizeof(_nyapc1__getWrapTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapTask *)soap_instantiate__nyapc1__getWrapTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapTask ** p = (_nyapc1__getWrapTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapTask, sizeof(_nyapc1__getWrapTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapTask(struct soap *soap, _nyapc1__getWrapTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapTask);
	if (soap_out_PointerTo_nyapc1__getWrapTask(soap, tag?tag:"nyapc1:getWrapTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapTask(struct soap *soap, _nyapc1__getWrapTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTaskResponse(struct soap *soap, _nyapc1__getTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__getTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTaskResponse(struct soap *soap, const char *tag, _nyapc1__getTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__getTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTaskResponse *)soap_instantiate__nyapc1__getTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTaskResponse ** p = (_nyapc1__getTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTaskResponse, sizeof(_nyapc1__getTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTaskResponse(struct soap *soap, _nyapc1__getTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTaskResponse);
	if (soap_out_PointerTo_nyapc1__getTaskResponse(soap, tag?tag:"nyapc1:getTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTaskResponse(struct soap *soap, _nyapc1__getTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getTask(struct soap *soap, _nyapc1__getTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getTask(struct soap *soap, const char *tag, int id, _nyapc1__getTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getTask(struct soap *soap, const char *tag, _nyapc1__getTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getTask **)soap_malloc(soap, sizeof(_nyapc1__getTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getTask *)soap_instantiate__nyapc1__getTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getTask ** p = (_nyapc1__getTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getTask, sizeof(_nyapc1__getTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getTask(struct soap *soap, _nyapc1__getTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getTask);
	if (soap_out_PointerTo_nyapc1__getTask(soap, tag?tag:"nyapc1:getTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getTask(struct soap *soap, _nyapc1__getTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__addWrapperResponse(struct soap *soap, _nyapc1__addWrapperResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__addWrapperResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__addWrapperResponse(struct soap *soap, const char *tag, int id, _nyapc1__addWrapperResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__addWrapperResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__addWrapperResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__addWrapperResponse(struct soap *soap, const char *tag, _nyapc1__addWrapperResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__addWrapperResponse **)soap_malloc(soap, sizeof(_nyapc1__addWrapperResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__addWrapperResponse *)soap_instantiate__nyapc1__addWrapperResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__addWrapperResponse ** p = (_nyapc1__addWrapperResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__addWrapperResponse, sizeof(_nyapc1__addWrapperResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__addWrapperResponse(struct soap *soap, _nyapc1__addWrapperResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__addWrapperResponse);
	if (soap_out_PointerTo_nyapc1__addWrapperResponse(soap, tag?tag:"nyapc1:addWrapperResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__addWrapperResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__addWrapperResponse(struct soap *soap, _nyapc1__addWrapperResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__addWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__addWrapper(struct soap *soap, _nyapc1__addWrapper *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__addWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__addWrapper(struct soap *soap, const char *tag, int id, _nyapc1__addWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__addWrapper);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__addWrapper ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__addWrapper(struct soap *soap, const char *tag, _nyapc1__addWrapper **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__addWrapper **)soap_malloc(soap, sizeof(_nyapc1__addWrapper *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__addWrapper *)soap_instantiate__nyapc1__addWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__addWrapper ** p = (_nyapc1__addWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__addWrapper, sizeof(_nyapc1__addWrapper), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__addWrapper(struct soap *soap, _nyapc1__addWrapper *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__addWrapper);
	if (soap_out_PointerTo_nyapc1__addWrapper(soap, tag?tag:"nyapc1:addWrapper", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__addWrapper ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__addWrapper(struct soap *soap, _nyapc1__addWrapper **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__addWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapperResponse(struct soap *soap, _nyapc1__getWrapperResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapperResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapperResponse(struct soap *soap, const char *tag, int id, _nyapc1__getWrapperResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapperResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapperResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapperResponse(struct soap *soap, const char *tag, _nyapc1__getWrapperResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapperResponse **)soap_malloc(soap, sizeof(_nyapc1__getWrapperResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapperResponse *)soap_instantiate__nyapc1__getWrapperResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapperResponse ** p = (_nyapc1__getWrapperResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapperResponse, sizeof(_nyapc1__getWrapperResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapperResponse(struct soap *soap, _nyapc1__getWrapperResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapperResponse);
	if (soap_out_PointerTo_nyapc1__getWrapperResponse(soap, tag?tag:"nyapc1:getWrapperResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapperResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapperResponse(struct soap *soap, _nyapc1__getWrapperResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapperResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getWrapper(struct soap *soap, _nyapc1__getWrapper *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getWrapper(struct soap *soap, const char *tag, int id, _nyapc1__getWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getWrapper);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getWrapper ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getWrapper(struct soap *soap, const char *tag, _nyapc1__getWrapper **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getWrapper **)soap_malloc(soap, sizeof(_nyapc1__getWrapper *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getWrapper *)soap_instantiate__nyapc1__getWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getWrapper ** p = (_nyapc1__getWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getWrapper, sizeof(_nyapc1__getWrapper), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getWrapper(struct soap *soap, _nyapc1__getWrapper *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getWrapper);
	if (soap_out_PointerTo_nyapc1__getWrapper(soap, tag?tag:"nyapc1:getWrapper", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getWrapper ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getWrapper(struct soap *soap, _nyapc1__getWrapper **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getWrapper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateJobResponse(struct soap *soap, _nyapc1__updateJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateJobResponse(struct soap *soap, const char *tag, int id, _nyapc1__updateJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateJobResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateJobResponse(struct soap *soap, const char *tag, _nyapc1__updateJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateJobResponse **)soap_malloc(soap, sizeof(_nyapc1__updateJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateJobResponse *)soap_instantiate__nyapc1__updateJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateJobResponse ** p = (_nyapc1__updateJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateJobResponse, sizeof(_nyapc1__updateJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateJobResponse(struct soap *soap, _nyapc1__updateJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateJobResponse);
	if (soap_out_PointerTo_nyapc1__updateJobResponse(soap, tag?tag:"nyapc1:updateJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateJobResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateJobResponse(struct soap *soap, _nyapc1__updateJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__updateJob(struct soap *soap, _nyapc1__updateJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__updateJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__updateJob(struct soap *soap, const char *tag, int id, _nyapc1__updateJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__updateJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__updateJob ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__updateJob(struct soap *soap, const char *tag, _nyapc1__updateJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__updateJob **)soap_malloc(soap, sizeof(_nyapc1__updateJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__updateJob *)soap_instantiate__nyapc1__updateJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__updateJob ** p = (_nyapc1__updateJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__updateJob, sizeof(_nyapc1__updateJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__updateJob(struct soap *soap, _nyapc1__updateJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__updateJob);
	if (soap_out_PointerTo_nyapc1__updateJob(soap, tag?tag:"nyapc1:updateJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__updateJob ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__updateJob(struct soap *soap, _nyapc1__updateJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__updateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__hasTaskResponse(struct soap *soap, _nyapc1__hasTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__hasTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__hasTaskResponse(struct soap *soap, const char *tag, int id, _nyapc1__hasTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__hasTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__hasTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__hasTaskResponse(struct soap *soap, const char *tag, _nyapc1__hasTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__hasTaskResponse **)soap_malloc(soap, sizeof(_nyapc1__hasTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__hasTaskResponse *)soap_instantiate__nyapc1__hasTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__hasTaskResponse ** p = (_nyapc1__hasTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__hasTaskResponse, sizeof(_nyapc1__hasTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__hasTaskResponse(struct soap *soap, _nyapc1__hasTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__hasTaskResponse);
	if (soap_out_PointerTo_nyapc1__hasTaskResponse(soap, tag?tag:"nyapc1:hasTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__hasTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__hasTaskResponse(struct soap *soap, _nyapc1__hasTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__hasTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__hasTask(struct soap *soap, _nyapc1__hasTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__hasTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__hasTask(struct soap *soap, const char *tag, int id, _nyapc1__hasTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__hasTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__hasTask ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__hasTask(struct soap *soap, const char *tag, _nyapc1__hasTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__hasTask **)soap_malloc(soap, sizeof(_nyapc1__hasTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__hasTask *)soap_instantiate__nyapc1__hasTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__hasTask ** p = (_nyapc1__hasTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__hasTask, sizeof(_nyapc1__hasTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__hasTask(struct soap *soap, _nyapc1__hasTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__hasTask);
	if (soap_out_PointerTo_nyapc1__hasTask(soap, tag?tag:"nyapc1:hasTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__hasTask ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__hasTask(struct soap *soap, _nyapc1__hasTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__hasTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__addJobResponse(struct soap *soap, _nyapc1__addJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__addJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__addJobResponse(struct soap *soap, const char *tag, int id, _nyapc1__addJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__addJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__addJobResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__addJobResponse(struct soap *soap, const char *tag, _nyapc1__addJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__addJobResponse **)soap_malloc(soap, sizeof(_nyapc1__addJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__addJobResponse *)soap_instantiate__nyapc1__addJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__addJobResponse ** p = (_nyapc1__addJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__addJobResponse, sizeof(_nyapc1__addJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__addJobResponse(struct soap *soap, _nyapc1__addJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__addJobResponse);
	if (soap_out_PointerTo_nyapc1__addJobResponse(soap, tag?tag:"nyapc1:addJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__addJobResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__addJobResponse(struct soap *soap, _nyapc1__addJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__addJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__addJob(struct soap *soap, _nyapc1__addJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__addJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__addJob(struct soap *soap, const char *tag, int id, _nyapc1__addJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__addJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__addJob ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__addJob(struct soap *soap, const char *tag, _nyapc1__addJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__addJob **)soap_malloc(soap, sizeof(_nyapc1__addJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__addJob *)soap_instantiate__nyapc1__addJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__addJob ** p = (_nyapc1__addJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__addJob, sizeof(_nyapc1__addJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__addJob(struct soap *soap, _nyapc1__addJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__addJob);
	if (soap_out_PointerTo_nyapc1__addJob(soap, tag?tag:"nyapc1:addJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__addJob ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__addJob(struct soap *soap, _nyapc1__addJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__addJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJobResponse(struct soap *soap, _nyapc1__getJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJobResponse(struct soap *soap, const char *tag, int id, _nyapc1__getJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJobResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJobResponse(struct soap *soap, const char *tag, _nyapc1__getJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJobResponse **)soap_malloc(soap, sizeof(_nyapc1__getJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJobResponse *)soap_instantiate__nyapc1__getJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJobResponse ** p = (_nyapc1__getJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJobResponse, sizeof(_nyapc1__getJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJobResponse(struct soap *soap, _nyapc1__getJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJobResponse);
	if (soap_out_PointerTo_nyapc1__getJobResponse(soap, tag?tag:"nyapc1:getJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJobResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJobResponse(struct soap *soap, _nyapc1__getJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getJob(struct soap *soap, _nyapc1__getJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getJob(struct soap *soap, const char *tag, int id, _nyapc1__getJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getJob ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getJob(struct soap *soap, const char *tag, _nyapc1__getJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getJob **)soap_malloc(soap, sizeof(_nyapc1__getJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getJob *)soap_instantiate__nyapc1__getJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getJob ** p = (_nyapc1__getJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getJob, sizeof(_nyapc1__getJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getJob(struct soap *soap, _nyapc1__getJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getJob);
	if (soap_out_PointerTo_nyapc1__getJob(soap, tag?tag:"nyapc1:getJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getJob ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getJob(struct soap *soap, _nyapc1__getJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getVersionResponse(struct soap *soap, _nyapc1__getVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getVersionResponse(struct soap *soap, const char *tag, int id, _nyapc1__getVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getVersionResponse(struct soap *soap, const char *tag, _nyapc1__getVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getVersionResponse **)soap_malloc(soap, sizeof(_nyapc1__getVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getVersionResponse *)soap_instantiate__nyapc1__getVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getVersionResponse ** p = (_nyapc1__getVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getVersionResponse, sizeof(_nyapc1__getVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getVersionResponse(struct soap *soap, _nyapc1__getVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getVersionResponse);
	if (soap_out_PointerTo_nyapc1__getVersionResponse(soap, tag?tag:"nyapc1:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getVersionResponse(struct soap *soap, _nyapc1__getVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__getVersion(struct soap *soap, _nyapc1__getVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__getVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__getVersion(struct soap *soap, const char *tag, int id, _nyapc1__getVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__getVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__getVersion ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__getVersion(struct soap *soap, const char *tag, _nyapc1__getVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__getVersion **)soap_malloc(soap, sizeof(_nyapc1__getVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__getVersion *)soap_instantiate__nyapc1__getVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__getVersion ** p = (_nyapc1__getVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__getVersion, sizeof(_nyapc1__getVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__getVersion(struct soap *soap, _nyapc1__getVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__getVersion);
	if (soap_out_PointerTo_nyapc1__getVersion(soap, tag?tag:"nyapc1:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__getVersion ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__getVersion(struct soap *soap, _nyapc1__getVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__addResponse(struct soap *soap, _nyapc1__addResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__addResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__addResponse(struct soap *soap, const char *tag, int id, _nyapc1__addResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__addResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__addResponse ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__addResponse(struct soap *soap, const char *tag, _nyapc1__addResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__addResponse **)soap_malloc(soap, sizeof(_nyapc1__addResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__addResponse *)soap_instantiate__nyapc1__addResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__addResponse ** p = (_nyapc1__addResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__addResponse, sizeof(_nyapc1__addResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__addResponse(struct soap *soap, _nyapc1__addResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__addResponse);
	if (soap_out_PointerTo_nyapc1__addResponse(soap, tag?tag:"nyapc1:addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__addResponse ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__addResponse(struct soap *soap, _nyapc1__addResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__addResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_nyapc1__add(struct soap *soap, _nyapc1__add *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__nyapc1__add))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_nyapc1__add(struct soap *soap, const char *tag, int id, _nyapc1__add *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__nyapc1__add);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _nyapc1__add ** SOAP_FMAC4 soap_in_PointerTo_nyapc1__add(struct soap *soap, const char *tag, _nyapc1__add **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_nyapc1__add **)soap_malloc(soap, sizeof(_nyapc1__add *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_nyapc1__add *)soap_instantiate__nyapc1__add(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_nyapc1__add ** p = (_nyapc1__add **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__nyapc1__add, sizeof(_nyapc1__add), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_nyapc1__add(struct soap *soap, _nyapc1__add *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_nyapc1__add);
	if (soap_out_PointerTo_nyapc1__add(soap, tag?tag:"nyapc1:add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _nyapc1__add ** SOAP_FMAC4 soap_get_PointerTo_nyapc1__add(struct soap *soap, _nyapc1__add **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_nyapc1__add(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonyapc1__Task(struct soap *soap, nyapc1__Task *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_nyapc1__Task))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonyapc1__Task(struct soap *soap, const char *tag, int id, nyapc1__Task *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_nyapc1__Task);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 nyapc1__Task ** SOAP_FMAC4 soap_in_PointerTonyapc1__Task(struct soap *soap, const char *tag, nyapc1__Task **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (nyapc1__Task **)soap_malloc(soap, sizeof(nyapc1__Task *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (nyapc1__Task *)soap_instantiate_nyapc1__Task(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	nyapc1__Task ** p = (nyapc1__Task **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_nyapc1__Task, sizeof(nyapc1__Task), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonyapc1__Task(struct soap *soap, nyapc1__Task *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTonyapc1__Task);
	if (soap_out_PointerTonyapc1__Task(soap, tag?tag:"nyapc1:Task", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 nyapc1__Task ** SOAP_FMAC4 soap_get_PointerTonyapc1__Task(struct soap *soap, nyapc1__Task **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTonyapc1__Task(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonyapc1__JobAtt(struct soap *soap, nyapc1__JobAtt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_nyapc1__JobAtt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonyapc1__JobAtt(struct soap *soap, const char *tag, int id, nyapc1__JobAtt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_nyapc1__JobAtt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 nyapc1__JobAtt ** SOAP_FMAC4 soap_in_PointerTonyapc1__JobAtt(struct soap *soap, const char *tag, nyapc1__JobAtt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (nyapc1__JobAtt **)soap_malloc(soap, sizeof(nyapc1__JobAtt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (nyapc1__JobAtt *)soap_instantiate_nyapc1__JobAtt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	nyapc1__JobAtt ** p = (nyapc1__JobAtt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_nyapc1__JobAtt, sizeof(nyapc1__JobAtt), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonyapc1__JobAtt(struct soap *soap, nyapc1__JobAtt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTonyapc1__JobAtt);
	if (soap_out_PointerTonyapc1__JobAtt(soap, tag?tag:"nyapc1:JobAtt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 nyapc1__JobAtt ** SOAP_FMAC4 soap_get_PointerTonyapc1__JobAtt(struct soap *soap, nyapc1__JobAtt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTonyapc1__JobAtt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, std::vector<nyapc1__JobAtt * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, const std::vector<nyapc1__JobAtt * >*a)
{
	for (std::vector<nyapc1__JobAtt * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTonyapc1__JobAtt(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, const char *tag, int id, const std::vector<nyapc1__JobAtt * >*a, const char *type)
{
	for (std::vector<nyapc1__JobAtt * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTonyapc1__JobAtt(soap, tag, id, &(*i), "nyapc1:JobAtt"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<nyapc1__JobAtt * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, const char *tag, std::vector<nyapc1__JobAtt * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTonyapc1__JobAtt(soap, -1)))
		return NULL;
	nyapc1__JobAtt *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_nyapc1__JobAtt, SOAP_TYPE_std__vectorTemplateOfPointerTonyapc1__JobAtt, sizeof(nyapc1__JobAtt), 1))
				break;
			if (!soap_in_PointerTonyapc1__JobAtt(soap, tag, NULL, "nyapc1:JobAtt"))
				break;
		}
		else
		{
			if (!soap_in_PointerTonyapc1__JobAtt(soap, tag, &n, "nyapc1:JobAtt"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<nyapc1__JobAtt * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTonyapc1__JobAtt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTonyapc1__JobAtt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<nyapc1__JobAtt * >);
		if (size)
			*size = sizeof(std::vector<nyapc1__JobAtt * >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<nyapc1__JobAtt * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<nyapc1__JobAtt * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<nyapc1__JobAtt * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTonyapc1__JobAtt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<nyapc1__JobAtt * > %p -> %p\n", q, p));
	*(std::vector<nyapc1__JobAtt * >*)p = *(std::vector<nyapc1__JobAtt * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), "xsd:int"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
