/* soapStub.h
   Generated by gSOAP 2.7.15 from CrawlerCtrl.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_nyapc1	"http://crawler.nyapc"
#define SOAP_NAMESPACE_OF_nyapc2	"http://dao.crawler.nyapc"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_nyapc1__JobAtt
#define SOAP_TYPE_nyapc1__JobAtt (8)
/* nyapc1:JobAtt */
class SOAP_CMAC nyapc1__JobAtt
{
public:
	std::string *comment;	/* optional element of type xsd:string */
	std::string *createTime;	/* optional element of type xsd:string */
	int id;	/* required element of type xsd:int */
	std::string *jobStat;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::string *seed;	/* optional element of type xsd:string */
	std::string *seedType;	/* optional element of type xsd:string */
	std::string *updateTime;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_nyapc1__JobAtt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         nyapc1__JobAtt() : comment(NULL), createTime(NULL), id(0), jobStat(NULL), name(NULL), seed(NULL), seedType(NULL), updateTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~nyapc1__JobAtt() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__add
#define SOAP_TYPE__nyapc1__add (10)
/* nyapc1:add */
class SOAP_CMAC _nyapc1__add
{
public:
	std::string s;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE__nyapc1__add */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__add() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__add() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__addResponse
#define SOAP_TYPE__nyapc1__addResponse (11)
/* nyapc1:addResponse */
class SOAP_CMAC _nyapc1__addResponse
{
public:
	std::string addReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE__nyapc1__addResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__addResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__addResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getVersion
#define SOAP_TYPE__nyapc1__getVersion (12)
/* nyapc1:getVersion */
class SOAP_CMAC _nyapc1__getVersion
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE__nyapc1__getVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getVersion() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getVersion() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getVersionResponse
#define SOAP_TYPE__nyapc1__getVersionResponse (13)
/* nyapc1:getVersionResponse */
class SOAP_CMAC _nyapc1__getVersionResponse
{
public:
	int getVersionReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE__nyapc1__getVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getVersionResponse() : getVersionReturn(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJob
#define SOAP_TYPE__nyapc1__getJob (14)
/* nyapc1:getJob */
class SOAP_CMAC _nyapc1__getJob
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE__nyapc1__getJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJob() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJob() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobResponse
#define SOAP_TYPE__nyapc1__getJobResponse (15)
/* nyapc1:getJobResponse */
class SOAP_CMAC _nyapc1__getJobResponse
{
public:
	nyapc1__JobAtt *getJobReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:JobAtt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE__nyapc1__getJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobResponse() : getJobReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__addJob
#define SOAP_TYPE__nyapc1__addJob (16)
/* nyapc1:addJob */
class SOAP_CMAC _nyapc1__addJob
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string url;	/* required element of type xsd:string */
	std::string type;	/* required element of type xsd:string */
	std::string comment;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE__nyapc1__addJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__addJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__addJob() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__addJobResponse
#define SOAP_TYPE__nyapc1__addJobResponse (17)
/* nyapc1:addJobResponse */
class SOAP_CMAC _nyapc1__addJobResponse
{
public:
	int addJobReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE__nyapc1__addJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__addJobResponse() : addJobReturn(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__addJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__hasTask
#define SOAP_TYPE__nyapc1__hasTask (18)
/* nyapc1:hasTask */
class SOAP_CMAC _nyapc1__hasTask
{
public:
	int cid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__nyapc1__hasTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__hasTask() : cid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__hasTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__hasTaskResponse
#define SOAP_TYPE__nyapc1__hasTaskResponse (19)
/* nyapc1:hasTaskResponse */
class SOAP_CMAC _nyapc1__hasTaskResponse
{
public:
	bool hasTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__nyapc1__hasTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__hasTaskResponse() : hasTaskReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__hasTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateJob
#define SOAP_TYPE__nyapc1__updateJob (20)
/* nyapc1:updateJob */
class SOAP_CMAC _nyapc1__updateJob
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__nyapc1__updateJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateJob() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateJob() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateJobResponse
#define SOAP_TYPE__nyapc1__updateJobResponse (21)
/* nyapc1:updateJobResponse */
class SOAP_CMAC _nyapc1__updateJobResponse
{
public:
	bool updateJobReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__nyapc1__updateJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateJobResponse() : updateJobReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapper
#define SOAP_TYPE__nyapc1__getWrapper (22)
/* nyapc1:getWrapper */
class SOAP_CMAC _nyapc1__getWrapper
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__nyapc1__getWrapper */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapper() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapper() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapperResponse
#define SOAP_TYPE__nyapc1__getWrapperResponse (23)
/* nyapc1:getWrapperResponse */
class SOAP_CMAC _nyapc1__getWrapperResponse
{
public:
	std::string getWrapperReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__nyapc1__getWrapperResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapperResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapperResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__addWrapper
#define SOAP_TYPE__nyapc1__addWrapper (24)
/* nyapc1:addWrapper */
class SOAP_CMAC _nyapc1__addWrapper
{
public:
	int jobId;	/* required element of type xsd:int */
	std::string type;	/* required element of type xsd:string */
	std::string Wrapper;	/* required element of type xsd:string */
	std::string vargen;	/* required element of type xsd:string */
	std::string comment;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__nyapc1__addWrapper */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__addWrapper() : jobId(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__addWrapper() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__addWrapperResponse
#define SOAP_TYPE__nyapc1__addWrapperResponse (25)
/* nyapc1:addWrapperResponse */
class SOAP_CMAC _nyapc1__addWrapperResponse
{
public:
	bool addWrapperReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__nyapc1__addWrapperResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__addWrapperResponse() : addWrapperReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__addWrapperResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTask
#define SOAP_TYPE__nyapc1__getTask (26)
/* nyapc1:getTask */
class SOAP_CMAC _nyapc1__getTask
{
public:
	int cid;	/* required element of type xsd:int */
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__nyapc1__getTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTask() : cid(0), num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTaskResponse
#define SOAP_TYPE__nyapc1__getTaskResponse (27)
/* nyapc1:getTaskResponse */
class SOAP_CMAC _nyapc1__getTaskResponse
{
public:
	class nyapc1__Task *getTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__nyapc1__getTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTaskResponse() : getTaskReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapTask
#define SOAP_TYPE__nyapc1__getWrapTask (28)
/* nyapc1:getWrapTask */
class SOAP_CMAC _nyapc1__getWrapTask
{
public:
	int cid;	/* required element of type xsd:int */
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__nyapc1__getWrapTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapTask() : cid(0), num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapTaskResponse
#define SOAP_TYPE__nyapc1__getWrapTaskResponse (29)
/* nyapc1:getWrapTaskResponse */
class SOAP_CMAC _nyapc1__getWrapTaskResponse
{
public:
	nyapc1__Task *getWrapTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__nyapc1__getWrapTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapTaskResponse() : getWrapTaskReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__takeWrapTask
#define SOAP_TYPE__nyapc1__takeWrapTask (30)
/* nyapc1:takeWrapTask */
class SOAP_CMAC _nyapc1__takeWrapTask
{
public:
	int cid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__nyapc1__takeWrapTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__takeWrapTask() : cid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__takeWrapTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__takeWrapTaskResponse
#define SOAP_TYPE__nyapc1__takeWrapTaskResponse (31)
/* nyapc1:takeWrapTaskResponse */
class SOAP_CMAC _nyapc1__takeWrapTaskResponse
{
public:
	nyapc1__Task *takeWrapTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__nyapc1__takeWrapTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__takeWrapTaskResponse() : takeWrapTaskReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__takeWrapTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapInvalidTask
#define SOAP_TYPE__nyapc1__getWrapInvalidTask (32)
/* nyapc1:getWrapInvalidTask */
class SOAP_CMAC _nyapc1__getWrapInvalidTask
{
public:
	int cid;	/* required element of type xsd:int */
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__nyapc1__getWrapInvalidTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapInvalidTask() : cid(0), num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapInvalidTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse
#define SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse (33)
/* nyapc1:getWrapInvalidTaskResponse */
class SOAP_CMAC _nyapc1__getWrapInvalidTaskResponse
{
public:
	nyapc1__Task *getWrapInvalidTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__nyapc1__getWrapInvalidTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapInvalidTaskResponse() : getWrapInvalidTaskReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapInvalidTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapper
#define SOAP_TYPE__nyapc1__updateWrapper (34)
/* nyapc1:updateWrapper */
class SOAP_CMAC _nyapc1__updateWrapper
{
public:
	std::string wrap;	/* required element of type xsd:string */
	int id;	/* required element of type xsd:int */
	int taskid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__nyapc1__updateWrapper */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapper() : id(0), taskid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapper() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapperResponse
#define SOAP_TYPE__nyapc1__updateWrapperResponse (35)
/* nyapc1:updateWrapperResponse */
class SOAP_CMAC _nyapc1__updateWrapperResponse
{
public:
	bool updateWrapperReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__nyapc1__updateWrapperResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapperResponse() : updateWrapperReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapperResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapperCheckOk
#define SOAP_TYPE__nyapc1__updateWrapperCheckOk (36)
/* nyapc1:updateWrapperCheckOk */
class SOAP_CMAC _nyapc1__updateWrapperCheckOk
{
public:
	std::string wrap;	/* required element of type xsd:string */
	int wrapId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__nyapc1__updateWrapperCheckOk */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapperCheckOk() : wrapId(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapperCheckOk() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse
#define SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse (37)
/* nyapc1:updateWrapperCheckOkResponse */
class SOAP_CMAC _nyapc1__updateWrapperCheckOkResponse
{
public:
	bool updateWrapperCheckOkReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__nyapc1__updateWrapperCheckOkResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapperCheckOkResponse() : updateWrapperCheckOkReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapperCheckOkResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getStat
#define SOAP_TYPE__nyapc1__getStat (38)
/* nyapc1:getStat */
class SOAP_CMAC _nyapc1__getStat
{
public:
	int cid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__nyapc1__getStat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getStat() : cid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getStat() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getStatResponse
#define SOAP_TYPE__nyapc1__getStatResponse (39)
/* nyapc1:getStatResponse */
class SOAP_CMAC _nyapc1__getStatResponse
{
public:
	int getStatReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__nyapc1__getStatResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getStatResponse() : getStatReturn(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getStatResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__putResult
#define SOAP_TYPE__nyapc1__putResult (40)
/* nyapc1:putResult */
class SOAP_CMAC _nyapc1__putResult
{
public:
	std::string res;	/* required element of type xsd:string */
	int cid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__nyapc1__putResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__putResult() : cid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__putResult() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__putResultResponse
#define SOAP_TYPE__nyapc1__putResultResponse (41)
/* nyapc1:putResultResponse */
class SOAP_CMAC _nyapc1__putResultResponse
{
public:
	bool putResultReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__nyapc1__putResultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__putResultResponse() : putResultReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__putResultResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobID
#define SOAP_TYPE__nyapc1__getJobID (42)
/* nyapc1:getJobID */
class SOAP_CMAC _nyapc1__getJobID
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__nyapc1__getJobID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobID() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobID() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobIDResponse
#define SOAP_TYPE__nyapc1__getJobIDResponse (43)
/* nyapc1:getJobIDResponse */
class SOAP_CMAC _nyapc1__getJobIDResponse
{
public:
	std::vector<int >getJobIDReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__nyapc1__getJobIDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobIDResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobIDResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobs
#define SOAP_TYPE__nyapc1__getJobs (44)
/* nyapc1:getJobs */
class SOAP_CMAC _nyapc1__getJobs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__nyapc1__getJobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobs() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobs() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobsResponse
#define SOAP_TYPE__nyapc1__getJobsResponse (45)
/* nyapc1:getJobsResponse */
class SOAP_CMAC _nyapc1__getJobsResponse
{
public:
	std::vector<nyapc1__JobAtt * >getJobsReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:JobAtt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__nyapc1__getJobsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobsResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobsResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobsWrapStatInvalid
#define SOAP_TYPE__nyapc1__getJobsWrapStatInvalid (46)
/* nyapc1:getJobsWrapStatInvalid */
class SOAP_CMAC _nyapc1__getJobsWrapStatInvalid
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__nyapc1__getJobsWrapStatInvalid */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobsWrapStatInvalid() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobsWrapStatInvalid() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse
#define SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse (47)
/* nyapc1:getJobsWrapStatInvalidResponse */
class SOAP_CMAC _nyapc1__getJobsWrapStatInvalidResponse
{
public:
	std::vector<nyapc1__JobAtt * >getJobsWrapStatInvalidReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:JobAtt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__nyapc1__getJobsWrapStatInvalidResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getJobsWrapStatInvalidResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getJobsWrapStatInvalidResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapGen
#define SOAP_TYPE__nyapc1__getWrapGen (48)
/* nyapc1:getWrapGen */
class SOAP_CMAC _nyapc1__getWrapGen
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__nyapc1__getWrapGen */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapGen() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapGen() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapGenResponse
#define SOAP_TYPE__nyapc1__getWrapGenResponse (49)
/* nyapc1:getWrapGenResponse */
class SOAP_CMAC _nyapc1__getWrapGenResponse
{
public:
	std::string getWrapGenReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__nyapc1__getWrapGenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapGenResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapGenResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapGen
#define SOAP_TYPE__nyapc1__updateWrapGen (50)
/* nyapc1:updateWrapGen */
class SOAP_CMAC _nyapc1__updateWrapGen
{
public:
	std::string wrapgen;	/* required element of type xsd:string */
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__nyapc1__updateWrapGen */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapGen() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapGen() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateWrapGenResponse
#define SOAP_TYPE__nyapc1__updateWrapGenResponse (51)
/* nyapc1:updateWrapGenResponse */
class SOAP_CMAC _nyapc1__updateWrapGenResponse
{
public:
	bool updateWrapGenReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__nyapc1__updateWrapGenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateWrapGenResponse() : updateWrapGenReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateWrapGenResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTaskQueue
#define SOAP_TYPE__nyapc1__getTaskQueue (52)
/* nyapc1:getTaskQueue */
class SOAP_CMAC _nyapc1__getTaskQueue
{
public:
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__nyapc1__getTaskQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTaskQueue() : num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTaskQueue() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTaskQueueResponse
#define SOAP_TYPE__nyapc1__getTaskQueueResponse (53)
/* nyapc1:getTaskQueueResponse */
class SOAP_CMAC _nyapc1__getTaskQueueResponse
{
public:
	nyapc1__Task *getTaskQueueReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__nyapc1__getTaskQueueResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTaskQueueResponse() : getTaskQueueReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTaskQueueResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapTaskQueue
#define SOAP_TYPE__nyapc1__getWrapTaskQueue (54)
/* nyapc1:getWrapTaskQueue */
class SOAP_CMAC _nyapc1__getWrapTaskQueue
{
public:
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__nyapc1__getWrapTaskQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapTaskQueue() : num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapTaskQueue() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapTaskQueueResponse
#define SOAP_TYPE__nyapc1__getWrapTaskQueueResponse (55)
/* nyapc1:getWrapTaskQueueResponse */
class SOAP_CMAC _nyapc1__getWrapTaskQueueResponse
{
public:
	nyapc1__Task *getWrapTaskQueueReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__nyapc1__getWrapTaskQueueResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapTaskQueueResponse() : getWrapTaskQueueReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapTaskQueueResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__takeTask
#define SOAP_TYPE__nyapc1__takeTask (56)
/* nyapc1:takeTask */
class SOAP_CMAC _nyapc1__takeTask
{
public:
	int cid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__nyapc1__takeTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__takeTask() : cid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__takeTask() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__takeTaskResponse
#define SOAP_TYPE__nyapc1__takeTaskResponse (57)
/* nyapc1:takeTaskResponse */
class SOAP_CMAC _nyapc1__takeTaskResponse
{
public:
	nyapc1__Task *takeTaskReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__nyapc1__takeTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__takeTaskResponse() : takeTaskReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__takeTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTaskByJobId
#define SOAP_TYPE__nyapc1__getTaskByJobId (58)
/* nyapc1:getTaskByJobId */
class SOAP_CMAC _nyapc1__getTaskByJobId
{
public:
	int cid;	/* required element of type xsd:int */
	int jid;	/* required element of type xsd:int */
	std::string type;	/* required element of type xsd:string */
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__nyapc1__getTaskByJobId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTaskByJobId() : cid(0), jid(0), num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTaskByJobId() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getTaskByJobIdResponse
#define SOAP_TYPE__nyapc1__getTaskByJobIdResponse (59)
/* nyapc1:getTaskByJobIdResponse */
class SOAP_CMAC _nyapc1__getTaskByJobIdResponse
{
public:
	nyapc1__Task *getTaskByJobIdReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__nyapc1__getTaskByJobIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getTaskByJobIdResponse() : getTaskByJobIdReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getTaskByJobIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__delJob
#define SOAP_TYPE__nyapc1__delJob (60)
/* nyapc1:delJob */
class SOAP_CMAC _nyapc1__delJob
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__nyapc1__delJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__delJob() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__delJob() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__delJobResponse
#define SOAP_TYPE__nyapc1__delJobResponse (61)
/* nyapc1:delJobResponse */
class SOAP_CMAC _nyapc1__delJobResponse
{
public:
	bool delJobReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__nyapc1__delJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__delJobResponse() : delJobReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__delJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateJobUrl
#define SOAP_TYPE__nyapc1__updateJobUrl (62)
/* nyapc1:updateJobUrl */
class SOAP_CMAC _nyapc1__updateJobUrl
{
public:
	int id;	/* required element of type xsd:int */
	std::string url;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__nyapc1__updateJobUrl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateJobUrl() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateJobUrl() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__updateJobUrlResponse
#define SOAP_TYPE__nyapc1__updateJobUrlResponse (63)
/* nyapc1:updateJobUrlResponse */
class SOAP_CMAC _nyapc1__updateJobUrlResponse
{
public:
	bool updateJobUrlReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__nyapc1__updateJobUrlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__updateJobUrlResponse() : updateJobUrlReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__updateJobUrlResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId
#define SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId (64)
/* nyapc1:getWrapInvalidTaskByJobId */
class SOAP_CMAC _nyapc1__getWrapInvalidTaskByJobId
{
public:
	int cid;	/* required element of type xsd:int */
	int jid;	/* required element of type xsd:int */
	std::string type;	/* required element of type xsd:string */
	int num;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapInvalidTaskByJobId() : cid(0), jid(0), num(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapInvalidTaskByJobId() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse
#define SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse (65)
/* nyapc1:getWrapInvalidTaskByJobIdResponse */
class SOAP_CMAC _nyapc1__getWrapInvalidTaskByJobIdResponse
{
public:
	nyapc1__Task *getWrapInvalidTaskByJobIdReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type nyapc1:Task */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__nyapc1__getWrapInvalidTaskByJobIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapInvalidTaskByJobIdResponse() : getWrapInvalidTaskByJobIdReturn(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapInvalidTaskByJobIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapId
#define SOAP_TYPE__nyapc1__getWrapId (66)
/* nyapc1:getWrapId */
class SOAP_CMAC _nyapc1__getWrapId
{
public:
	int jid;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__nyapc1__getWrapId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapId() : jid(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapId() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWrapIdResponse
#define SOAP_TYPE__nyapc1__getWrapIdResponse (67)
/* nyapc1:getWrapIdResponse */
class SOAP_CMAC _nyapc1__getWrapIdResponse
{
public:
	std::vector<int >getWrapIdReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__nyapc1__getWrapIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWrapIdResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWrapIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWraptype
#define SOAP_TYPE__nyapc1__getWraptype (68)
/* nyapc1:getWraptype */
class SOAP_CMAC _nyapc1__getWraptype
{
public:
	int id;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__nyapc1__getWraptype */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWraptype() : id(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWraptype() { }
};
#endif

#ifndef SOAP_TYPE__nyapc1__getWraptypeResponse
#define SOAP_TYPE__nyapc1__getWraptypeResponse (69)
/* nyapc1:getWraptypeResponse */
class SOAP_CMAC _nyapc1__getWraptypeResponse
{
public:
	std::string getWraptypeReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__nyapc1__getWraptypeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _nyapc1__getWraptypeResponse() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_nyapc1__getWraptypeResponse() { }
};
#endif

#ifndef SOAP_TYPE_nyapc2__AttSuperClass
#define SOAP_TYPE_nyapc2__AttSuperClass (70)
/* nyapc2:AttSuperClass */
class SOAP_CMAC nyapc2__AttSuperClass
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_nyapc2__AttSuperClass */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         nyapc2__AttSuperClass() : soap(NULL) { this->soap_default(NULL); }
	virtual ~nyapc2__AttSuperClass() { }
};
#endif

#ifndef SOAP_TYPE_nyapc1__Task
#define SOAP_TYPE_nyapc1__Task (9)
/* nyapc1:Task */
class SOAP_CMAC nyapc1__Task : public nyapc2__AttSuperClass
{
public:
	std::string *ids;	/* optional element of type xsd:string */
	int job_USCOREid;	/* required element of type xsd:int */
	int taskId;	/* required element of type xsd:int */
	std::string *type;	/* optional element of type xsd:string */
	std::string *urls;	/* optional element of type xsd:string */
	int wrap_USCOREid;	/* required element of type xsd:int */
	int wrap_USCOREversion;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_nyapc1__Task */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         nyapc1__Task() : ids(NULL), job_USCOREid(0), taskId(0), type(NULL), urls(NULL), wrap_USCOREid(0), wrap_USCOREversion(0) { this->soap_default(NULL); }
	virtual ~nyapc1__Task() { }
};
#endif

#ifndef SOAP_TYPE___nyapc1__add
#define SOAP_TYPE___nyapc1__add (82)
/* Operation wrapper: */
struct __nyapc1__add
{
public:
	_nyapc1__add *nyapc1__add;	/* optional element of type nyapc1:add */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getVersion
#define SOAP_TYPE___nyapc1__getVersion (86)
/* Operation wrapper: */
struct __nyapc1__getVersion
{
public:
	_nyapc1__getVersion *nyapc1__getVersion;	/* optional element of type nyapc1:getVersion */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getJob
#define SOAP_TYPE___nyapc1__getJob (90)
/* Operation wrapper: */
struct __nyapc1__getJob
{
public:
	_nyapc1__getJob *nyapc1__getJob;	/* optional element of type nyapc1:getJob */
};
#endif

#ifndef SOAP_TYPE___nyapc1__addJob
#define SOAP_TYPE___nyapc1__addJob (94)
/* Operation wrapper: */
struct __nyapc1__addJob
{
public:
	_nyapc1__addJob *nyapc1__addJob;	/* optional element of type nyapc1:addJob */
};
#endif

#ifndef SOAP_TYPE___nyapc1__hasTask
#define SOAP_TYPE___nyapc1__hasTask (98)
/* Operation wrapper: */
struct __nyapc1__hasTask
{
public:
	_nyapc1__hasTask *nyapc1__hasTask;	/* optional element of type nyapc1:hasTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__updateJob
#define SOAP_TYPE___nyapc1__updateJob (102)
/* Operation wrapper: */
struct __nyapc1__updateJob
{
public:
	_nyapc1__updateJob *nyapc1__updateJob;	/* optional element of type nyapc1:updateJob */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapper
#define SOAP_TYPE___nyapc1__getWrapper (106)
/* Operation wrapper: */
struct __nyapc1__getWrapper
{
public:
	_nyapc1__getWrapper *nyapc1__getWrapper;	/* optional element of type nyapc1:getWrapper */
};
#endif

#ifndef SOAP_TYPE___nyapc1__addWrapper
#define SOAP_TYPE___nyapc1__addWrapper (110)
/* Operation wrapper: */
struct __nyapc1__addWrapper
{
public:
	_nyapc1__addWrapper *nyapc1__addWrapper;	/* optional element of type nyapc1:addWrapper */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getTask
#define SOAP_TYPE___nyapc1__getTask (114)
/* Operation wrapper: */
struct __nyapc1__getTask
{
public:
	_nyapc1__getTask *nyapc1__getTask;	/* optional element of type nyapc1:getTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapTask
#define SOAP_TYPE___nyapc1__getWrapTask (118)
/* Operation wrapper: */
struct __nyapc1__getWrapTask
{
public:
	_nyapc1__getWrapTask *nyapc1__getWrapTask;	/* optional element of type nyapc1:getWrapTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__takeWrapTask
#define SOAP_TYPE___nyapc1__takeWrapTask (122)
/* Operation wrapper: */
struct __nyapc1__takeWrapTask
{
public:
	_nyapc1__takeWrapTask *nyapc1__takeWrapTask;	/* optional element of type nyapc1:takeWrapTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapInvalidTask
#define SOAP_TYPE___nyapc1__getWrapInvalidTask (126)
/* Operation wrapper: */
struct __nyapc1__getWrapInvalidTask
{
public:
	_nyapc1__getWrapInvalidTask *nyapc1__getWrapInvalidTask;	/* optional element of type nyapc1:getWrapInvalidTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__updateWrapper
#define SOAP_TYPE___nyapc1__updateWrapper (130)
/* Operation wrapper: */
struct __nyapc1__updateWrapper
{
public:
	_nyapc1__updateWrapper *nyapc1__updateWrapper;	/* optional element of type nyapc1:updateWrapper */
};
#endif

#ifndef SOAP_TYPE___nyapc1__updateWrapperCheckOk
#define SOAP_TYPE___nyapc1__updateWrapperCheckOk (134)
/* Operation wrapper: */
struct __nyapc1__updateWrapperCheckOk
{
public:
	_nyapc1__updateWrapperCheckOk *nyapc1__updateWrapperCheckOk;	/* optional element of type nyapc1:updateWrapperCheckOk */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getStat
#define SOAP_TYPE___nyapc1__getStat (138)
/* Operation wrapper: */
struct __nyapc1__getStat
{
public:
	_nyapc1__getStat *nyapc1__getStat;	/* optional element of type nyapc1:getStat */
};
#endif

#ifndef SOAP_TYPE___nyapc1__putResult
#define SOAP_TYPE___nyapc1__putResult (142)
/* Operation wrapper: */
struct __nyapc1__putResult
{
public:
	_nyapc1__putResult *nyapc1__putResult;	/* optional element of type nyapc1:putResult */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getJobID
#define SOAP_TYPE___nyapc1__getJobID (146)
/* Operation wrapper: */
struct __nyapc1__getJobID
{
public:
	_nyapc1__getJobID *nyapc1__getJobID;	/* optional element of type nyapc1:getJobID */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getJobs
#define SOAP_TYPE___nyapc1__getJobs (150)
/* Operation wrapper: */
struct __nyapc1__getJobs
{
public:
	_nyapc1__getJobs *nyapc1__getJobs;	/* optional element of type nyapc1:getJobs */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getJobsWrapStatInvalid
#define SOAP_TYPE___nyapc1__getJobsWrapStatInvalid (154)
/* Operation wrapper: */
struct __nyapc1__getJobsWrapStatInvalid
{
public:
	_nyapc1__getJobsWrapStatInvalid *nyapc1__getJobsWrapStatInvalid;	/* optional element of type nyapc1:getJobsWrapStatInvalid */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapGen
#define SOAP_TYPE___nyapc1__getWrapGen (158)
/* Operation wrapper: */
struct __nyapc1__getWrapGen
{
public:
	_nyapc1__getWrapGen *nyapc1__getWrapGen;	/* optional element of type nyapc1:getWrapGen */
};
#endif

#ifndef SOAP_TYPE___nyapc1__updateWrapGen
#define SOAP_TYPE___nyapc1__updateWrapGen (162)
/* Operation wrapper: */
struct __nyapc1__updateWrapGen
{
public:
	_nyapc1__updateWrapGen *nyapc1__updateWrapGen;	/* optional element of type nyapc1:updateWrapGen */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getTaskQueue
#define SOAP_TYPE___nyapc1__getTaskQueue (166)
/* Operation wrapper: */
struct __nyapc1__getTaskQueue
{
public:
	_nyapc1__getTaskQueue *nyapc1__getTaskQueue;	/* optional element of type nyapc1:getTaskQueue */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapTaskQueue
#define SOAP_TYPE___nyapc1__getWrapTaskQueue (170)
/* Operation wrapper: */
struct __nyapc1__getWrapTaskQueue
{
public:
	_nyapc1__getWrapTaskQueue *nyapc1__getWrapTaskQueue;	/* optional element of type nyapc1:getWrapTaskQueue */
};
#endif

#ifndef SOAP_TYPE___nyapc1__takeTask
#define SOAP_TYPE___nyapc1__takeTask (174)
/* Operation wrapper: */
struct __nyapc1__takeTask
{
public:
	_nyapc1__takeTask *nyapc1__takeTask;	/* optional element of type nyapc1:takeTask */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getTaskByJobId
#define SOAP_TYPE___nyapc1__getTaskByJobId (178)
/* Operation wrapper: */
struct __nyapc1__getTaskByJobId
{
public:
	_nyapc1__getTaskByJobId *nyapc1__getTaskByJobId;	/* optional element of type nyapc1:getTaskByJobId */
};
#endif

#ifndef SOAP_TYPE___nyapc1__delJob
#define SOAP_TYPE___nyapc1__delJob (182)
/* Operation wrapper: */
struct __nyapc1__delJob
{
public:
	_nyapc1__delJob *nyapc1__delJob;	/* optional element of type nyapc1:delJob */
};
#endif

#ifndef SOAP_TYPE___nyapc1__updateJobUrl
#define SOAP_TYPE___nyapc1__updateJobUrl (186)
/* Operation wrapper: */
struct __nyapc1__updateJobUrl
{
public:
	_nyapc1__updateJobUrl *nyapc1__updateJobUrl;	/* optional element of type nyapc1:updateJobUrl */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId
#define SOAP_TYPE___nyapc1__getWrapInvalidTaskByJobId (190)
/* Operation wrapper: */
struct __nyapc1__getWrapInvalidTaskByJobId
{
public:
	_nyapc1__getWrapInvalidTaskByJobId *nyapc1__getWrapInvalidTaskByJobId;	/* optional element of type nyapc1:getWrapInvalidTaskByJobId */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWrapId
#define SOAP_TYPE___nyapc1__getWrapId (194)
/* Operation wrapper: */
struct __nyapc1__getWrapId
{
public:
	_nyapc1__getWrapId *nyapc1__getWrapId;	/* optional element of type nyapc1:getWrapId */
};
#endif

#ifndef SOAP_TYPE___nyapc1__getWraptype
#define SOAP_TYPE___nyapc1__getWraptype (198)
/* Operation wrapper: */
struct __nyapc1__getWraptype
{
public:
	_nyapc1__getWraptype *nyapc1__getWraptype;	/* optional element of type nyapc1:getWraptype */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (199)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (200)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (202)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (205)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (206)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
